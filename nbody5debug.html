<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebGPU N-Body (merge + split) – nbody5</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #ui { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: #fff; font-family: system-ui, sans-serif; padding: 10px; font-size: 12px; }
    #ui label { display:block; margin: 6px 0 2px; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="ui">
    <div><b>Controls</b></div>
    <label>G: <span id="gVal">0.30</span></label>
    <input id="g" type="range" min="0.01" max="5.0" step="0.01" value="0.30" />

    <label>dt: <span id="dtVal">0.20</span></label>
    <input id="dt" type="range" min="0.01" max="1.00" step="0.01" value="0.20" />

    <label>Restitution (alpha): <span id="restVal">1.00</span></label>
    <input id="rest" type="range" min="0.0" max="1.0" step="0.01" value="1.00" />

    <!-- New: Radius factor slider -->
    <label>Radius factor: <span id="rfVal">2</span></label>
    <input id="rf" type="range" min="1" max="100" step="1" value="2" />

    <!-- New: Repulsion (R) slider -->
    <label>Repulsion R: <span id="repVal">10</span></label>
    <input id="rep" type="range" min="0" max="100" step="1" value="10" />

    <!-- New: Spin and Damping sliders -->
    <label>Spin: <span id="spinVal">0.00</span></label>
    <input id="spin" type="range" min="-2.0" max="2.0" step="0.01" value="0.00" />

    <label>Damping: <span id="dampVal">1.00</span></label>
    <input id="damp" type="range" min="0.0" max="1.0" step="0.001" value="1.00" />

    <!-- New: Radiative damping -->
    <label>Radiative: <span id="radVal">0.005</span></label>
    <input id="rad" type="range" min="0.0" max="0.1" step="0.001" value="0.005" />

    <!-- New: Collision controls -->
    <label><input id="collideOn" type="checkbox" checked /> Collisions (detect/split)</label>
    <label>Collide every k frames: <span id="collideKVal">1</span></label>
    <input id="collideK" type="range" min="1" max="8" step="1" value="1" />

    <!-- New: Octree (Morton) indexing for collisions -->
    <label><input id="octOn" type="checkbox" checked /> Use octree index (Morton)</label>
    <label>Neighbor window: <span id="winVal">64</span></label>
    <input id="win" type="range" min="8" max="256" step="8" value="64" />

  <!-- Barnes–Hut (always enabled) -->
    <label>Opening angle θ: <span id="thetaVal">0.60</span></label>
    <input id="theta" type="range" min="0.2" max="1.0" step="0.05" value="0.60" />
    <label>Cluster size: <span id="clSizeVal">64</span></label>
    <input id="clSize" type="range" min="16" max="256" step="16" value="64" />

    <!-- Minimal debug controls -->
    <label><input id="showPairs" type="checkbox" checked /> Show pairwise force vectors</label>

    <div id="stats" style="margin-top:6px; opacity: 0.85;"></div>
  </div>

  <script>
  "use strict";
  (async () => {
    const canvas = document.getElementById('c');
    const statsDiv = document.getElementById('stats');
    if (!('gpu' in navigator)) { alert('WebGPU not supported'); return; }

    const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' }) || await navigator.gpu.requestAdapter();
    if (!adapter) { alert('No GPU adapter'); return; }
    // Some platforms default to conservative limits. If the adapter reports it
    // supports a higher maxStorageBuffersPerShaderStage, request a device with
    // that higher limit so our compute pipelines with many storage buffers can
    // be created. If not supported, we'll proceed with the default device and
    // fall back (already implemented) to omit optional visualization bindings.
    const desiredStorageBuffers = 10;
    let device;
    try {
      const supportStorage = adapter.limits && adapter.limits.maxStorageBuffersPerShaderStage;
      const requiredLimits = {};
      if (supportStorage && supportStorage >= desiredStorageBuffers) {
        requiredLimits.maxStorageBuffersPerShaderStage = desiredStorageBuffers;
      }
      device = await adapter.requestDevice({ requiredLimits });
    } catch (e) {
      console.warn('requestDevice with increased limits failed, falling back to default requestDevice()', e);
      device = await adapter.requestDevice();
    }
    const context = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();
    const WG_SIZE = 128; // tuned workgroup size
    const MORTON_BITS = 10; // 10 bits/axis => 1024^3 grid

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      context.configure({ device, format, alphaMode: 'opaque' });
    }
    resize();
    addEventListener('resize', resize);
    // overlay removed for simplification; all debug visualization will be GPU rendered

    // Simple parameters/UI
    let G = 3.30;
    let dt = 0.50;
    let restitution = 1.00; // used as alpha in energy restitution
    let radiusFactor = 2.0; // new: scales collision radii
    let R = 10.0;           // new: short-range repulsion strength (like nbody3)
    let spin = 0.00;        // new: tangential velocity injection rate (rad/s)
    let damping = 1.00;     // CHANGED: damping factor (0..1), applied directly to velocity (1.0 = no damping)
    let radiativeDamping = 0.005; // new: radiative damping coefficient
    let collisionsEnabled = true; // new: toggle collisions
    let collideEvery = 1;         // new: run collisions every k frames
    let useMorton = true;         // new: toggle morton/octree indexing
    let neighborWindow = 64;      // new: neighbors to scan on each side in Morton order
    let useBH = true;             // new: Barnes–Hut toggle
    let theta = 0.60;             // new: BH opening angle
    let clusterSize = 64;         // new: leaf capacity approximation

    const gEl = document.getElementById('g');
    const gVal = document.getElementById('gVal');
    gEl.addEventListener('input', () => { G = parseFloat(gEl.value); gVal.textContent = G.toFixed(2); writeSimParams(); });
    const dtEl = document.getElementById('dt');
    const dtVal = document.getElementById('dtVal');
    dtEl.addEventListener('input', () => { dt = parseFloat(dtEl.value); dtVal.textContent = dt.toFixed(2); writeSimParams(); });
    const restEl = document.getElementById('rest');
    const restVal = document.getElementById('restVal');
    restEl.addEventListener('input', () => { restitution = parseFloat(restEl.value); restVal.textContent = restitution.toFixed(2); writeRest(); });

    // New: radius factor UI wiring
    const rfEl = document.getElementById('rf');
    const rfVal = document.getElementById('rfVal');
    rfEl.addEventListener('input', () => { radiusFactor = parseFloat(rfEl.value); rfVal.textContent = String(rfEl.value); writeRadius(); });

    // New: repulsion UI wiring
    const repEl = document.getElementById('rep');
    const repVal = document.getElementById('repVal');
    repEl.addEventListener('input', () => { R = parseFloat(repEl.value); repVal.textContent = String(repEl.value); writeRepulse(); });

    // New: spin + damping UI wiring
    const spinEl = document.getElementById('spin');
    const spinVal = document.getElementById('spinVal');
    spinEl.addEventListener('input', () => { spin = parseFloat(spinEl.value); spinVal.textContent = spin.toFixed(2); writeSpin(); });
    const dampEl = document.getElementById('damp');
    const dampVal = document.getElementById('dampVal');
    dampEl.addEventListener('input', () => { damping = parseFloat(dampEl.value); dampVal.textContent = damping.toFixed(3); writeDamp(); });

    // New: radiative damping UI wiring
    const radEl = document.getElementById('rad');
    const radVal = document.getElementById('radVal');
    radEl.addEventListener('input', () => { radiativeDamping = parseFloat(radEl.value); radVal.textContent = radiativeDamping.toFixed(3); writeRad(); });

    // New: collision UI wiring
    const collideOnEl = document.getElementById('collideOn');
    const collideKEl = document.getElementById('collideK');
    const collideKVal = document.getElementById('collideKVal');
    collideOnEl.addEventListener('change', () => { collisionsEnabled = collideOnEl.checked; });
    collideKEl.addEventListener('input', () => { collideEvery = parseInt(collideKEl.value); collideKVal.textContent = String(collideEvery); });

    // New: Morton/octree UI wiring
    const octOnEl = document.getElementById('octOn');
    const winEl = document.getElementById('win');
    const winVal = document.getElementById('winVal');
    octOnEl.addEventListener('change', () => { useMorton = octOnEl.checked; });
    winEl.addEventListener('input', () => { neighborWindow = parseInt(winEl.value); winVal.textContent = String(neighborWindow); writeWindow(); });

    // New: BH UI wiring
  const thetaEl = document.getElementById('theta');
  const thetaVal = document.getElementById('thetaVal');
  const clSizeEl = document.getElementById('clSize');
  const clSizeVal = document.getElementById('clSizeVal');
  // Barnes–Hut is always enabled; user cannot toggle it off.
  // Keep theta/cluster size controls wired below.
    thetaEl.addEventListener('input', () => { theta = parseFloat(thetaEl.value); thetaVal.textContent = theta.toFixed(2); writeBHParams(); });
    clSizeEl.addEventListener('input', () => { clusterSize = parseInt(clSizeEl.value); clSizeVal.textContent = String(clusterSize); writeBHParams(); });

    // Basic math helpers (column-major matrices like WebGPU expects)
    function perspective(fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      return new Float32Array([
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * far * near) * nf, 0
      ]);
    }
    function normalize(a) { const l = Math.hypot(a[0],a[1],a[2]) || 1; return [a[0]/l, a[1]/l, a[2]/l]; }
    function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
    function dot(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
    function lookAt(eye, center, up) {
      const f = normalize([center[0]-eye[0], center[1]-eye[1], center[2]-eye[2]]);
      const s = normalize(cross(f, up));
      const u = cross(s, f);
      return new Float32Array([
        s[0], u[0], -f[0], 0,
        s[1], u[1], -f[1], 0,
        s[2], u[2], -f[2], 0,
        - (s[0]*eye[0] + s[1]*eye[1] + s[2]*eye[2]),
        - (u[0]*eye[0] + u[1]*eye[1] + u[2]*eye[2]),
        (f[0]*eye[0] + f[1]*eye[1] + f[2]*eye[2]),
        1
      ]);
    }

    // Orbit camera (simple)
    let az = 0.3, el = 0.6, dist = 2000.0;
    function updateView() {
      const ce = Math.cos(el), se = Math.sin(el), sa = Math.sin(az), ca = Math.cos(az);
      const eye = [ dist * ce * sa, dist * se, dist * ce * ca ];
      view = lookAt(eye, [0,0,0], [0,1,0]);
    }
    (function orbitControls(){
      let drag=false, lx=0, ly=0;
      canvas.addEventListener('mousedown', (e)=>{ if(e.button===0){ drag=true; lx=e.clientX; ly=e.clientY; }});
      addEventListener('mouseup', ()=> drag=false);
      addEventListener('mousemove', (e)=>{
        if(!drag) return; const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY;
        az += dx * 0.005; el += dy * 0.005;
        const minEl = -Math.PI/2 + 0.01;
        const maxEl =  Math.PI/2 - 0.01;
        el = Math.max(minEl, Math.min(maxEl, el));
      });
      canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); dist *= Math.exp(e.deltaY * 0.001); dist = Math.max(10, Math.min(1e6, dist)); }, {passive:false});
    })();

    // Simulation setup (simple random sphere)
    const particleCount = 32; // keep moderate (O(N^2) pair find)
    const stride = 4; // vec4
    const stateBytes = particleCount * stride * 4;

    function makeBuf(size, usage) { return device.createBuffer({ size, usage }); }
    function bufFrom(arr, usage) {
      const b = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
      new Float32Array(b.getMappedRange()).set(arr);
      b.unmap(); return b;
    }

    const posInit = new Float32Array(particleCount * stride);
    const velInit = new Float32Array(particleCount * stride);
    const massInit = new Float32Array(particleCount);
    const rad = 800.0;
    for (let i=0;i<particleCount;i++){
      let x,y,z; do { x=(Math.random()*2-1)*rad; y=(Math.random()*2-1)*rad; z=(Math.random()*2-1)*rad; } while (x*x+y*y+z*z>rad*rad);
      const o=i*stride; posInit[o]=x; posInit[o+1]=y; posInit[o+2]=z; posInit[o+3]=0;
      velInit[o]=0; velInit[o+1]=0; velInit[o+2]=0; velInit[o+3]=0;
      massInit[i]=1.0; // start uniform
    }
  let posA = bufFrom(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
  let posB = makeBuf(stateBytes, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
    let velA = bufFrom(velInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
    let velB = makeBuf(stateBytes, GPUBufferUsage.STORAGE);
    const masses = bufFrom(massInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);

    // Collision pair buffers (very simple)
    const MAX_PAIRS = Math.min(particleCount * 8, 262144);
  const pairBuf = device.createBuffer({ size: MAX_PAIRS * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });
  const pairCount = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
  // Visualization-only pair buffer (CPU-writable) to avoid mutating the simulation pairBuf
  const visPairBuf = device.createBuffer({ size: MAX_PAIRS * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
  // visualization pair count (atomic)
  const visPairCountBuf = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
  // Small persistent readback buffer for debugging pairCount
  // CPU readback buffers removed to keep GPU-only rendering and avoid stalls.
    const locks = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const claims = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    // Morton keys + index buffers
    const mortonKeys = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const mortonIdx  = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });

    // Uniforms
    // SimParams is 4 floats (16 bytes): dt, G, eps, num
    const simParams = new Float32Array([dt, G, 1.0, particleCount]); // eps defaults to 1.0
    const simParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSimParams(){ device.queue.writeBuffer(simParamsBuf, 0, simParams.buffer, simParams.byteOffset, simParams.byteLength); }
    writeSimParams();

    const restParams = new Float32Array([restitution, 0,0,0]);
    const restBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRest(){ restParams[0]=restitution; device.queue.writeBuffer(restBuf, 0, restParams); }
    writeRest();

    // New: collision radius factor uniform
    const radiusParams = new Float32Array([radiusFactor, 0,0,0]);
    const radiusBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRadius(){ radiusParams[0]=radiusFactor; device.queue.writeBuffer(radiusBuf, 0, radiusParams); }
    writeRadius();

    // New: damping uniform
    const dampParams = new Float32Array([damping, 0,0,0]);
    const dampBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeDamp(){ dampParams[0]=damping; device.queue.writeBuffer(dampBuf, 0, dampParams); }
    writeDamp();

    // New: spin uniform
    const spinParams = new Float32Array([spin, 0,0,0]);
    const spinBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSpin(){ spinParams[0]=spin; device.queue.writeBuffer(spinBuf, 0, spinParams); }
    writeSpin();

    // New: repulsion (R) uniform
    const repulseParams = new Float32Array([R, 0,0,0]);
    const repulseBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRepulse(){ repulseParams[0]=R; device.queue.writeBuffer(repulseBuf, 0, repulseParams); }
    writeRepulse();

    // New: radiative damping uniform
    const radParams = new Float32Array([radiativeDamping, 0,0,0]);
    const radBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRad(){ radParams[0]=radiativeDamping; device.queue.writeBuffer(radBuf, 0, radParams); }
    writeRad();

    // New: Morton/octree uniforms (extent maps [-extent,extent] to [0,1])
    let mortonExtent = 4096.0;
    const mortonParams = new Float32Array([mortonExtent, 0,0,0]);
    const mortonParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeMorton(){ mortonParams[0]=mortonExtent; device.queue.writeBuffer(mortonParamsBuf, 0, mortonParams); }
    writeMorton();

    // Bitonic sort stage params (j,k,n)
    const sortParams = new Uint32Array([0, 0, particleCount, 0]);
    const sortParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSortJK(j, k){ sortParams[0] = j; sortParams[1] = k; device.queue.writeBuffer(sortParamsBuf, 0, sortParams); }

    // Neighbor window uniform for Morton collision detection
    const windowParams = new Uint32Array([neighborWindow, 0, 0, 0]);
    const windowBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeWindow(){ windowParams[0] = neighborWindow; device.queue.writeBuffer(windowBuf, 0, windowParams); }
    writeWindow();

    // New: BH uniforms and cluster buffers
    const bhParams = new Float32Array([theta, 0,0,0]);
    const bhBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    // Cluster params: size, count
    let clusterCountUsed = Math.ceil(particleCount / clusterSize);
    const clParams = new Uint32Array([clusterSize, clusterCountUsed, 0, 0]);
    const clBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeBHParams(){
      bhParams[0] = theta; device.queue.writeBuffer(bhBuf, 0, bhParams);
      clusterCountUsed = Math.ceil(particleCount / Math.max(1, clusterSize));
      clParams[0] = clusterSize; clParams[1] = clusterCountUsed;
      device.queue.writeBuffer(clBuf, 0, clParams);
    }
    writeBHParams();
    // Allocate max cluster buffers for min leaf size 16
    const MIN_CLUSTER = 16;
    const maxClusters = Math.ceil(particleCount / MIN_CLUSTER);
    const clMassBuf = device.createBuffer({ size: maxClusters * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const clComBuf  = device.createBuffer({ size: maxClusters * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });

    // WGSL Shaders
    // Load all WGSL shaders from external files
    const integrateWGSL = await (await fetch('scripts/integrate.wgsl')).text();
    const detectPairsWGSL = await (await fetch('scripts/detectPairs.wgsl')).text();
    const splitWGSL = await (await fetch('scripts/split.wgsl')).text();
    const renderWGSL = await (await fetch('scripts/render.wgsl')).text();
    const mortonWGSL = await (await fetch('scripts/morton.wgsl')).text();
    const bitonicWGSL = await (await fetch('scripts/bitonic.wgsl')).text();
    const detectMortonWGSL = await (await fetch('scripts/detectMorton.wgsl')).text();
    const clusterReduceWGSL = await (await fetch('scripts/clusterReduce.wgsl')).text();
    const integrateBHWGSL = await (await fetch('scripts/integrateBH.wgsl')).text();
 
    // Matrices + viewport params in a 10-vec4 uniform for alignment
    let proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1e7);
    let view = lookAt([0, 0, dist], [0,0,0], [0,1,0]);
    const mats = new Float32Array(40); // 10 * vec4
  const matsBuf = device.createBuffer({ size: mats.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    function writeMats() {
      proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1e7);
      updateView();
      mats.set(proj, 0);
      mats.set(view, 16);
      mats[32] = canvas.width;  // viewport W
      mats[33] = canvas.height; // viewport H
      mats[34] = 18.0;          // sprite sizeScale in pixels
      mats[35] = 1.0 / Math.log(1.0 + 8.0); // inverse log(maxMass+1)
      device.queue.writeBuffer(matsBuf, 0, mats);
    }
    writeMats();

    // Pipelines (compute + render)
  // integrate (direct N^2) pipeline intentionally not created here; we always use Barnes–Hut integrate pipeline (integrateBH)
    const detectModule = device.createShaderModule({ code: detectPairsWGSL });
    const detectPipe = device.createComputePipeline({ layout: 'auto', compute: { module: detectModule, entryPoint: 'main' } });
    const splitModule = device.createShaderModule({ code: splitWGSL });
    const splitPipe = device.createComputePipeline({ layout: 'auto', compute: { module: splitModule, entryPoint: 'main' } });

    const renderModule = device.createShaderModule({ code: renderWGSL });
    const renderPipe = device.createRenderPipeline({
      layout: 'auto',
      vertex: { module: renderModule, entryPoint: 'vs' },
      fragment: { module: renderModule, entryPoint: 'fs', targets: [{ format, blend: { color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' }, alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' } } }] },
      primitive: { topology: 'triangle-strip', cullMode: 'none' }
    });

    // Pipelines for Morton + sort
    const mortonModule = device.createShaderModule({ code: mortonWGSL });
    const mortonPipe = device.createComputePipeline({ layout: 'auto', compute: { module: mortonModule, entryPoint: 'main' } });
    const bitonicModule = device.createShaderModule({ code: bitonicWGSL });
    const bitonicPipe = device.createComputePipeline({ layout: 'auto', compute: { module: bitonicModule, entryPoint: 'main' } });
    const detectMortonModule = device.createShaderModule({ code: detectMortonWGSL });
    const detectMortonPipe = device.createComputePipeline({ layout: 'auto', compute: { module: detectMortonModule, entryPoint: 'main' } });

    // New: cluster reduce and BH integrate shaders
    const clusterReduceModule = device.createShaderModule({ code: clusterReduceWGSL });
    const clusterReducePipe = device.createComputePipeline({ layout: 'auto', compute: { module: clusterReduceModule, entryPoint: 'main' } });

    const integrateBHModule = device.createShaderModule({ code: integrateBHWGSL });
    const integrateBHPipe = device.createComputePipeline({ layout: 'auto', compute: { module: integrateBHModule, entryPoint: 'main' } });

    // Lines pipeline (GPU render of pair vectors)
    const linesWGSL = await (await fetch('scripts/lines.wgsl')).text();
    const linesModule = device.createShaderModule({ code: linesWGSL });
    const linesPipe = device.createRenderPipeline({
      layout: 'auto',
      vertex: { module: linesModule, entryPoint: 'vs' },
      fragment: { module: linesModule, entryPoint: 'fs', targets: [{ format, blend: { color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' }, alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' } } }] },
      primitive: { topology: 'line-list', stripIndexFormat: undefined, cullMode: 'none' }
    });

    // Bind groups for Morton
    const mortonBG_posA = device.createBindGroup({ layout: mortonPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: mortonKeys } },
      { binding: 2, resource: { buffer: mortonIdx } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: mortonParamsBuf } },
    ]});
    const mortonBG_posB = device.createBindGroup({ layout: mortonPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: mortonKeys } },
      { binding: 2, resource: { buffer: mortonIdx } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: mortonParamsBuf } },
    ]});

    const bitonicBG = device.createBindGroup({ layout: bitonicPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: mortonKeys } },
      { binding: 1, resource: { buffer: mortonIdx } },
      { binding: 2, resource: { buffer: sortParamsBuf } },
    ]});

    const detectMortonBG_posA = device.createBindGroup({ layout: detectMortonPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: radiusBuf } },
      { binding: 7, resource: { buffer: mortonIdx } },
      { binding: 8, resource: { buffer: windowBuf } },
    ]});
    const detectMortonBG_posB = device.createBindGroup({ layout: detectMortonPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: radiusBuf } },
      { binding: 7, resource: { buffer: mortonIdx } },
      { binding: 8, resource: { buffer: windowBuf } },
    ]});

    // Bind groups for cluster reduce (posA/posB)
    const clusterReduceBG_posA = device.createBindGroup({ layout: clusterReducePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: mortonIdx } },
      { binding: 3, resource: { buffer: clBuf } },
      { binding: 4, resource: { buffer: clMassBuf } },
      { binding: 5, resource: { buffer: clComBuf } },
      { binding: 6, resource: { buffer: simParamsBuf } },
    ]});
    const clusterReduceBG_posB = device.createBindGroup({ layout: clusterReducePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: mortonIdx } },
      { binding: 3, resource: { buffer: clBuf } },
      { binding: 4, resource: { buffer: clMassBuf } },
      { binding: 5, resource: { buffer: clComBuf } },
      { binding: 6, resource: { buffer: simParamsBuf } },
    ]});

    // Bind groups for integrateBH (A->B and B->A)
    // Integrate BH bind groups: try full set (including vis pair buffers),
    // but fall back to omit vis buffers if the shader/pipeline doesn't declare them.
    let integrateBHBG_AtoB;
    let integrateBHBG_BtoA;
    (function(){
      const layout = integrateBHPipe.getBindGroupLayout(0);
      const fullEntriesA = [
        { binding: 0, resource: { buffer: posA } },
        { binding: 1, resource: { buffer: velA } },
        { binding: 2, resource: { buffer: posB } },
        { binding: 3, resource: { buffer: velB } },
        { binding: 4, resource: { buffer: simParamsBuf } },
        { binding: 5, resource: { buffer: masses } },
        { binding: 6, resource: { buffer: dampBuf } },
        { binding: 7, resource: { buffer: repulseBuf } },
        { binding: 8, resource: { buffer: radBuf } },
        { binding: 9, resource: { buffer: spinBuf } },
        { binding: 10, resource: { buffer: bhBuf } },
        { binding: 11, resource: { buffer: mortonIdx } },
        { binding: 12, resource: { buffer: clBuf } },
        { binding: 13, resource: { buffer: clMassBuf } },
        { binding: 14, resource: { buffer: clComBuf } },
        { binding: 15, resource: { buffer: visPairCountBuf } },
        { binding: 16, resource: { buffer: visPairBuf } },
      ];
      const fullEntriesB = fullEntriesA.map(e => {
        // swap pos/vel buffers for B->A
        const copy = Object.assign({}, e);
        if (e.binding === 0) copy.resource.buffer = posB;
        if (e.binding === 1) copy.resource.buffer = velB;
        if (e.binding === 2) copy.resource.buffer = posA;
        if (e.binding === 3) copy.resource.buffer = velA;
        return copy;
      });
      try {
        integrateBHBG_AtoB = device.createBindGroup({ layout, entries: fullEntriesA });
        integrateBHBG_BtoA = device.createBindGroup({ layout, entries: fullEntriesB });
      } catch (e) {
        console.warn('integrateBH bind group failed, retrying without visPair buffers', e);
        // fallback: remove entries with binding >= 15
        const fallbackA = fullEntriesA.filter(en => en.binding < 15);
        const fallbackB = fullEntriesB.filter(en => en.binding < 15);
        integrateBHBG_AtoB = device.createBindGroup({ layout, entries: fallbackA });
        integrateBHBG_BtoA = device.createBindGroup({ layout, entries: fallbackB });
      }
    })();

    // Direct integrate (O(N^2)) bind groups removed: Barnes–Hut only.

    const detectBG_posA = device.createBindGroup({ layout: detectPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: radiusBuf } },
    ]});
    const detectBG_posB = device.createBindGroup({ layout: detectPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: radiusBuf } },
    ]});

    const splitBG_velA = device.createBindGroup({ layout: splitPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: velA } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: pairCount } },
      { binding: 3, resource: { buffer: pairBuf } },
      { binding: 4, resource: { buffer: restBuf } },
      { binding: 5, resource: { buffer: locks } },
      { binding: 6, resource: { buffer: claims } },
    ]});
    const splitBG_velB = device.createBindGroup({ layout: splitPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: velB } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: pairCount } },
      { binding: 3, resource: { buffer: pairBuf } },
      { binding: 4, resource: { buffer: restBuf } },
      { binding: 5, resource: { buffer: locks } },
      { binding: 6, resource: { buffer: claims } },
    ]});

    const renderBG_posA = device.createBindGroup({ layout: renderPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: matsBuf } },
    ]});
    const renderBG_posB = device.createBindGroup({ layout: renderPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: matsBuf } },
    ]});

    // Lines bind groups (posA/posB) — create defensively: some builds of the shader
    // may not declare the cluster COM binding (binding 3). Try full entries and
    // fall back without binding 3 if creation fails.
    let linesBG_posA;
    let linesBG_posB;
    (function(){
      const layout = linesPipe.getBindGroupLayout(0);
      const fullA = [
        { binding: 0, resource: { buffer: posA } },
        { binding: 1, resource: { buffer: visPairBuf } },
        { binding: 2, resource: { buffer: matsBuf } },
        { binding: 3, resource: { buffer: clComBuf } },
      ];
      const fullB = [
        { binding: 0, resource: { buffer: posB } },
        { binding: 1, resource: { buffer: visPairBuf } },
        { binding: 2, resource: { buffer: matsBuf } },
        { binding: 3, resource: { buffer: clComBuf } },
      ];
      try {
        linesBG_posA = device.createBindGroup({ layout, entries: fullA });
        linesBG_posB = device.createBindGroup({ layout, entries: fullB });
      } catch (e) {
        console.warn('lines bind group failed, retrying without cluster COM binding', e);
        const fallbackA = fullA.filter(en => en.binding < 3);
        const fallbackB = fullB.filter(en => en.binding < 3);
        linesBG_posA = device.createBindGroup({ layout, entries: fallbackA });
        linesBG_posB = device.createBindGroup({ layout, entries: fallbackB });
      }
    })();

    // Removed separate spin bind groups (spin is applied in integrate)

    // Frame loop
    let readFromA = true;
    let lastT = performance.now();
    let frameCount = 0;
    // Debug: always populate pairBuf with all unique pairs (i<j) up to MAX_PAIRS
    // Useful for visualization at small particle counts. Set to false to disable.
    const alwaysShowAllPairs = true;
  // overlay removed
  async function frame() {
      const now = performance.now();
      const dtMs = now - lastT; lastT = now;
      writeMats();
      simParams[0] = dt; simParams[1] = G; simParams[2] = 1.0; simParams[3] = particleCount; // eps = 1.0
      writeSimParams();
      writeRepulse(); // ensure R updates
      writeRad();     // ensure radiative damping updates
      //// Force spin = 1.0 for first 10 frames, then use UI-controlled value
      //if (frameCount < 10) { spinParams[0] = 1.0; device.queue.writeBuffer(spinBuf, 0, spinParams); } else { writeSpin(); }

      const enc = device.createCommandEncoder();

      // Collisions: optionally run detect+split every k frames
      const doCollisions = collisionsEnabled && ((frameCount % collideEvery) === 0);

      // If BH is enabled, compute morton + sort first (used for BH and possibly collisions)
      if (useBH) {
        // morton keys
        {
          const p0 = enc.beginComputePass();
          p0.setPipeline(mortonPipe);
          p0.setBindGroup(0, readFromA ? mortonBG_posA : mortonBG_posB);
          p0.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
          p0.end();
        }
        // bitonic sort
        let kStage = 2;
        while (kStage <= particleCount) {
          let jStage = kStage >> 1;
          while (jStage > 0) {
            writeSortJK(jStage, kStage);
            const pS = enc.beginComputePass();
            pS.setPipeline(bitonicPipe);
            pS.setBindGroup(0, bitonicBG);
            pS.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
            pS.end();
            jStage >>= 1;
          }
          kStage <<= 1;
        }
        // cluster reduction
        {
          const pR = enc.beginComputePass();
          pR.setPipeline(clusterReducePipe);
          pR.setBindGroup(0, readFromA ? clusterReduceBG_posA : clusterReduceBG_posB);
          pR.dispatchWorkgroups(clusterCountUsed);
          pR.end();
        }
      }

      if (doCollisions) {
        device.queue.writeBuffer(pairCount, 0, new Uint32Array([0]));
        device.queue.writeBuffer(locks, 0, new Uint32Array(particleCount));
        device.queue.writeBuffer(claims, 0, new Uint32Array(particleCount));

        if (useMorton && !useBH) {
          // Compute morton + sort for collisions if not already done for BH
          {
            const p0 = enc.beginComputePass();
            p0.setPipeline(mortonPipe);
            p0.setBindGroup(0, readFromA ? mortonBG_posA : mortonBG_posB);
            p0.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
            p0.end();
          }
          let kStage2 = 2;
          while (kStage2 <= particleCount) {
            let jStage2 = kStage2 >> 1;
            while (jStage2 > 0) {
              writeSortJK(jStage2, kStage2);
              const pS2 = enc.beginComputePass();
              pS2.setPipeline(bitonicPipe);
              pS2.setBindGroup(0, bitonicBG);
              pS2.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
              pS2.end();
              jStage2 >>= 1;
            }
            kStage2 <<= 1;
          }
        }

        if (useMorton) {
          const p1 = enc.beginComputePass();
          p1.setPipeline(detectMortonPipe);
          p1.setBindGroup(0, readFromA ? detectMortonBG_posA : detectMortonBG_posB);
          p1.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
          p1.end();
          // SMOKE TEST: populate the first few entries of pairBuf with known
          // pairs so the lines renderer has something concrete to draw. This
          // is safer than forcing pairCount alone because we also fill pairBuf.
          // Remove after debugging.
          try {
            const testPairs = new Uint32Array([
              0, 1, 0, 0,
              2, 3, 0, 0,
              4, 5, 0, 0,
              6, 7, 0, 0,
            ]);
            device.queue.writeBuffer(visPairBuf, 0, testPairs);
            // SMOKE TEST: wrote test pairs (silent)
          } catch (e) { console.warn('SMOKE TEST write failed', e); }
          // Immediate debug readback of pairCount after detectMorton
          // CPU readbacks removed; skip post-detectMorton debug readback.
        } else {
          const p0 = enc.beginComputePass();
          p0.setPipeline(detectPipe);
          p0.setBindGroup(0, readFromA ? detectBG_posA : detectBG_posB);
          p0.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
          p0.end();
          // Immediate debug readback of pairCount after detect
          // CPU readbacks removed; skip post-detect debug readback.
        }
      }

      // Integrate all particles using Barnes–Hut (always)
      {
        // reset visualization pair count for this frame so shaders can append
        device.queue.writeBuffer(visPairCountBuf, 0, new Uint32Array([0]));
        const p = enc.beginComputePass();
        writeBHParams(); // ensure uniforms updated
        p.setPipeline(integrateBHPipe);
        p.setBindGroup(0, readFromA ? integrateBHBG_AtoB : integrateBHBG_BtoA);
        p.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
        p.end();
        readFromA = !readFromA;
        // Debug: copy the first particle's position from the active buffer to CPU-visible buffer
        // CPU readbacks removed; skip post-integrate first-particle readback.
      }

      // Split using pairs from this frame (if any)
      if (doCollisions) {
        const p2 = enc.beginComputePass();
        p2.setPipeline(splitPipe);
        p2.setBindGroup(0, readFromA ? splitBG_velA : splitBG_velB);
        p2.dispatchWorkgroups(Math.ceil(MAX_PAIRS / WG_SIZE));
        p2.end();
      }

      // Render
      {
        // If debug mode enabled, populate pairBuf with all (i<j) pairs on the CPU
        if (alwaysShowAllPairs) {
          try {
            const maxPairsToWrite = Math.min(MAX_PAIRS, Math.floor(particleCount*(particleCount-1)/2));
            const cpuPairs = new Uint32Array(maxPairsToWrite * 4); // vec4<u32>
            let idx = 0;
            for (let i=0; i<particleCount && idx < maxPairsToWrite; i++) {
              for (let j=i+1; j<particleCount && idx < maxPairsToWrite; j++) {
                const off = idx * 4;
                cpuPairs[off+0] = i;
                cpuPairs[off+1] = j;
                cpuPairs[off+2] = 0;
                cpuPairs[off+3] = 0;
                idx++;
              }
            }
            device.queue.writeBuffer(visPairBuf, 0, cpuPairs);
          } catch(e) { console.warn('alwaysShowAllPairs write failed', e); }
        }
        // Small readback of visPairCount to set instance count for lines draw
        let numVisPairs = MAX_PAIRS;
        // No CPU readback for visPairCount; assume MAX_PAIRS as instance count fallback
        numVisPairs = MAX_PAIRS;

        const viewTex = context.getCurrentTexture().createView();
        const rp = enc.beginRenderPass({ colorAttachments: [{ view: viewTex, clearValue: {r:0,g:0,b:0,a:1}, loadOp: 'clear', storeOp: 'store' }] });
        rp.setPipeline(renderPipe);
        rp.setBindGroup(0, readFromA ? renderBG_posA : renderBG_posB);
        rp.draw(4, particleCount);
        // Draw GPU pair vectors directly into the main canvas
        rp.setPipeline(linesPipe);
        rp.setBindGroup(0, readFromA ? linesBG_posA : linesBG_posB);
        // Each instance emits 2 vertices (line-list). Instance count = vis pair count
        rp.draw(2, Math.max(1, numVisPairs));
        rp.end();
      }

      device.queue.submit([enc.finish()]);

      // Debug: every 30 frames, read back pairCount and log to console
      if ((frameCount % 30) === 0) {
        // Periodic CPU readbacks removed.
      }

      // Additional debug: every 60 frames read back first 4 particle positions and masses
      if ((frameCount % 60) === 0) {
        // Additional periodic CPU debug readbacks removed.
      }

      frameCount++;
      statsDiv.textContent = `fps: ${(1000/Math.max(1, dtMs)).toFixed(0)}  particles: ${particleCount}`;
  // overlay removed
  requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
