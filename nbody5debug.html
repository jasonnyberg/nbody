<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebGPU N-Body (merge + split) – nbody5</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #ui { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: #fff; font-family: system-ui, sans-serif; padding: 10px; font-size: 12px; }
    #ui label { display:block; margin: 6px 0 2px; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <canvas id="overlay" style="position:fixed;left:0;top:0;pointer-events:none"></canvas>
  <div id="ui">
    <div><b>Controls</b></div>
    <label>G: <span id="gVal">0.30</span></label>
    <input id="g" type="range" min="0.01" max="5.0" step="0.01" value="0.30" />

    <label>dt: <span id="dtVal">0.20</span></label>
    <input id="dt" type="range" min="0.01" max="1.00" step="0.01" value="0.20" />

    <label>Restitution (alpha): <span id="restVal">1.00</span></label>
    <input id="rest" type="range" min="0.0" max="1.0" step="0.01" value="1.00" />

    <!-- New: Radius factor slider -->
    <label>Radius factor: <span id="rfVal">2</span></label>
    <input id="rf" type="range" min="1" max="100" step="1" value="2" />

    <!-- New: Repulsion (R) slider -->
    <label>Repulsion R: <span id="repVal">10</span></label>
    <input id="rep" type="range" min="0" max="100" step="1" value="10" />

    <!-- New: Spin and Damping sliders -->
    <label>Spin: <span id="spinVal">0.00</span></label>
    <input id="spin" type="range" min="-2.0" max="2.0" step="0.01" value="0.00" />

    <label>Damping: <span id="dampVal">1.00</span></label>
    <input id="damp" type="range" min="0.0" max="1.0" step="0.001" value="1.00" />

    <!-- New: Radiative damping -->
    <label>Radiative: <span id="radVal">0.005</span></label>
    <input id="rad" type="range" min="0.0" max="0.1" step="0.001" value="0.005" />

    <!-- New: Collision controls -->
    <label><input id="collideOn" type="checkbox" checked /> Collisions (detect/split)</label>
    <label>Collide every k frames: <span id="collideKVal">1</span></label>
    <input id="collideK" type="range" min="1" max="8" step="1" value="1" />

    <!-- New: Octree (Morton) indexing for collisions -->
    <label><input id="octOn" type="checkbox" checked /> Use octree index (Morton)</label>
    <label>Neighbor window: <span id="winVal">64</span></label>
    <input id="win" type="range" min="8" max="256" step="8" value="64" />

    <!-- New: Barnes–Hut controls -->
    <label><input id="bhOn" type="checkbox" checked /> Barnes–Hut gravity</label>
    <label>Opening angle θ: <span id="thetaVal">0.60</span></label>
    <input id="theta" type="range" min="0.2" max="1.0" step="0.05" value="0.60" />
    <label>Cluster size: <span id="clSizeVal">64</span></label>
    <input id="clSize" type="range" min="16" max="256" step="16" value="64" />

    <!-- Debug overlays -->
    <label><input id="showPairs" type="checkbox" checked /> Show pairwise force vectors</label>
    <label><input id="showNet" type="checkbox" checked /> Show net force vectors</label>
    <label><input id="showBoxes" type="checkbox" checked /> Show octree boxes (CPU 1–2 levels)</label>
    <label>Vector scale: <span id="vecScaleVal">1.0</span></label>
    <input id="vecScale" type="range" min="0.1" max="10" step="0.1" value="1.0" />

    <div id="stats" style="margin-top:6px; opacity: 0.85;"></div>
  </div>

  <script>
  "use strict";
  (async () => {
    const canvas = document.getElementById('c');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');
    const statsDiv = document.getElementById('stats');
    if (!('gpu' in navigator)) { alert('WebGPU not supported'); return; }

    const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' }) || await navigator.gpu.requestAdapter();
    if (!adapter) { alert('No GPU adapter'); return; }
    const device = await adapter.requestDevice();
    const context = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();
    const WG_SIZE = 128; // tuned workgroup size
    const MORTON_BITS = 10; // 10 bits/axis => 1024^3 grid

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      overlay.width = canvas.width;
      overlay.height = canvas.height;
      context.configure({ device, format, alphaMode: 'opaque' });
    }
    resize();
    addEventListener('resize', resize);

    // Simple parameters/UI
    let G = 0.30;
    let dt = 0.20;
    let restitution = 1.00; // used as alpha in energy restitution
    let radiusFactor = 2.0; // new: scales collision radii
    let R = 10.0;           // new: short-range repulsion strength (like nbody3)
    let spin = 0.00;        // new: tangential velocity injection rate (rad/s)
    let damping = 1.00;     // CHANGED: damping factor (0..1), applied directly to velocity (1.0 = no damping)
    let radiativeDamping = 0.005; // new: radiative damping coefficient
    let collisionsEnabled = true; // new: toggle collisions
    let collideEvery = 1;         // new: run collisions every k frames
    let useMorton = true;         // new: toggle morton/octree indexing
    let neighborWindow = 64;      // new: neighbors to scan on each side in Morton order
    let useBH = true;             // new: Barnes–Hut toggle
    let theta = 0.60;             // new: BH opening angle
    let clusterSize = 64;         // new: leaf capacity approximation

    const gEl = document.getElementById('g');
    const gVal = document.getElementById('gVal');
    gEl.addEventListener('input', () => { G = parseFloat(gEl.value); gVal.textContent = G.toFixed(2); writeSimParams(); });
    const dtEl = document.getElementById('dt');
    const dtVal = document.getElementById('dtVal');
    dtEl.addEventListener('input', () => { dt = parseFloat(dtEl.value); dtVal.textContent = dt.toFixed(2); writeSimParams(); });
    const restEl = document.getElementById('rest');
    const restVal = document.getElementById('restVal');
    restEl.addEventListener('input', () => { restitution = parseFloat(restEl.value); restVal.textContent = restitution.toFixed(2); writeRest(); });

    // New: radius factor UI wiring
    const rfEl = document.getElementById('rf');
    const rfVal = document.getElementById('rfVal');
    rfEl.addEventListener('input', () => { radiusFactor = parseFloat(rfEl.value); rfVal.textContent = String(rfEl.value); writeRadius(); });

    // New: repulsion UI wiring
    const repEl = document.getElementById('rep');
    const repVal = document.getElementById('repVal');
    repEl.addEventListener('input', () => { R = parseFloat(repEl.value); repVal.textContent = String(repEl.value); writeRepulse(); });

    // New: spin + damping UI wiring
    const spinEl = document.getElementById('spin');
    const spinVal = document.getElementById('spinVal');
    spinEl.addEventListener('input', () => { spin = parseFloat(spinEl.value); spinVal.textContent = spin.toFixed(2); writeSpin(); });
    const dampEl = document.getElementById('damp');
    const dampVal = document.getElementById('dampVal');
    dampEl.addEventListener('input', () => { damping = parseFloat(dampEl.value); dampVal.textContent = damping.toFixed(3); writeDamp(); });

    // New: radiative damping UI wiring
    const radEl = document.getElementById('rad');
    const radVal = document.getElementById('radVal');
    radEl.addEventListener('input', () => { radiativeDamping = parseFloat(radEl.value); radVal.textContent = radiativeDamping.toFixed(3); writeRad(); });

    // New: collision UI wiring
    const collideOnEl = document.getElementById('collideOn');
    const collideKEl = document.getElementById('collideK');
    const collideKVal = document.getElementById('collideKVal');
    collideOnEl.addEventListener('change', () => { collisionsEnabled = collideOnEl.checked; });
    collideKEl.addEventListener('input', () => { collideEvery = parseInt(collideKEl.value); collideKVal.textContent = String(collideEvery); });

    // New: Morton/octree UI wiring
    const octOnEl = document.getElementById('octOn');
    const winEl = document.getElementById('win');
    const winVal = document.getElementById('winVal');
    octOnEl.addEventListener('change', () => { useMorton = octOnEl.checked; });
    winEl.addEventListener('input', () => { neighborWindow = parseInt(winEl.value); winVal.textContent = String(neighborWindow); writeWindow(); });

    // New: BH UI wiring
    const bhOnEl = document.getElementById('bhOn');
    const thetaEl = document.getElementById('theta');
    const thetaVal = document.getElementById('thetaVal');
    const clSizeEl = document.getElementById('clSize');
    const clSizeVal = document.getElementById('clSizeVal');
    bhOnEl.addEventListener('change', () => { useBH = bhOnEl.checked; writeBHParams(); });
    thetaEl.addEventListener('input', () => { theta = parseFloat(thetaEl.value); thetaVal.textContent = theta.toFixed(2); writeBHParams(); });
    clSizeEl.addEventListener('input', () => { clusterSize = parseInt(clSizeEl.value); clSizeVal.textContent = String(clusterSize); writeBHParams(); });

    // Basic math helpers (column-major matrices like WebGPU expects)
    function perspective(fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      return new Float32Array([
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * far * near) * nf, 0
      ]);
    }
    function normalize(a) { const l = Math.hypot(a[0],a[1],a[2]) || 1; return [a[0]/l, a[1]/l, a[2]/l]; }
    function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
    function dot(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
    function lookAt(eye, center, up) {
      const f = normalize([center[0]-eye[0], center[1]-eye[1], center[2]-eye[2]]);
      const s = normalize(cross(f, up));
      const u = cross(s, f);
      return new Float32Array([
        s[0], u[0], -f[0], 0,
        s[1], u[1], -f[1], 0,
        s[2], u[2], -f[2], 0,
        - (s[0]*eye[0] + s[1]*eye[1] + s[2]*eye[2]),
        - (u[0]*eye[0] + u[1]*eye[1] + u[2]*eye[2]),
        (f[0]*eye[0] + f[1]*eye[1] + f[2]*eye[2]),
        1
      ]);
    }

    // Orbit camera (simple)
    let az = 0.3, el = 0.6, dist = 400.0;
    function updateView() {
      const ce = Math.cos(el), se = Math.sin(el), sa = Math.sin(az), ca = Math.cos(az);
      const eye = [ dist * ce * sa, dist * se, dist * ce * ca ];
      view = lookAt(eye, [0,0,0], [0,1,0]);
    }
    (function orbitControls(){
      let drag=false, lx=0, ly=0;
      canvas.addEventListener('mousedown', (e)=>{ if(e.button===0){ drag=true; lx=e.clientX; ly=e.clientY; }});
      addEventListener('mouseup', ()=> drag=false);
      addEventListener('mousemove', (e)=>{
        if(!drag) return; const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY;
        az += dx * 0.005; el += dy * 0.005;
        const minEl = -Math.PI/2 + 0.01;
        const maxEl =  Math.PI/2 - 0.01;
        el = Math.max(minEl, Math.min(maxEl, el));
      });
      canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); dist *= Math.exp(e.deltaY * 0.001); dist = Math.max(10, Math.min(1e6, dist)); }, {passive:false});
    })();

    // Simulation setup (simple random sphere)
    const particleCount = 64; // small for debugging overlays
    const stride = 4; // vec4
    const stateBytes = particleCount * stride * 4;

    function makeBuf(size, usage) { return device.createBuffer({ size, usage }); }
    function bufFrom(arr, usage) {
      const b = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
      new Float32Array(b.getMappedRange()).set(arr);
      b.unmap(); return b;
    }

    const posInit = new Float32Array(particleCount * stride);
    const velInit = new Float32Array(particleCount * stride);
    const massInit = new Float32Array(particleCount);
    const rad = 800.0;
    for (let i=0;i<particleCount;i++){
      let x,y,z; do { x=(Math.random()*2-1)*rad; y=(Math.random()*2-1)*rad; z=(Math.random()*2-1)*rad; } while (x*x+y*y+z*z>rad*rad);
      const o=i*stride; posInit[o]=x; posInit[o+1]=y; posInit[o+2]=z; posInit[o+3]=0;
      velInit[o]=0; velInit[o+1]=0; velInit[o+2]=0; velInit[o+3]=0;
      massInit[i]=1.0; // start uniform
    }
    let posA = bufFrom(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
    let posB = makeBuf(stateBytes, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
    let velA = bufFrom(velInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
    let velB = makeBuf(stateBytes, GPUBufferUsage.STORAGE);
    const masses = bufFrom(massInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);

    // Collision pair buffers (very simple)
    const MAX_PAIRS = Math.min(particleCount * 8, 262144);
    const pairBuf = device.createBuffer({ size: MAX_PAIRS * 16, usage: GPUBufferUsage.STORAGE }); // vec4<u32>
    const pairCount = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const locks = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const claims = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    // Morton keys + index buffers
    const mortonKeys = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const mortonIdx  = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });

    // Uniforms
    // SimParams is 4 floats (16 bytes): dt, G, eps, num
    const simParams = new Float32Array([dt, G, 1.0, particleCount]); // eps defaults to 1.0
    const simParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSimParams(){ device.queue.writeBuffer(simParamsBuf, 0, simParams.buffer, simParams.byteOffset, simParams.byteLength); }
    writeSimParams();

    const restParams = new Float32Array([restitution, 0,0,0]);
    const restBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRest(){ restParams[0]=restitution; device.queue.writeBuffer(restBuf, 0, restParams); }
    writeRest();

    // New: collision radius factor uniform
    const radiusParams = new Float32Array([radiusFactor, 0,0,0]);
    const radiusBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRadius(){ radiusParams[0]=radiusFactor; device.queue.writeBuffer(radiusBuf, 0, radiusParams); }
    writeRadius();

    // New: damping uniform
    const dampParams = new Float32Array([damping, 0,0,0]);
    const dampBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeDamp(){ dampParams[0]=damping; device.queue.writeBuffer(dampBuf, 0, dampParams); }
    writeDamp();

    // New: spin uniform
    const spinParams = new Float32Array([spin, 0,0,0]);
    const spinBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSpin(){ spinParams[0]=spin; device.queue.writeBuffer(spinBuf, 0, spinParams); }
    writeSpin();

    // New: repulsion (R) uniform
    const repulseParams = new Float32Array([R, 0,0,0]);
    const repulseBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRepulse(){ repulseParams[0]=R; device.queue.writeBuffer(repulseBuf, 0, repulseParams); }
    writeRepulse();

    // New: radiative damping uniform
    const radParams = new Float32Array([radiativeDamping, 0,0,0]);
    const radBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRad(){ radParams[0]=radiativeDamping; device.queue.writeBuffer(radBuf, 0, radParams); }
    writeRad();

    // New: Morton/octree uniforms (extent maps [-extent,extent] to [0,1])
    let mortonExtent = 4096.0;
    const mortonParams = new Float32Array([mortonExtent, 0,0,0]);
    const mortonParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeMorton(){ mortonParams[0]=mortonExtent; device.queue.writeBuffer(mortonParamsBuf, 0, mortonParams); }
    writeMorton();

    // Bitonic sort stage params (j,k,n)
    const sortParams = new Uint32Array([0, 0, particleCount, 0]);
    const sortParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSortJK(j, k){ sortParams[0] = j; sortParams[1] = k; device.queue.writeBuffer(sortParamsBuf, 0, sortParams); }

    // Neighbor window uniform for Morton collision detection
    const windowParams = new Uint32Array([neighborWindow, 0, 0, 0]);
    const windowBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeWindow(){ windowParams[0] = neighborWindow; device.queue.writeBuffer(windowBuf, 0, windowParams); }
    writeWindow();

    // New: BH uniforms and cluster buffers
    const bhParams = new Float32Array([theta, 0,0,0]);
    const bhBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    // Cluster params: size, count
    let clusterCountUsed = Math.ceil(particleCount / clusterSize);
    const clParams = new Uint32Array([clusterSize, clusterCountUsed, 0, 0]);
    const clBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeBHParams(){
      bhParams[0] = theta; device.queue.writeBuffer(bhBuf, 0, bhParams);
      clusterCountUsed = Math.ceil(particleCount / Math.max(1, clusterSize));
      clParams[0] = clusterSize; clParams[1] = clusterCountUsed;
      device.queue.writeBuffer(clBuf, 0, clParams);
    }
    writeBHParams();
    // Allocate max cluster buffers for min leaf size 16
    const MIN_CLUSTER = 16;
    const maxClusters = Math.ceil(particleCount / MIN_CLUSTER);
    const clMassBuf = device.createBuffer({ size: maxClusters * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const clComBuf  = device.createBuffer({ size: maxClusters * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });

    // WGSL Shaders
    const integrateWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Damp { factor: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
struct Repulse { k: f32, _r0: f32, _r1: f32, _r2: f32 }
struct Rad { c: f32, _r0: f32, _r1: f32, _r2: f32 }
struct Spin { w: f32, _s0: f32, _s1: f32, _s2: f32 } // new spin uniform
@group(0) @binding(0) var<storage, read> posIn: Vec4Buf;
@group(0) @binding(1) var<storage, read> velIn: Vec4Buf;
@group(0) @binding(2) var<storage, read_write> posOut: Vec4Buf;
@group(0) @binding(3) var<storage, read_write> velOut: Vec4Buf;
@group(0) @binding(4) var<uniform> P: SimParams;
@group(0) @binding(5) var<storage, read> M: FloatBuf;
@group(0) @binding(6) var<uniform> D: Damp;
@group(0) @binding(7) var<uniform> Rp: Repulse;
@group(0) @binding(8) var<uniform> Rd: Rad;
@group(0) @binding(9) var<uniform> Sp: Spin; // spin now applied inside integrate

const WG: u32 = 128u;
var<workgroup> tPos: array<vec4<f32>, WG>;
var<workgroup> tVel: array<vec4<f32>, WG>;
var<workgroup> tMass: array<f32, WG>;

@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = gid.x;
  let n = u32(P.numParticlesF);
  let isActive = i < n;
  let eps2 = P.eps * P.eps;
  var p = vec3<f32>(0.0);
  var v = vec3<f32>(0.0);
  var mi: f32 = 0.0;
  if (isActive) {
    p = posIn.data[i].xyz;
    v = velIn.data[i].xyz;
    mi = M.data[i];
  }
  var a = vec3<f32>(0.0);
  var radiate_mag: f32 = 0.0;
  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }
    let j = base + lid.x;
    if (j < n) {
      tPos[lid.x] = posIn.data[j];
      tVel[lid.x] = velIn.data[j];
      tMass[lid.x] = M.data[j];
    } else {
      tPos[lid.x] = vec4<f32>(0.0);
      tVel[lid.x] = vec4<f32>(0.0);
      tMass[lid.x] = 0.0;
    }
    workgroupBarrier();
    let remain = n - base;
    var count: u32 = WG;
    if (remain < WG) { count = remain; }
    if (isActive && mi > 0.0) {
      var k: u32 = 0u;
      loop {
        if (k >= count) { break; }
        let m = tMass[k];
        if (m > 0.0) {
          let d = tPos[k].xyz - p;
          let r2 = dot(d,d) + eps2;
          let invR = inverseSqrt(r2);
          let invR2 = invR * invR;
          let invR4 = invR2 * invR2;
          let dir = d * invR;
          let aG = (P.G * m) * invR2;
          let aR = (Rp.k * m) * invR4;
          var aRad: f32 = 0.0;
          if (aR >= aG) {
            let vj = tVel[k].xyz;
            let closingSpeed = dot(d, v - vj);
            aRad = Rd.c * closingSpeed * invR;
            radiate_mag = radiate_mag + abs(aRad);
          }
          let aMag = aG - aR - aRad;
          a = a + dir * aMag;
        }
        k = k + 1u;
      }
    }
    workgroupBarrier();
    base = base + WG;
  }
  if (isActive) {
    v = v + a * P.dt;
    // Inject spin like prior separate pass
    if (abs(Sp.w) > 0.0) {
      let posXZ = p.xz;
      let len2 = dot(posXZ, posXZ);
      if (len2 > 0.0) {
        let invLen = inverseSqrt(len2);
        let tang2 = vec2<f32>(-posXZ.y, posXZ.x) * invLen;
        let tang = vec3<f32>(tang2.x, 0.0, tang2.y);
        v = v + (Sp.w * P.dt) * tang;
      }
    }
    v = v * D.factor;
    p = p + v * P.dt;
    posOut.data[i] = vec4<f32>(p, radiate_mag);
    velOut.data[i] = vec4<f32>(v, 0.0);
  }
}
`;

    const detectPairsWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct PairCount { value: atomic<u32>, }
struct Pairs { data: array<vec4<u32>>, }
struct Coll { rf: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read> Pvel: Vec4Buf;
@group(0) @binding(2) var<storage, read> M: FloatBuf;
@group(0) @binding(3) var<uniform> S: SimParams;
@group(0) @binding(4) var<storage, read_write> pc: PairCount;
@group(0) @binding(5) var<storage, read_write> pb: Pairs;
@group(0) @binding(6) var<uniform> C: Coll; // collision radius factor

const WG: u32 = 128u;
var<workgroup> tPos: array<vec4<f32>, WG>;
var<workgroup> tVel: array<vec4<f32>, WG>;
var<workgroup> tMass: array<f32, WG>;

fn encodeNormal(n: vec3<f32>) -> vec2<u32> {
  let nx = clamp(n.x * 32767.0, -32767.0, 32767.0);
  let ny = clamp(n.y * 32767.0, -32767.0, 32767.0);
  let p0 = (u32(i32(nx) & 0xFFFF) | (u32(i32(ny) & 0xFFFF) << 16));
  let p1 = select(0u, 1u, n.z < 0.0);
  return vec2<u32>(p0, p1);
}

@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = gid.x;
  let n = u32(S.numParticlesF);
  let isActive = i < n;
  var mi: f32 = 0.0;
  if (isActive) { mi = M.data[i]; }
  let alive = isActive && (mi > 0.0);
  var pi = vec3<f32>(0.0);
  var vi = vec3<f32>(0.0);
  if (alive) { pi = Ppos.data[i].xyz; vi = Pvel.data[i].xyz; }

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }
    let jg = base + lid.x;
    if (jg < n) {
      tPos[lid.x] = Ppos.data[jg];
      tVel[lid.x] = Pvel.data[jg];
      tMass[lid.x] = M.data[jg];
    } else {
      tPos[lid.x] = vec4<f32>(0.0);
      tVel[lid.x] = vec4<f32>(0.0);
      tMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remain = n - base;
    var count: u32 = WG;
    if (remain < WG) { count = remain; }
    if (alive) {
      var k: u32 = 0u;
      loop {
        if (k >= count) { break; }
        let j = base + k;
        if (j > i) {
          let mj = tMass[k];
          if (mj > 0.0) {
            let dp = tPos[k].xyz - pi;
            let d2 = dot(dp, dp);
            let rf = max(C.rf, 0.0);
            let ri = rf * max(1.0, pow(mi, 0.3333));
            let rj = rf * max(1.0, pow(mj, 0.3333));
            let R = ri + rj;
            if (d2 < R*R) {
              let relv = tVel[k].xyz - vi;
              if (dot(dp, relv) < 0.0) {
                let len2 = max(d2, 1e-12);
                let invL = inverseSqrt(len2);
                let nhat = dp * invL;
                let packed = encodeNormal(nhat);
                let idx = atomicAdd(&pc.value, 1u);
                if (idx < ${MAX_PAIRS}u) {
                  pb.data[idx] = vec4<u32>(i, j, packed.x, packed.y);
                }
              }
            }
          }
        }
        k = k + 1u;
      }
    }

    workgroupBarrier();
    base = base + WG;
  }
}
`;

    // Split shader (unchanged)
    const splitWGSL = /* wgsl */`
struct PairCount { value: atomic<u32>, }
struct Pairs { data: array<vec4<u32>>, }
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Rest { e: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
struct Locks { data: array<atomic<u32>>, }
struct Claims { data: array<atomic<u32>>, }

@group(0) @binding(0) var<storage, read_write> V: Vec4Buf; // velocities (post-integration)
@group(0) @binding(1) var<storage, read> M: FloatBuf;      // masses
@group(0) @binding(2) var<storage, read_write> pc: PairCount; // pair count (atomic)
@group(0) @binding(3) var<storage, read> pb: Pairs;        // pairs list
@group(0) @binding(4) var<uniform> R: Rest;               // alpha (energy restitution)
@group(0) @binding(5) var<storage, read_write> L: Locks;  // locks
@group(0) @binding(6) var<storage, read_write> C: Claims; // claims per particle (to avoid multiple splits)

fn decodeNormal(packed: vec2<u32>) -> vec3<f32> {
  let xb = packed.x & 0xFFFFu;
  let yb = (packed.x >> 16u) & 0xFFFFu;
  let xs = select(i32(xb), i32(xb) - 65536, (xb & 0x8000u) != 0u);
  let ys = select(i32(yb), i32(yb) - 65536, (yb & 0x8000u) != 0u);
  let x = f32(xs) / 32767.0;
  let y = f32(ys) / 32767.0;
  var z = sqrt(max(0.0, 1.0 - x*x - y*y));
  if (packed.y != 0u) { z = -z; }
  return normalize(vec3<f32>(x, y, z));
}

@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let k = gid.x;
  let total = atomicLoad(&pc.value);
  if (k >= total) { return; }

  let rec = pb.data[k];
  let i = rec.x; let j = rec.y;
  if (i == j) { return; }

  // Acquire locks in index order to avoid deadlocks
  let a = min(i, j);
  let b = max(i, j);
  let la = atomicCompareExchangeWeak(&L.data[a], 0u, 1u);
  if (!la.exchanged) { return; }
  let lb = atomicCompareExchangeWeak(&L.data[b], 0u, 1u);
  if (!lb.exchanged) { atomicStore(&L.data[a], 0u); return; }

  // Ensure each particle participates in at most one split per frame
  let ca = atomicCompareExchangeWeak(&C.data[i], 0u, 1u);
  if (!ca.exchanged) { atomicStore(&L.data[b], 0u); atomicStore(&L.data[a], 0u); return; }
  let cb = atomicCompareExchangeWeak(&C.data[j], 0u, 1u);
  if (!cb.exchanged) {
    atomicStore(&C.data[i], 0u);
    atomicStore(&L.data[b], 0u);
    atomicStore(&L.data[a], 0u);
    return;
  }

  let mi = M.data[i];
  let mj = M.data[j];
  if (mi <= 0.0 || mj <= 0.0) {
    // release
    atomicStore(&L.data[b], 0u);
    atomicStore(&L.data[a], 0u);
    return;
  }

  var vi = V.data[i].xyz; // post-integration velocities
  var vj = V.data[j].xyz;
  let n = decodeNormal(vec2<u32>(rec.z, rec.w));

  let m12 = mi + mj;
  if (m12 <= 0.0) {
    atomicStore(&L.data[b], 0u);
    atomicStore(&L.data[a], 0u);
    return;
  }
  let v12p = (mi * vi + mj * vj) / m12; // COM velocity after integration

  // Angular-momentum-preserving split: keep tangential component, reverse normal component (with restitution)
  let alpha = clamp(R.e, 0.0, 1.0);           // coefficient of restitution along normal
  let vrel = vj - vi;                         // relative velocity after integration
  let vn_mag = dot(vrel, n);                  // normal component magnitude
  let vn = vn_mag * n;                        // normal component vector
  let vt = vrel - vn;                         // tangential component
  // Only flip normal if approaching (vn_mag < 0). Otherwise keep it (already separating)
  let vn_mag_new = select(vn_mag, -alpha * vn_mag, vn_mag < 0.0);
  let vrel_new = vt + vn_mag_new * n;

  // Reconstruct individual velocities from COM and relative velocity
  vi = v12p - (mj / m12) * vrel_new;
  vj = v12p + (mi / m12) * vrel_new;
  V.data[i] = vec4<f32>(vi, 0.0);
  V.data[j] = vec4<f32>(vj, 0.0);

  // release locks
  atomicStore(&L.data[b], 0u);
  atomicStore(&L.data[a], 0u);
}
`;

    // Render shader (unchanged)
    const renderWGSL = /* wgsl */`
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Mats { m: array<vec4<f32>, 10>, }
@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read> M: FloatBuf;
@group(0) @binding(2) var<uniform> U: Mats;

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) uv: vec2<f32>,
  @location(1) radiate: f32,
  @location(2) massNorm: f32,
};

fn loadMat(idx: u32) -> mat4x4<f32> {
  let b = idx * 4u;
  return mat4x4<f32>(U.m[b+0u], U.m[b+1u], U.m[b+2u], U.m[b+3u]);
}

@vertex
fn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VSOut {
  // Per-instance particle index
  let pos4 = Ppos.data[iid];
  let world = pos4.xyz;
  let mass = M.data[iid];

  // Cull dead particles (mass <= 0)
  if (mass <= 0.0) {
    var out: VSOut;
    out.pos = vec4<f32>(2.0, 2.0, 1.0, 1.0);
    out.uv = vec2<f32>(2.0);
    out.radiate = 0.0;
    out.massNorm = 0.0;
    return out;
  }

  // Corner in NDC pixel space: (-1,-1), (-1,1), (1,-1), (1,1)
  var corner: vec2<f32>;
  switch (vid & 3u) {
    case 0u: { corner = vec2<f32>(-1.0, -1.0); }
    case 1u: { corner = vec2<f32>(-1.0,  1.0); }
    case 2u: { corner = vec2<f32>( 1.0, -1.0); }
    default: { corner = vec2<f32>( 1.0,  1.0); }
  }

  let proj = loadMat(0u);
  let view = loadMat(1u);
  let viewPos = view * vec4<f32>(world, 1.0);
  let clip = proj * viewPos;

  // Viewport and size parameters packed at U.m[8]: (width, height, sizeScale, invLogMax)
  let vp = U.m[8u];
  let width = vp.x; let height = vp.y; let sizeScale = vp.z; let invLogMax = vp.w;
  // Depth-scaled size similar to nbody3
  let baseSize = max(1.0, pow(max(mass, 0.0), 0.3333));
  let sizePx = max(2.0, sizeScale * baseSize / max(1.0, -viewPos.z));

  // Convert pixel offset to clip-space offset (pre-divide), account for clip.w
  let offsetClip = vec2<f32>(
    2.0 * corner.x * sizePx / max(1.0, width),
   -2.0 * corner.y * sizePx / max(1.0, height)
  ) * clip.w;

  // Mass normalization for color like nbody3
  let mNorm = clamp(log(1.0 + max(mass, 0.0)) * invLogMax, 0.0, 1.0);

  var out: VSOut;
  out.pos = vec4<f32>(clip.xy + offsetClip, clip.z, clip.w);
  out.uv = corner; // pass to fragment for circular mask
  out.radiate = pos4.w;
  out.massNorm = mNorm;
  return out;
}

@fragment
fn fs(in: VSOut) -> @location(0) vec4<f32> {
  let r = length(in.uv);
  if (r > 1.0) { discard; }
  // Soft edge alpha
  let alpha = clamp((1.0 - r) / 0.3, 0.0, 1.0);
  // Radiative coloring like nbody3: red from radiate, green/blue from mass
  let redRadiate = clamp(5.0 * in.radiate, 0.0, 1.0);
  let g = in.massNorm;
  let b = 1.0 - in.massNorm;
  return vec4<f32>(redRadiate, g, b, alpha);
}
`;

    // Morton code generation shader (compute morton key + identity index), bitonic sort shaders (swap by key), and Morton-neighborhood collision detection shader.
    const mortonWGSL = /* wgsl */`
struct Vec4Buf { data: array<vec4<f32>>, }
struct Keys { data: array<u32>, }
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Morton { extent: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read_write> keys: Keys;
@group(0) @binding(2) var<storage, read_write> idx: Keys;
@group(0) @binding(3) var<uniform> P: SimParams;
@group(0) @binding(4) var<uniform> M: Morton;

fn part1by2(n: u32) -> u32 {
  var x = n & 0x000003ffu;        // 10 bits
  x = (x | (x << 16u)) & 0x030000FFu;
  x = (x | (x << 8u))  & 0x0300F00Fu;
  x = (x | (x << 4u))  & 0x030C30C3u;
  x = (x | (x << 2u))  & 0x09249249u;
  return x;
}

fn morton3D(x: u32, y: u32, z: u32) -> u32 {
  return (part1by2(z) << 2u) | (part1by2(y) << 1u) | part1by2(x);
}

@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let i = gid.x;
  let n = u32(P.numParticlesF);
  if (i >= n) { return; }
  let p = Ppos.data[i].xyz;
  let e = max(1e-6, M.extent);
  let qx = clamp((p.x / e) * 0.5 + 0.5, 0.0, 1.0);
  let qy = clamp((p.y / e) * 0.5 + 0.5, 0.0, 1.0);
  let qz = clamp((p.z / e) * 0.5 + 0.5, 0.0, 1.0);
  let X = u32(qx * 1023.0);
  let Y = u32(qy * 1023.0);
  let Z = u32(qz * 1023.0);
  keys.data[i] = morton3D(X,Y,Z);
  idx.data[i] = i;
}
`;

    const bitonicWGSL = /* wgsl */`
struct Keys { data: array<u32>, }
struct Params { j: u32, k: u32, n: u32, _pad: u32 }
@group(0) @binding(0) var<storage, read_write> keys: Keys;
@group(0) @binding(1) var<storage, read_write> idx: Keys;
@group(0) @binding(2) var<uniform> SP: Params;

@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let i = gid.x;
  if (i >= SP.n) { return; }
  let j = SP.j; let k = SP.k;
  let ixj = i ^ j;
  if (ixj > i && ixj < SP.n) {
    let asc = (i & k) == 0u;
    let key_i = keys.data[i];
    let key_ixj = keys.data[ixj];
    let swap = select((key_i < key_ixj), (key_i > key_ixj), asc);
    if (swap) {
      let tmpK = key_i;
      keys.data[i] = key_ixj;
      keys.data[ixj] = tmpK;
      let tmpI = idx.data[i];
      idx.data[i] = idx.data[ixj];
      idx.data[ixj] = tmpI;
    }
  }
}
`;

    const detectMortonWGSL = /* wgsl */`
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct PairCount { value: atomic<u32>, }
struct Pairs { data: array<vec4<u32>>, }
struct Keys { data: array<u32>, }
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Coll { rf: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
struct Window { w: u32, _p1: u32, _p2: u32, _p3: u32 }

@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read> Pvel: Vec4Buf;
@group(0) @binding(2) var<storage, read> M: FloatBuf;
@group(0) @binding(3) var<uniform> S: SimParams;
@group(0) @binding(4) var<storage, read_write> pc: PairCount; // read_write for atomicAdd
@group(0) @binding(5) var<storage, read_write> pb: Pairs;
@group(0) @binding(6) var<uniform> C: Coll;
@group(0) @binding(7) var<storage, read> idx: Keys; // sorted indices
@group(0) @binding(8) var<uniform> W: Window;       // neighbor window

fn encodeNormal(n: vec3<f32>) -> vec2<u32> {
  let nx = clamp(n.x * 32767.0, -32767.0, 32767.0);
  let ny = clamp(n.y * 32767.0, -32767.0, 32767.0);
  let p0 = (u32(i32(nx) & 0xFFFF) | (u32(i32(ny) & 0xFFFF) << 16));
  let p1 = select(0u, 1u, n.z < 0.0);
  return vec2<u32>(p0, p1);
}

@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let k = gid.x;
  let n = u32(S.numParticlesF);
  if (k >= n) { return; }
  let i = idx.data[k]; // actual particle index
  let mi = M.data[i];
  if (mi <= 0.0) { return; }
  let pi = Ppos.data[i].xyz;
  let vi = Pvel.data[i].xyz;
  let w = W.w;

  // Scan a window in sorted order around k
  var start: u32 = 0u;
  if (k > w) { start = k - w; }
  let end = min(n - 1u, k + w);
  for (var t: u32 = start; t <= end; t = t + 1u) {
    if (t == k) { continue; }
    let j = idx.data[t];
    if (j <= i) { continue; } // de-dup
    let mj = M.data[j];
    if (mj <= 0.0) { continue; }
    let dp = Ppos.data[j].xyz - pi;
    let d2 = dot(dp, dp);
    let rf = max(C.rf, 0.0);
    let ri = rf * max(1.0, pow(mi, 0.3333));
    let rj = rf * max(1.0, pow(mj, 0.3333));
    let R = ri + rj;
    if (d2 < R*R) {
      let relv = Pvel.data[j].xyz - vi;
      if (dot(dp, relv) < 0.0) {
        let invL = inverseSqrt(max(d2, 1e-12));
        let nhat = dp * invL;
        let packed = encodeNormal(nhat);
        let idxPair = atomicAdd(&pc.value, 1u);
        if (idxPair < ${MAX_PAIRS}u) {
          pb.data[idxPair] = vec4<u32>(i, j, packed.x, packed.y);
        }
      }
    }
  }
}
`;

    // New: cluster reduce and BH integrate shaders
    const clusterReduceWGSL = /* wgsl */`
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Keys { data: array<u32>, }
struct Cl { size: u32, count: u32, _p2: u32, _p3: u32 }
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct OutMass { data: array<f32>, }
struct OutCom { data: array<vec4<f32>>, }

@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read> M: FloatBuf;
@group(0) @binding(2) var<storage, read> idx: Keys;
@group(0) @binding(3) var<uniform> C: Cl;
@group(0) @binding(4) var<storage, read_write> CM: OutMass;
@group(0) @binding(5) var<storage, read_write> CC: OutCom;
@group(0) @binding(6) var<uniform> S: SimParams;

const WG: u32 = 128u;
var<workgroup> sumM: array<f32, WG>;
var<workgroup> sumMV: array<vec3<f32>, WG>;
var<workgroup> bbMin: array<vec3<f32>, WG>;
var<workgroup> bbMax: array<vec3<f32>, WG>;

@compute @workgroup_size(128)
fn main(
  @builtin(workgroup_id) wid: vec3<u32>,
  @builtin(local_invocation_id) lid: vec3<u32>
) {
  let c = wid.x; // one cluster per workgroup
  if (c >= C.count) { return; }
  let n = u32(S.numParticlesF);
  let start = c * C.size;
  let end = min(n, start + C.size);

  var lm: f32 = 0.0;
  var lmv: vec3<f32> = vec3<f32>(0.0);
  var lmin: vec3<f32> = vec3<f32>(1e30);
  var lmax: vec3<f32> = vec3<f32>(-1e30);

  var t = start + lid.x;
  loop {
    if (t >= end) { break; }
    let j = idx.data[t];
    let mj = M.data[j];
    if (mj > 0.0) {
      let pj = Ppos.data[j].xyz;
      lm = lm + mj;
      lmv = lmv + mj * pj;
      lmin = min(lmin, pj);
      lmax = max(lmax, pj);
    }
    t = t + WG;
  }

  sumM[lid.x] = lm;
  sumMV[lid.x] = lmv;
  bbMin[lid.x] = lmin;
  bbMax[lid.x] = lmax;
  workgroupBarrier();

  if (lid.x == 0u) {
    var tm: f32 = 0.0;
    var tmv: vec3<f32> = vec3<f32>(0.0);
    var tmin: vec3<f32> = vec3<f32>(1e30);
    var tmax: vec3<f32> = vec3<f32>(-1e30);
    var s: u32 = 0u;
    loop {
      if (s >= WG) { break; }
      tm = tm + sumM[s];
      tmv = tmv + sumMV[s];
      tmin = min(tmin, bbMin[s]);
      tmax = max(tmax, bbMax[s]);
      s = s + 1u;
    }
    var com: vec3<f32> = vec3<f32>(0.0);
    if (tm > 0.0) { com = tmv / tm; }
    let extent = tmax - tmin;
    let radius = 0.5 * length(extent);
    CM.data[c] = tm;
    CC.data[c] = vec4<f32>(com, radius);
  }
}
`;

    const integrateBHWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Damp { factor: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
struct Repulse { k: f32, _r0: f32, _r1: f32, _r2: f32 }
struct Rad { c: f32, _r0: f32, _r1: f32, _r2: f32 }
struct Spin { w: f32, _s0: f32, _s1: f32, _s2: f32 }
struct Keys { data: array<u32>, }
struct Cl { size: u32, count: u32, _p2: u32, _p3: u32 }
struct BH { theta: f32, _b0: f32, _b1: f32, _b2: f32 }
struct ClMass { data: array<f32>, }
struct ClCom { data: array<vec4<f32>>, }

@group(0) @binding(0) var<storage, read> posIn: Vec4Buf;
@group(0) @binding(1) var<storage, read> velIn: Vec4Buf;
@group(0) @binding(2) var<storage, read_write> posOut: Vec4Buf;
@group(0) @binding(3) var<storage, read_write> velOut: Vec4Buf;
@group(0) @binding(4) var<uniform> P: SimParams;
@group(0) @binding(5) var<storage, read> M: FloatBuf;
@group(0) @binding(6) var<uniform> D: Damp;
@group(0) @binding(7) var<uniform> Rp: Repulse;
@group(0) @binding(8) var<uniform> Rd: Rad;
@group(0) @binding(9) var<uniform> Sp: Spin;
@group(0) @binding(10) var<uniform> B: BH;
@group(0) @binding(11) var<storage, read> idx: Keys;
@group(0) @binding(12) var<uniform> C: Cl;
@group(0) @binding(13) var<storage, read> CM: ClMass;
@group(0) @binding(14) var<storage, read> CC: ClCom;

@compute @workgroup_size(128)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let k = gid.x; // sorted index
  let n = u32(P.numParticlesF);
  if (k >= n) { return; }
  let i = idx.data[k];
  let mi = M.data[i];
  let isActive = mi > 0.0;
  var p = posIn.data[i].xyz;
  var v = velIn.data[i].xyz;
  if (!isActive) {
    posOut.data[i] = posIn.data[i];
    velOut.data[i] = velIn.data[i];
    return;
  }
  let eps2 = P.eps * P.eps;
  var a = vec3<f32>(0.0);
  var radiate_mag: f32 = 0.0;

  let cSize = C.size;
  let cCount = C.count;
  let cSelf = k / cSize;

  // Far-field via cluster COM, near-field via particles
  for (var c: u32 = 0u; c < cCount; c = c + 1u) {
    let mC = CM.data[c];
    if (mC <= 0.0) { continue; }
    if (c == cSelf) {
      // direct interactions inside own cluster
      let start = c * cSize;
      let end = min(n, start + cSize);
      for (var t: u32 = start; t < end; t = t + 1u) {
        let j = idx.data[t];
        if (j == i) { continue; }
        let mj = M.data[j];
        if (mj <= 0.0) { continue; }
        let d = posIn.data[j].xyz - p;
        let r2 = dot(d,d) + eps2;
        let invR = inverseSqrt(r2);
        let invR2 = invR * invR;
        let invR6 = invR2 * invR2 * invR2;
        let dir = d * invR;
        let aG = (P.G * mj) * invR2;
        let aR = (Rp.k * mj) * invR6;
        var aRad: f32 = 0.0;
        if (aR >= aG) {
          let vj = velIn.data[j].xyz;
          let closingSpeed = dot(d, v - vj);
          aRad = Rd.c * closingSpeed * invR;
          radiate_mag = radiate_mag + abs(aRad);
        }
        let aMag = aG - aR - aRad;
        a = a + dir * aMag;
      }
    } else {
      let com = CC.data[c].xyz;
      let s = CC.data[c].w; // radius
      let d = com - p;
      let r2 = dot(d,d) + eps2;
      let r = sqrt(r2);
      let open = s / max(r, 1e-6);
      if (open < B.theta) {
        let dir = d / max(r, 1e-6);
        let aG = (P.G * mC) / r2;
        a = a + dir * aG;
      } else {
        // too close: direct interactions with members of this cluster
        let start = c * cSize;
        let end = min(n, start + cSize);
        for (var t: u32 = start; t < end; t = t + 1u) {
          let j = idx.data[t];
          if (j == i) { continue; }
          let mj = M.data[j];
          if (mj <= 0.0) { continue; }
          let d2 = posIn.data[j].xyz - p;
          let r22 = dot(d2,d2) + eps2;
          let invR = inverseSqrt(r22);
          let invR2 = invR * invR;
          let invR6 = invR2 * invR2 * invR2;
          let dir2 = d2 * invR;
          let aG2 = (P.G * mj) * invR2;
          let aR2 = (Rp.k * mj) * invR6;
          var aRad2: f32 = 0.0;
          if (aR2 >= aG2) {
            let vj2 = velIn.data[j].xyz;
            let closingSpeed2 = dot(d2, v - vj2);
            aRad2 = Rd.c * closingSpeed2 * invR;
            radiate_mag = radiate_mag + abs(aRad2);
          }
          let aMag2 = aG2 - aR2 - aRad2;
          a = a + dir2 * aMag2;
        }
      }
    }
  }

  // Integrate
  v = v + a * P.dt;
  if (abs(Sp.w) > 0.0) {
    let posXZ = p.xz;
    let len2 = dot(posXZ, posXZ);
    if (len2 > 0.0) {
      let invLen = inverseSqrt(len2);
      let tang2 = vec2<f32>(-posXZ.y, posXZ.x) * invLen;
      let tang = vec3<f32>(tang2.x, 0.0, tang2.y);
      v = v + (Sp.w * P.dt) * tang;
    }
  }
  v = v * D.factor;
  p = p + v * P.dt;
  posOut.data[i] = vec4<f32>(p, radiate_mag);
  velOut.data[i] = vec4<f32>(v, 0.0);
}
`;

    // Matrices + viewport params in a 10-vec4 uniform for alignment
    let proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1e7);
    let view = lookAt([0, 0, dist], [0,0,0], [0,1,0]);
    const mats = new Float32Array(40); // 10 * vec4
    const matsBuf = device.createBuffer({ size: mats.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeMats() {
      proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1e7);
      updateView();
      mats.set(proj, 0);
      mats.set(view, 16);
      mats[32] = canvas.width;  // viewport W
      mats[33] = canvas.height; // viewport H
      mats[34] = 24.0;          // sprite sizeScale in pixels (bigger for debug)
      mats[35] = 1.0 / Math.log(1.0 + 8.0);
      device.queue.writeBuffer(matsBuf, 0, mats);
    }
    writeMats();

    // Pipelines (compute + render)
    const integrateModule = device.createShaderModule({ code: integrateWGSL });
    const integratePipe = device.createComputePipeline({ layout: 'auto', compute: { module: integrateModule, entryPoint: 'main' } });
    const detectModule = device.createShaderModule({ code: detectPairsWGSL });
    const detectPipe = device.createComputePipeline({ layout: 'auto', compute: { module: detectModule, entryPoint: 'main' } });
    const splitModule = device.createShaderModule({ code: splitWGSL });
    const splitPipe = device.createComputePipeline({ layout: 'auto', compute: { module: splitModule, entryPoint: 'main' } });

    const renderModule = device.createShaderModule({ code: renderWGSL });
    const renderPipe = device.createRenderPipeline({
      layout: 'auto',
      vertex: { module: renderModule, entryPoint: 'vs' },
      fragment: { module: renderModule, entryPoint: 'fs', targets: [{ format, blend: { color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' }, alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' } } }] },
      primitive: { topology: 'triangle-strip', cullMode: 'none' }
    });

    // Pipelines for Morton + sort
    const mortonModule = device.createShaderModule({ code: mortonWGSL });
    const mortonPipe = device.createComputePipeline({ layout: 'auto', compute: { module: mortonModule, entryPoint: 'main' } });
    const bitonicModule = device.createShaderModule({ code: bitonicWGSL });
    const bitonicPipe = device.createComputePipeline({ layout: 'auto', compute: { module: bitonicModule, entryPoint: 'main' } });
    const detectMortonModule = device.createShaderModule({ code: detectMortonWGSL });
    const detectMortonPipe = device.createComputePipeline({ layout: 'auto', compute: { module: detectMortonModule, entryPoint: 'main' } });

    // New: cluster reduce and BH integrate shaders
    const clusterReduceModule = device.createShaderModule({ code: clusterReduceWGSL });
    const clusterReducePipe = device.createComputePipeline({ layout: 'auto', compute: { module: clusterReduceModule, entryPoint: 'main' } });

    const integrateBHModule = device.createShaderModule({ code: integrateBHWGSL });
    const integrateBHPipe = device.createComputePipeline({ layout: 'auto', compute: { module: integrateBHModule, entryPoint: 'main' } });

    // Bind groups for Morton
    const mortonBG_posA = device.createBindGroup({ layout: mortonPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: mortonKeys } },
      { binding: 2, resource: { buffer: mortonIdx } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: mortonParamsBuf } },
    ]});
    const mortonBG_posB = device.createBindGroup({ layout: mortonPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: mortonKeys } },
      { binding: 2, resource: { buffer: mortonIdx } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: mortonParamsBuf } },
    ]});

    const bitonicBG = device.createBindGroup({ layout: bitonicPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: mortonKeys } },
      { binding: 1, resource: { buffer: mortonIdx } },
      { binding: 2, resource: { buffer: sortParamsBuf } },
    ]});

    const detectMortonBG_posA = device.createBindGroup({ layout: detectMortonPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: radiusBuf } },
      { binding: 7, resource: { buffer: mortonIdx } },
      { binding: 8, resource: { buffer: windowBuf } },
    ]});
    const detectMortonBG_posB = device.createBindGroup({ layout: detectMortonPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: radiusBuf } },
      { binding: 7, resource: { buffer: mortonIdx } },
      { binding: 8, resource: { buffer: windowBuf } },
    ]});

    // Bind groups for cluster reduce (posA/posB)
    const clusterReduceBG_posA = device.createBindGroup({ layout: clusterReducePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: mortonIdx } },
      { binding: 3, resource: { buffer: clBuf } },
      { binding: 4, resource: { buffer: clMassBuf } },
      { binding: 5, resource: { buffer: clComBuf } },
      { binding: 6, resource: { buffer: simParamsBuf } },
    ]});
    const clusterReduceBG_posB = device.createBindGroup({ layout: clusterReducePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: mortonIdx } },
      { binding: 3, resource: { buffer: clBuf } },
      { binding: 4, resource: { buffer: clMassBuf } },
      { binding: 5, resource: { buffer: clComBuf } },
      { binding: 6, resource: { buffer: simParamsBuf } },
    ]});

    // Bind groups for integrateBH (A->B and B->A)
    const integrateBHBG_AtoB = device.createBindGroup({ layout: integrateBHPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: posB } },
      { binding: 3, resource: { buffer: velB } },
      { binding: 4, resource: { buffer: simParamsBuf } },
      { binding: 5, resource: { buffer: masses } },
      { binding: 6, resource: { buffer: dampBuf } },
      { binding: 7, resource: { buffer: repulseBuf } },
      { binding: 8, resource: { buffer: radBuf } },
      { binding: 9, resource: { buffer: spinBuf } },
      { binding: 10, resource: { buffer: bhBuf } },
      { binding: 11, resource: { buffer: mortonIdx } },
      { binding: 12, resource: { buffer: clBuf } },
      { binding: 13, resource: { buffer: clMassBuf } },
      { binding: 14, resource: { buffer: clComBuf } },
    ]});
    const integrateBHBG_BtoA = device.createBindGroup({ layout: integrateBHPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: posA } },
      { binding: 3, resource: { buffer: velA } },
      { binding: 4, resource: { buffer: simParamsBuf } },
      { binding: 5, resource: { buffer: masses } },
      { binding: 6, resource: { buffer: dampBuf } },
      { binding: 7, resource: { buffer: repulseBuf } },
      { binding: 8, resource: { buffer: radBuf } },
      { binding: 9, resource: { buffer: spinBuf } },
      { binding: 10, resource: { buffer: bhBuf } },
      { binding: 11, resource: { buffer: mortonIdx } },
      { binding: 12, resource: { buffer: clBuf } },
      { binding: 13, resource: { buffer: clMassBuf } },
      { binding: 14, resource: { buffer: clComBuf } },
    ]});

    // Compute bind groups
    const integrateBG_AtoB = device.createBindGroup({ layout: integratePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: posB } },
      { binding: 3, resource: { buffer: velB } },
      { binding: 4, resource: { buffer: simParamsBuf } },
      { binding: 5, resource: { buffer: masses } },
      { binding: 6, resource: { buffer: dampBuf } },
      { binding: 7, resource: { buffer: repulseBuf } },
      { binding: 8, resource: { buffer: radBuf } },
      { binding: 9, resource: { buffer: spinBuf } }, // new spin
    ]});
    const integrateBG_BtoA = device.createBindGroup({ layout: integratePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: posA } },
      { binding: 3, resource: { buffer: velA } },
      { binding: 4, resource: { buffer: simParamsBuf } },
      { binding: 5, resource: { buffer: masses } },
      { binding: 6, resource: { buffer: dampBuf } },
      { binding: 7, resource: { buffer: repulseBuf } },
      { binding: 8, resource: { buffer: radBuf } },
      { binding: 9, resource: { buffer: spinBuf } }, // new spin
    ]});

    const detectBG_posA = device.createBindGroup({ layout: detectPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: radiusBuf } },
    ]});
    const detectBG_posB = device.createBindGroup({ layout: detectPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: radiusBuf } },
    ]});

    const splitBG_velA = device.createBindGroup({ layout: splitPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: velA } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: pairCount } },
      { binding: 3, resource: { buffer: pairBuf } },
      { binding: 4, resource: { buffer: restBuf } },
      { binding: 5, resource: { buffer: locks } },
      { binding: 6, resource: { buffer: claims } },
    ]});
    const splitBG_velB = device.createBindGroup({ layout: splitPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: velB } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: pairCount } },
      { binding: 3, resource: { buffer: pairBuf } },
      { binding: 4, resource: { buffer: restBuf } },
      { binding: 5, resource: { buffer: locks } },
      { binding: 6, resource: { buffer: claims } },
    ]});

    const renderBG_posA = device.createBindGroup({ layout: renderPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: matsBuf } },
    ]});
    const renderBG_posB = device.createBindGroup({ layout: renderPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: matsBuf } },
    ]});

    // Removed separate spin bind groups (spin is applied in integrate)

    // Frame loop
    let readFromA = true;
    let lastT = performance.now();
    let frameCount = 0;
    function frame() {
      const now = performance.now();
      const dtMs = now - lastT; lastT = now;
      writeMats();
      simParams[0] = dt; simParams[1] = G; simParams[2] = 1.0; simParams[3] = particleCount; // eps = 1.0
      writeSimParams();
      writeRepulse(); // ensure R updates
      writeRad();     // ensure radiative damping updates
      // Force spin = 1.0 for first 10 frames, then use UI-controlled value
      if (frameCount < 10) { spinParams[0] = 1.0; device.queue.writeBuffer(spinBuf, 0, spinParams); } else { writeSpin(); }

      const enc = device.createCommandEncoder();

      // Collisions: optionally run detect+split every k frames
      const doCollisions = collisionsEnabled && ((frameCount % collideEvery) === 0);

      // If BH is enabled, compute morton + sort first (used for BH and possibly collisions)
      if (useBH) {
        // morton keys
        {
          const p0 = enc.beginComputePass();
          p0.setPipeline(mortonPipe);
          p0.setBindGroup(0, readFromA ? mortonBG_posA : mortonBG_posB);
          p0.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
          p0.end();
        }
        // bitonic sort
        let kStage = 2;
        while (kStage <= particleCount) {
          let jStage = kStage >> 1;
          while (jStage > 0) {
            writeSortJK(jStage, kStage);
            const pS = enc.beginComputePass();
            pS.setPipeline(bitonicPipe);
            pS.setBindGroup(0, bitonicBG);
            pS.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
            pS.end();
            jStage >>= 1;
          }
          kStage <<= 1;
        }
        // cluster reduction
        {
          const pR = enc.beginComputePass();
          pR.setPipeline(clusterReducePipe);
          pR.setBindGroup(0, readFromA ? clusterReduceBG_posA : clusterReduceBG_posB);
          pR.dispatchWorkgroups(clusterCountUsed);
          pR.end();
        }
      }

      if (doCollisions) {
        device.queue.writeBuffer(pairCount, 0, new Uint32Array([0]));
        device.queue.writeBuffer(locks, 0, new Uint32Array(particleCount));
        device.queue.writeBuffer(claims, 0, new Uint32Array(particleCount));

        if (useMorton && !useBH) {
          // Compute morton + sort for collisions if not already done for BH
          {
            const p0 = enc.beginComputePass();
            p0.setPipeline(mortonPipe);
            p0.setBindGroup(0, readFromA ? mortonBG_posA : mortonBG_posB);
            p0.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
            p0.end();
          }
          let kStage2 = 2;
          while (kStage2 <= particleCount) {
            let jStage2 = kStage2 >> 1;
            while (jStage2 > 0) {
              writeSortJK(jStage2, kStage2);
              const pS2 = enc.beginComputePass();
              pS2.setPipeline(bitonicPipe);
              pS2.setBindGroup(0, bitonicBG);
              pS2.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
              pS2.end();
              jStage2 >>= 1;
            }
            kStage2 <<= 1;
          }
        }

        if (useMorton) {
          const p1 = enc.beginComputePass();
          p1.setPipeline(detectMortonPipe);
          p1.setBindGroup(0, readFromA ? detectMortonBG_posA : detectMortonBG_posB);
          p1.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
          p1.end();
        } else {
          const p0 = enc.beginComputePass();
          p0.setPipeline(detectPipe);
          p0.setBindGroup(0, readFromA ? detectBG_posA : detectBG_posB);
          p0.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
          p0.end();
        }
      }

      // Integrate all particles (BH or direct)
      {
        const p = enc.beginComputePass();
        if (useBH) {
          writeBHParams(); // ensure uniforms updated
          p.setPipeline(integrateBHPipe);
          p.setBindGroup(0, readFromA ? integrateBHBG_AtoB : integrateBHBG_BtoA);
        } else {
          p.setPipeline(integratePipe);
          p.setBindGroup(0, readFromA ? integrateBG_AtoB : integrateBG_BtoA);
        }
        p.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
        p.end();
        readFromA = !readFromA;
      }

      // Split using pairs from this frame (if any)
      if (doCollisions) {
        const p2 = enc.beginComputePass();
        p2.setPipeline(splitPipe);
        p2.setBindGroup(0, readFromA ? splitBG_velA : splitBG_velB);
        p2.dispatchWorkgroups(Math.ceil(MAX_PAIRS / WG_SIZE));
        p2.end();
      }

      // Render
      {
        const viewTex = context.getCurrentTexture().createView();
        const rp = enc.beginRenderPass({ colorAttachments: [{ view: viewTex, clearValue: {r:0,g:0,b:0,a:1}, loadOp: 'clear', storeOp: 'store' }] });
        rp.setPipeline(renderPipe);
        rp.setBindGroup(0, readFromA ? renderBG_posA : renderBG_posB);
        rp.draw(4, particleCount);
        rp.end();

        // enqueue copy for CPU debug overlay
        enc.copyBufferToBuffer(readFromA ? posA : posB, 0, readbackPos, 0, stateBytes);
        enc.copyBufferToBuffer(readFromA ? velA : velB, 0, readbackVel, 0, stateBytes);
      }

      device.queue.submit([enc.finish()]);

      // Draw overlay after GPU submit (non-blocking map)
      drawOverlay();

      frameCount++;
      statsDiv.textContent = `fps: ${(1000/Math.max(1, dtMs)).toFixed(0)}  particles: ${particleCount}`;
      requestAnimationFrame(frame);
    }

    async function drawOverlay(){
      octx.clearRect(0,0,overlay.width, overlay.height);
      // map last frame data
      try{
        await readbackPos.mapAsync(GPUMapMode.READ);
        await readbackVel.mapAsync(GPUMapMode.READ);
      } catch(e) { return; }
      const pArr = new Float32Array(readbackPos.getMappedRange());
      const vArr = new Float32Array(readbackVel.getMappedRange());

      // Snapshot proj/view from GPU uniforms
      // Recompute like writeMats() to match
      const W = canvas.width, H = canvas.height;
      const projSnap = perspective(Math.PI/4, W/H, 0.1, 1e7);
      updateView();
      const viewSnap = view;

      // Pairwise and net forces (CPU, for visualization only)
      // Colors: gravity (cyan), repulsion (magenta), radiative drag (yellow), net (white)
      // Only draw for small N
      const n = particleCount;
      for (let i=0;i<n;i++){
        const io = i*4;
        const pi = [pArr[io], pArr[io+1], pArr[io+2]];
        const vi = [vArr[io], vArr[io+1], vArr[io+2]];
        let aNet = [0,0,0];
        for (let j=i+1;j<n;j++){
          const jo = j*4;
          const pj = [pArr[jo], pArr[jo+1], pArr[jo+2]];
          const vj = [vArr[jo], vArr[jo+1], vArr[jo+2]];
          const dx = [pj[0]-pi[0], pj[1]-pi[1], pj[2]-pi[2]];
          const r2 = dx[0]*dx[0]+dx[1]*dx[1]+dx[2]*dx[2] + 1.0; // eps^2
          const r = Math.sqrt(r2);
          const dir = [dx[0]/r, dx[1]/r, dx[2]/r];
          // simple unit masses for viz
          const aG = (G) / r2;
          const aR = (R) / (r2*r2);
          const closing = (dx[0]*(vi[0]-vj[0]) + dx[1]*(vi[1]-vj[1]) + dx[2]*(vi[2]-vj[2]))/r;
          const aRad = (aR >= aG) ? (radiativeDamping * closing / r) : 0.0;
          const aPair = [ dir[0]*(aG - aR - aRad), dir[1]*(aG - aR - aRad), dir[2]*(aG - aR - aRad) ];
          aNet[0]+=aPair[0]; aNet[1]+=aPair[1]; aNet[2]+=aPair[2];
          if (showPairs) {
            drawVector(pi, aPair, projSnap, viewSnap, W, H, 'rgba(0,255,255,0.7)'); // cyan
            drawVector(pj, [-aPair[0],-aPair[1],-aPair[2]], projSnap, viewSnap, W, H, 'rgba(0,255,255,0.7)');
            // repulsion magenta
            const aRep = [ dir[0]*aR, dir[1]*aR, dir[2]*aR ];
            drawVector(pi, [-aRep[0],-aRep[1],-aRep[2]], projSnap, viewSnap, W, H, 'rgba(255,0,255,0.5)');
            drawVector(pj, aRep, projSnap, viewSnap, W, H, 'rgba(255,0,255,0.5)');
            // radiative yellow if active
            if (aRad !== 0.0){
              const aRadV = [ dir[0]*aRad, dir[1]*aRad, dir[2]*aRad ];
              drawVector(pi, [-aRadV[0],-aRadV[1],-aRadV[2]], projSnap, viewSnap, W, H, 'rgba(255,255,0,0.6)');
              drawVector(pj, aRadV, projSnap, viewSnap, W, H, 'rgba(255,255,0,0.6)');
            }
          }
        }
        if (showNet) drawVector(pi, aNet, projSnap, viewSnap, W, H, 'rgba(255,255,255,0.9)');
      }

      // Draw simple CPU octree boxes: compute AABB of all, then split into 8 octants (one level)
      if (showBoxes){
        const pts = [];
        for (let i=0;i<n;i++){ const o=i*4; pts.push([pArr[o],pArr[o+1],pArr[o+2]]); }
        const root = aabbOf(pts);
        drawAABB(root.min, root.max, projSnap, viewSnap, W, H, 'rgba(0,128,255,0.5)');
        const octs = splitOct(root, 1); // 1 level
        for (const box of octs){ drawAABB(box.min, box.max, projSnap, viewSnap, W, H, 'rgba(0,255,128,0.35)'); }
      }

      readbackPos.unmap();
      readbackVel.unmap();
    }

    function drawVector(p, a, proj, view, W, H, color){
      // scale into screen space
      const scale = 100 * vecScale; // tune
      const q = [ p[0] + a[0]*scale, p[1] + a[1]*scale, p[2] + a[2]*scale ];
      const s0 = project(p, proj, view, W, H);
      const s1 = project(q, proj, view, W, H);
      if (!isFinite(s0[0]) || !isFinite(s1[0])) return;
      octx.strokeStyle = color;
      octx.lineWidth = 2;
      octx.beginPath();
      octx.moveTo(s0[0], s0[1]);
      octx.lineTo(s1[0], s1[1]);
      octx.stroke();
      // arrow head
      const vx = s1[0] - s0[0], vy = s1[1] - s0[1];
      const len = Math.hypot(vx,vy) || 1;
      const ux = vx/len, uy = vy/len;
      const size = 6;
      octx.beginPath();
      octx.moveTo(s1[0], s1[1]);
      octx.lineTo(s1[0] - ux*size - uy*size*0.5, s1[1] - uy*size + ux*size*0.5);
      octx.lineTo(s1[0] - ux*size + uy*size*0.5, s1[1] - uy*size - ux*size*0.5);
      octx.closePath();
      octx.fillStyle = color;
      octx.fill();
    }

    function aabbOf(pts){
      const min=[1e30,1e30,1e30], max=[-1e30,-1e30,-1e30];
      for(const p of pts){ for(let k=0;k<3;k++){ if(p[k]<min[k])min[k]=p[k]; if(p[k]>max[k])max[k]=p[k]; } }
      return {min,max};
    }
    function splitOct(box, levels){
      const {min,max} = box; const c=[(min[0]+max[0])/2,(min[1]+max[1])/2,(min[2]+max[2])/2];
      const octs=[];
      for(let xi=0;xi<2;xi++) for(let yi=0;yi<2;yi++) for(let zi=0;zi<2;zi++){
        const mn=[ xi?c[0]:min[0], yi?c[1]:min[1], zi?c[2]:min[2] ];
        const mx=[ xi?max[0]:c[0], yi?max[1]:c[1], zi?max[2]:c[2] ];
        octs.push({min:mn,max:mx});
      }
      if (levels<=1) return octs; // stop
      const child=[];
      for(const o of octs){ child.push(...splitOct(o, levels-1)); }
      return child;
    }
  })();
  </script>
</body>
</html>
