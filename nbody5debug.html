<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebGPU N-Body (merge + split) – nbody5</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    canvas { width: 100vw; height: 100vh; display: block; }
    /* Overlay canvas for CPU-side debug rendering */
    #overlay { position: fixed; left: 0; top: 0; pointer-events: none; width: 100vw; height: 100vh; }
    #ui { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: #fff; font-family: system-ui, sans-serif; padding: 10px; font-size: 12px; }
    #ui label { display:block; margin: 6px 0 2px; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <canvas id="overlay"></canvas>
  <div id="ui">
    <div><b>Controls</b></div>
    <label>G: <span id="gVal">0.30</span></label>
    <input id="g" type="range" min="0.01" max="5.0" step="0.01" value="0.30" />

    <label>dt: <span id="dtVal">0.20</span></label>
    <input id="dt" type="range" min="0.01" max="1.00" step="0.01" value="0.20" />

    <label>Restitution (alpha): <span id="restVal">1.00</span></label>
    <input id="rest" type="range" min="0.0" max="1.0" step="0.01" value="1.00" />

    <!-- New: Radius factor slider -->
    <label>Radius factor: <span id="rfVal">2</span></label>
    <input id="rf" type="range" min="1" max="100" step="1" value="2" />

    <!-- New: Repulsion (R) slider -->
    <label>Repulsion R: <span id="repVal">10</span></label>
    <input id="rep" type="range" min="0" max="100" step="1" value="10" />

    <!-- New: Spin and Damping sliders -->
    <label>Spin: <span id="spinVal">0.00</span></label>
    <input id="spin" type="range" min="-2.0" max="2.0" step="0.01" value="0.00" />

    <label>Damping: <span id="dampVal">1.00</span></label>
    <input id="damp" type="range" min="0.0" max="1.0" step="0.001" value="1.00" />

    <!-- New: Radiative damping -->
    <label>Radiative: <span id="radVal">0.005</span></label>
    <input id="rad" type="range" min="0.0" max="0.1" step="0.001" value="0.005" />

  <!-- New: Collision controls -->
  <label>Collide every k frames: <span id="collideKVal">1</span></label>
  <input id="collideK" type="range" min="1" max="8" step="1" value="1" />

  <!-- Morton (octree) indexing for collisions -->
  <label>Neighbor window: <span id="winVal">64</span></label>
  <input id="win" type="range" min="8" max="256" step="8" value="64" />

  <!-- Approach-only toggle for detectMorton (checked = only record approaching pairs) -->
  <label><input id="approach" type="checkbox" checked /> Approach-only pairs</label>

  <!-- Barnes–Hut controls -->
    <label>Opening angle θ: <span id="thetaVal">0.60</span></label>
    <input id="theta" type="range" min="0.2" max="1.0" step="0.05" value="0.60" />
    <label>Cluster size: <span id="clSizeVal">64</span></label>
    <input id="clSize" type="range" min="16" max="256" step="16" value="64" />

  <!-- Debug overlays rendered by GPU shader; toggles removed (always enabled via code) -->

    <div id="stats" style="margin-top:6px; opacity: 0.85;"></div>
    <div style="margin-top:6px;">
      <button id="startStop">Pause</button>
      <button id="step">Step</button>
    </div>
    <div style="margin-top:6px;">
      <button id="dumpPairs">Dump pairs (one frame)</button>
    </div>
  </div>

  <script>
  "use strict";
  (async () => {
    const canvas = document.getElementById('c');
    const overlay = document.getElementById('overlay');
    const octx = overlay.getContext('2d');
    const statsDiv = document.getElementById('stats');
    if (!('gpu' in navigator)) { alert('WebGPU not supported'); return; }

    const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' }) || await navigator.gpu.requestAdapter();
    if (!adapter) { alert('No GPU adapter'); return; }
    // Some devices support more storage buffers per stage than the default (8).
    // Relaxed: if not granted, continue with defaults.
    const DESIRED_MAX_STORAGE = 10;
    let device;
    try {
      const adapterMax = adapter.limits && adapter.limits.maxStorageBuffersPerShaderStage;
      if (typeof adapterMax === 'number' && adapterMax >= DESIRED_MAX_STORAGE) {
        device = await adapter.requestDevice({ requiredLimits: { maxStorageBuffersPerShaderStage: DESIRED_MAX_STORAGE } });
      } else {
        try {
          device = await adapter.requestDevice({ requiredLimits: { maxStorageBuffersPerShaderStage: DESIRED_MAX_STORAGE } });
        } catch (e) {
          console.warn('Could not obtain higher storage buffer limit, falling back to default device:', e);
          device = await adapter.requestDevice();
        }
      }
      // Debug: log uncaptured GPU errors to console to help diagnose why nothing renders
      if (device) {
        try { device.addEventListener('uncapturederror', (ev) => console.error('GPU uncap error', ev)); } catch (e) {}
        try { device.onuncapturederror = (ev) => console.error('GPU onuncapturederror', ev); } catch (e) {}
      }
    } catch (e) {
      console.warn('requestDevice failed, cannot continue:', e);
      alert('Unable to initialize GPU device');
      return;
    }

    const context = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();
    const WG_SIZE = 64; // small workgroup for debug

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      overlay.width = canvas.width;
      overlay.height = canvas.height;
      context.configure({ device, format, alphaMode: 'opaque' });
    }
    resize();
    addEventListener('resize', resize);

    // Simple parameters/UI
    let G = 3.30;
    let dt = 0.50;
    let restitution = 1.00;
    let radiusFactor = 2.0;
    let R = 10.0;
    let spin = 0.00;
    let damping = 1.00;
    let radiativeDamping = 0.005;
    let collisionsEnabled = true; // collisions always enabled in this simplified build
    let collideEvery = 1;         // new: run collisions every k frames
    let useMorton = true;         // morton/octree always used
    let neighborWindow = 64;      // new: neighbors to scan on each side in Morton order
    let useBH = true;             // Barnes–Hut always used
    let theta = 0.60;             // new: BH opening angle
    let clusterSize = 64;         // new: leaf capacity approximation

    // Debug build: Morton/BH paths are disabled; keep UI responsive with no-op writers
    function writeWindow() { /* no-op in debug build */ }
    function writeBHParams() { /* no-op in debug build */ }

    const gEl = document.getElementById('g');
    const gVal = document.getElementById('gVal');
    gEl.addEventListener('input', () => { G = parseFloat(gEl.value); gVal.textContent = G.toFixed(2); writeSimParams(); });
    const dtEl = document.getElementById('dt');
    const dtVal = document.getElementById('dtVal');
    dtEl.addEventListener('input', () => { dt = parseFloat(dtEl.value); dtVal.textContent = dt.toFixed(2); writeSimParams(); });
    const restEl = document.getElementById('rest');
    const restVal = document.getElementById('restVal');
    restEl.addEventListener('input', () => { restitution = parseFloat(restEl.value); restVal.textContent = restitution.toFixed(2); writeRest(); });

    // New: radius factor UI wiring
    const rfEl = document.getElementById('rf');
    const rfVal = document.getElementById('rfVal');
    rfEl.addEventListener('input', () => { radiusFactor = parseFloat(rfEl.value); rfVal.textContent = String(rfEl.value); writeRadius(); });

    // New: repulsion UI wiring
    const repEl = document.getElementById('rep');
    const repVal = document.getElementById('repVal');
    repEl.addEventListener('input', () => { R = parseFloat(repEl.value); repVal.textContent = String(repEl.value); writeRepulse(); });

    // New: spin + damping UI wiring
    const spinEl = document.getElementById('spin');
    const spinVal = document.getElementById('spinVal');
    spinEl.addEventListener('input', () => { spin = parseFloat(spinEl.value); spinVal.textContent = spin.toFixed(2); writeSpin(); });
    const dampEl = document.getElementById('damp');
    const dampVal = document.getElementById('dampVal');
    dampEl.addEventListener('input', () => { damping = parseFloat(dampEl.value); dampVal.textContent = damping.toFixed(3); writeDamp(); });

    // New: radiative damping UI wiring
    const radEl = document.getElementById('rad');
    const radVal = document.getElementById('radVal');
    radEl.addEventListener('input', () => { radiativeDamping = parseFloat(radEl.value); radVal.textContent = radiativeDamping.toFixed(3); writeRad(); });

  // New: collision UI wiring (collisions always on)
  const collideKEl = document.getElementById('collideK');
  const collideKVal = document.getElementById('collideKVal');
  collideKEl.addEventListener('input', () => { collideEvery = parseInt(collideKEl.value); collideKVal.textContent = String(collideEvery); });

  // New: Morton/octree UI wiring
  const winEl = document.getElementById('win');
  const winVal = document.getElementById('winVal');
  winEl.addEventListener('input', () => { neighborWindow = parseInt(winEl.value); winVal.textContent = String(neighborWindow); writeWindow(); });
    
    

  // New: BH UI wiring
  const thetaEl = document.getElementById('theta');
  const thetaVal = document.getElementById('thetaVal');
  const clSizeEl = document.getElementById('clSize');
  const clSizeVal = document.getElementById('clSizeVal');
  thetaEl.addEventListener('input', () => { theta = parseFloat(thetaEl.value); thetaVal.textContent = theta.toFixed(2); writeBHParams(); });
  clSizeEl.addEventListener('input', () => { clusterSize = parseInt(clSizeEl.value); clSizeVal.textContent = String(clusterSize); writeBHParams(); });

    // Basic math helpers (column-major matrices like WebGPU expects)
    function perspective(fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      return new Float32Array([
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * far * near) * nf, 0
      ]);
    }
    function normalize(a) { const l = Math.hypot(a[0],a[1],a[2]) || 1; return [a[0]/l, a[1]/l, a[2]/l]; }
    function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
    function dot(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
    function lookAt(eye, center, up) {
      const f = normalize([center[0]-eye[0], center[1]-eye[1], center[2]-eye[2]]);
      const s = normalize(cross(f, up));
      const u = cross(s, f);
      return new Float32Array([
        s[0], u[0], -f[0], 0,
        s[1], u[1], -f[1], 0,
        s[2], u[2], -f[2], 0,
        - (s[0]*eye[0] + s[1]*eye[1] + s[2]*eye[2]),
        - (u[0]*eye[0] + u[1]*eye[1] + u[2]*eye[2]),
        (f[0]*eye[0] + f[1]*eye[1] + f[2]*eye[2]),
        1
      ]);
    }

    // Orbit camera (simple)
    let az = 0.3, el = 0.6, dist = 2000.0;
    let view = lookAt([0, 0, dist], [0,0,0], [0,1,0]);
    function updateView() {
      const ce = Math.cos(el), se = Math.sin(el), sa = Math.sin(az), ca = Math.cos(az);
      const eye = [ dist * ce * sa, dist * se, dist * ce * ca ];
      view = lookAt(eye, [0,0,0], [0,1,0]);
    }
    (function orbitControls(){
      let drag=false, lx=0, ly=0;
      canvas.addEventListener('mousedown', (e)=>{ if(e.button===0){ drag=true; lx=e.clientX; ly=e.clientY; }});
      addEventListener('mouseup', ()=> drag=false);
      addEventListener('mousemove', (e)=>{
        if(!drag) return; const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY;
        az += dx * 0.005; el += dy * 0.005;
        const minEl = -Math.PI/2 + 0.01;
        const maxEl =  Math.PI/2 - 0.01;
        el = Math.max(minEl, Math.min(maxEl, el));
      });
      canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); dist *= Math.exp(e.deltaY * 0.001); dist = Math.max(10, Math.min(1e6, dist)); }, {passive:false});
    })();

    // Simulation setup (simple random sphere)
    const particleCount = 32; // keep moderate
    const stride = 4; // vec4
    const stateBytes = particleCount * stride * 4;

    function makeBuf(size, usage) { return device.createBuffer({ size, usage }); }
    function bufFrom(arr, usage) {
      const b = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
      new Float32Array(b.getMappedRange()).set(arr);
      b.unmap(); return b;
    }

    const posInit = new Float32Array(particleCount * stride);
    const massInit = new Float32Array(particleCount);
    const rad = 800.0;
    for (let i=0;i<particleCount;i++){
      let x,y,z; do { x=(Math.random()*2-1)*rad; y=(Math.random()*2-1)*rad; z=(Math.random()*2-1)*rad; } while (x*x+y*y+z*z>rad*rad);
      const o=i*stride; posInit[o]=x; posInit[o+1]=y; posInit[o+2]=z; posInit[o+3]=0;
      massInit[i]=1.0;
    }
    let posA = bufFrom(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
    let posB = makeBuf(stateBytes, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
    // Verlet previous positions
    let prevPosA = bufFrom(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC);
    let prevPosB = makeBuf(stateBytes, GPUBufferUsage.STORAGE);
    const masses = bufFrom(massInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);

    // Pair visualization buffers (CPU generated)
    const MAX_PAIRS = (particleCount * (particleCount - 1)) >> 1;
    const visPairBuf = device.createBuffer({ size: MAX_PAIRS * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const outPairCount = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    // Readback helpers for dump
    const pairCountReadback = device.createBuffer({ size: 4, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
    const DUMP_PAIRS_N = 64;
    const pairBufReadback = device.createBuffer({ size: DUMP_PAIRS_N * 16, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });
    const posReadback = device.createBuffer({ size: 16, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });

    // --- Octree-bucket AABB debug (post-sort reduction approximation) ---
    // Partition sorted positions into small buckets in Morton order (for debug we use contiguous buckets)
    const BUCKET_SIZE = 4; // tune for debug; smaller -> more boxes
    const bucketCount = Math.ceil(particleCount / BUCKET_SIZE);
    // nodeBuf holds min(vec4) then max(vec4) per bucket (2 vec4 per bucket)
    const nodeBuf = device.createBuffer({ size: bucketCount * 2 * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
    const nodeParams = new Float32Array([particleCount, BUCKET_SIZE, bucketCount, 0]);
    const nodeParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    device.queue.writeBuffer(nodeParamsBuf, 0, nodeParams);

    // WGSL: reduction that computes min/max per bucket
    const reduceWGSL = `
struct UBO { n: f32, bucket: f32, bucketCount: f32, pad: f32 };
@group(0) @binding(0) var<storage, read> posBuf: array<vec4f>;
@group(0) @binding(1) var<storage, read_write> nodeBuf: array<vec4f>;
@group(0) @binding(2) var<uniform> params: UBO;

@compute @workgroup_size(1)
fn main(@builtin(global_invocation_id) gid: vec3u) {
  let k = gid.x;
  let N = u32(params.n);
  let bsz = u32(params.bucket);
  let start = k * bsz;
  if (start >= N) {
    // empty slot
    nodeBuf[2u*k] = vec4f(0.0);
    nodeBuf[2u*k+1u] = vec4f(0.0);
    return;
  }
  var mn = vec3f(1e30, 1e30, 1e30);
  var mx = vec3f(-1e30, -1e30, -1e30);
  let end = min(start + bsz, N);
  var i = start;
  loop {
    let p = posBuf[i].xyz;
    mn = min(mn, p);
    mx = max(mx, p);
    i = i + 1u;
    if (i >= end) { break; }
  }
  nodeBuf[2u*k] = vec4f(mn, 0.0);
  nodeBuf[2u*k+1u] = vec4f(mx, 0.0);
}
`;
    const reduceModule = device.createShaderModule({ code: reduceWGSL });
    const reducePipe = device.createComputePipeline({ layout: 'auto', compute: { module: reduceModule, entryPoint: 'main' } });

    // Bind groups for reduction (posA/posB)
    const reduceBG_A = device.createBindGroup({ layout: reducePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: nodeBuf } },
      { binding: 2, resource: { buffer: nodeParamsBuf } },
    ]});
    const reduceBG_B = device.createBindGroup({ layout: reducePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: nodeBuf } },
      { binding: 2, resource: { buffer: nodeParamsBuf } },
    ]});

    console.log('DEBUG: reducePipe/bindgroups created', { reducePipe: !!reducePipe, reduceBG_A: !!reduceBG_A, reduceBG_B: !!reduceBG_B });

    // WGSL for rendering boxes as instanced line geometry (24 edges -> 48 vertices per instance)
    const boxesWGSL = `
struct VSOut { @builtin(position) pos: vec4f, @location(0) col: vec4f };
@group(0) @binding(0) var<storage, read> nodeBuf: array<vec4f>;
struct UBO { proj: mat4x4f, view: mat4x4f, vp: vec4f };
@group(0) @binding(1) var<uniform> ubo: UBO;

const EDGES : array<u32, 24> = array<u32,24>(
  0u,1u, 1u,3u, 3u,2u, 2u,0u,  // bottom
  4u,5u, 5u,7u, 7u,6u, 6u,4u,  // top
  0u,4u, 1u,5u, 2u,6u, 3u,7u   // verticals
);

fn cornerPos(c: u32, mn: vec3f, mx: vec3f) -> vec3f {
  let bx = f32((c & 1u));
  let by = f32(((c >> 1u) & 1u));
  let bz = f32(((c >> 2u) & 1u));
  return mn + vec3f(bx, by, bz) * (mx - mn);
}

@vertex fn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VSOut {
  var o: VSOut;
  let edge = vid / 2u;
  if (u32(iid) >= ${bucketCount}u) {
    o.pos = vec4f(2.0,2.0,2.0,1.0);
    o.col = vec4f(0.0);
    return o;
  }
  let a = nodeBuf[2u*iid].xyz;
  let b = nodeBuf[2u*iid+1u].xyz;
  let ea = EDGES[edge*2u + 0u];
  let eb = EDGES[edge*2u + 1u];
  let endpoint = vid % 2u;
  let ci = select(ea, eb, endpoint == 1u);
  let P = cornerPos(ci, a, b);
  let vp4 = ubo.proj * ubo.view * vec4f(P, 1.0);
  o.pos = vp4;
  // color by depth approximation: use teal
  o.col = vec4f(0.0, 0.8, 1.0, 0.8);
  return o;
}

@fragment fn fs(inp: VSOut) -> @location(0) vec4f { return inp.col; }
`;
    const boxesModule = device.createShaderModule({ code: boxesWGSL });
    const boxesPipe = device.createRenderPipeline({
      layout: 'auto',
      vertex: { module: boxesModule, entryPoint: 'vs' },
      fragment: { module: boxesModule, entryPoint: 'fs', targets: [{ format, blend: { color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' }, alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' } } }] },
      primitive: { topology: 'line-list', cullMode: 'none' }
    });

    // NOTE: matsBuf is declared later; avoid referencing it here to prevent TDZ ReferenceError.
    console.log('DEBUG: boxesPipe created', { boxesPipe: !!boxesPipe, nodeBufSize: bucketCount * 2 * 16 });

    // Matrices + viewport params in a 10-vec4 uniform for alignment (used by renderers and box shader)
    let proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1e7);
     const mats = new Float32Array(40); // 10 * vec4
     const matsBuf = device.createBuffer({ size: mats.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
     function writeMats() {
       proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1e7);
       updateView();
       mats.set(proj, 0);
       mats.set(view, 16);
       mats[32] = canvas.width;  // viewport W
       mats[33] = canvas.height; // viewport H
       mats[34] = 18.0;          // sprite sizeScale in pixels
       mats[35] = 1.0 / Math.log(1.0 + 8.0); // inverse log(maxMass+1)
       device.queue.writeBuffer(matsBuf, 0, mats);
     }
     writeMats();

    // Render shader used by full build — include here so debug can create the render pipeline
    const renderWGSL = `
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Mats { m: array<vec4<f32>, 10>, }
@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read> M: FloatBuf;
@group(0) @binding(2) var<uniform> U: Mats;

struct VSOut {
  @builtin(position) pos: vec4<f32>,
  @location(0) uv: vec2<f32>,
  @location(1) radiate: f32,
  @location(2) massNorm: f32,
};

fn loadMat(idx: u32) -> mat4x4<f32> {
  let b = idx * 4u;
  return mat4x4<f32>(U.m[b+0u], U.m[b+1u], U.m[b+2u], U.m[b+3u]);
}

@vertex
fn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VSOut {
  // Per-instance particle index
  let pos4 = Ppos.data[iid];
  let world = pos4.xyz;
  let mass = M.data[iid];

  // Cull dead particles (mass <= 0)
  if (mass <= 0.0) {
    var out: VSOut;
    out.pos = vec4<f32>(2.0, 2.0, 1.0, 1.0);
    out.uv = vec2<f32>(2.0);
    out.radiate = 0.0;
    out.massNorm = 0.0;
    return out;
  }

  // Corner in NDC pixel space: (-1,-1), (-1,1), (1,-1), (1,1)
  var corner: vec2<f32>;
  switch (vid & 3u) {
    case 0u: { corner = vec2<f32>(-1.0, -1.0); }
    case 1u: { corner = vec2<f32>(-1.0,  1.0); }
    case 2u: { corner = vec2<f32>( 1.0, -1.0); }
    default: { corner = vec2<f32>( 1.0,  1.0); }
  }

  let proj = loadMat(0u);
  let view = loadMat(1u);
  let viewPos = view * vec4<f32>(world, 1.0);
  let clip = proj * viewPos;

  // Viewport and size parameters packed at U.m[8]: (width, height, sizeScale, invLogMax)
  let vp = U.m[8u];
  let width = vp.x; let height = vp.y; let sizeScale = vp.z; let invLogMax = vp.w;
  // Depth-scaled size similar to nbody3
  let baseSize = max(1.0, pow(max(mass, 0.0), 0.3333));
  let sizePx = max(2.0, sizeScale * baseSize / max(1.0, -viewPos.z));

  // Convert pixel offset to clip-space offset (pre-divide), account for clip.w
  let offsetClip = vec2<f32>(
    2.0 * corner.x * sizePx / max(1.0, width),
   -2.0 * corner.y * sizePx / max(1.0, height)
  ) * clip.w;

  // Mass normalization for color like nbody3
  let mNorm = clamp(log(1.0 + max(mass, 0.0)) * invLogMax, 0.0, 1.0);

  var out: VSOut;
  out.pos = vec4<f32>(clip.xy + offsetClip, clip.z, clip.w);
  out.uv = corner; // pass to fragment for circular mask
  out.radiate = pos4.w;
  out.massNorm = mNorm;
  return out;
}

@fragment
fn fs(in: VSOut) -> @location(0) vec4<f32> {
  let r = length(in.uv);
  if (r > 1.0) { discard; }
  // Soft edge alpha
  let alpha = clamp((1.0 - r) / 0.3, 0.0, 1.0);
  // Radiative coloring like nbody3: red from radiate, green/blue from mass
  let redRadiate = clamp(5.0 * in.radiate, 0.0, 1.0);
  let g = in.massNorm;
  let b = 1.0 - in.massNorm;
  return vec4<f32>(redRadiate, g, b, alpha);
}
`;

    // WGSL for a simple O(N^2) Verlet integrator
    const integrateWGSL = `
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Damp { factor: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
struct Repulse { k: f32, _r0: f32, _r1: f32, _r2: f32 }
struct Rad { c: f32, _r0: f32, _r1: f32, _r2: f32 }
struct Spin { w: f32, _s0: f32, _s1: f32, _s2: f32 }

@group(0) @binding(0) var<storage, read> posIn: Vec4Buf;
@group(0) @binding(1) var<storage, read> prevPosIn: Vec4Buf;
@group(0) @binding(2) var<storage, read_write> posOut: Vec4Buf;
@group(0) @binding(3) var<storage, read_write> prevPosOut: Vec4Buf;
@group(0) @binding(4) var<uniform> P: SimParams;
@group(0) @binding(5) var<storage, read> M: FloatBuf;
@group(0) @binding(6) var<uniform> D: Damp;
@group(0) @binding(7) var<uniform> Rp: Repulse;
@group(0) @binding(8) var<uniform> Rd: Rad;
@group(0) @binding(9) var<uniform> Sp: Spin;

const WG: u32 = ${WG_SIZE}u;
var<workgroup> tPos: array<vec4<f32>, WG>;
var<workgroup> tMass: array<f32, WG>;

@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = gid.x;
  let n = u32(P.numParticlesF);
  let isActive = i < n;
  let eps2 = P.eps * P.eps;

  var p = vec3<f32>(0.0);
  var p_prev = vec3<f32>(0.0);
  var mi: f32 = 0.0;
  if (isActive) {
    p = posIn.data[i].xyz;
    p_prev = prevPosIn.data[i].xyz;
    mi = M.data[i];
  }

  var a = vec3<f32>(0.0);

  if (isActive && mi > 0.0) {
    var base: u32 = 0u;
    loop {
      if (base >= n) { break; }
      let j_tile = base + lid.x;
      if (j_tile < n) {
        tPos[lid.x] = posIn.data[j_tile];
        tMass[lid.x] = M.data[j_tile];
      } else {
        tPos[lid.x] = vec4<f32>(0.0);
        tMass[lid.x] = 0.0;
      }
      workgroupBarrier();

      let remain = n - base;
      var count: u32 = min(remain, WG);

      for (var k: u32 = 0u; k < count; k = k + 1u) {
        let j_global = base + k;
        if (j_global != i) {
            let m = tMass[k];
            if (m > 0.0) {
                let d = tPos[k].xyz - p;
                let r2 = dot(d,d) + eps2;
                let invR = inverseSqrt(r2);
                let invR2 = invR * invR;
                let invR6 = invR2 * invR2 * invR2;
                let dir = d * invR;
                let aG = (P.G * m) * invR2;
                let aR = (Rp.k * m) * invR6;
                a = a + dir * (aG - aR);
            }
        }
      }
      workgroupBarrier();
      base = base + WG;
    }
  }

  if (isActive) {
    if (mi > 0.0) {
        let dt2 = P.dt * P.dt;
        var p_new = p + (p - p_prev) * D.factor + a * dt2;

        if (abs(Sp.w) > 0.0) {
            let posXZ = p.xz;
            if (dot(posXZ, posXZ) > 0.0) {
                let tang = normalize(vec3<f32>(-posXZ.y, 0.0, posXZ.x));
                p_new = p_new + tang * (Sp.w * dt2);
            }
        }

        posOut.data[i] = vec4<f32>(p_new, 0.0);
        prevPosOut.data[i] = vec4<f32>(p, 0.0);
    } else {
        posOut.data[i] = posIn.data[i];
        prevPosOut.data[i] = prevPosIn.data[i];
    }
  }
}
`;

    // WGSL for rendering debug lines between pairs
    const linesWGSL = `
struct VSOut { @builtin(position) pos: vec4f, @location(0) col: vec4f };
struct Vec4Buf { data: array<vec4f>, };
struct Mats { m: array<vec4f, 10>, };
struct PairCount { count: u32, }

@group(0) @binding(0) var<storage, read> posBuf: Vec4Buf;
@group(0) @binding(1) var<storage, read> pairBuf: array<vec4u>;
@group(0) @binding(2) var<uniform> U: Mats;
@group(0) @binding(3) var<storage, read> pc: PairCount;

fn loadMat(idx: u32) -> mat4x4<f32> {
  let b = idx * 4u;
  return mat4x4<f32>(U.m[b+0u], U.m[b+1u], U.m[b+2u], U.m[b+3u]);
}

@vertex
fn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VSOut {
  var o: VSOut;
  if (iid >= pc.count) {
    o.pos = vec4f(2.0, 2.0, 2.0, 1.0); // off-screen
    o.col = vec4f(0.0);
    return o;
  }

  let pair = pairBuf[iid];
  let p_idx = select(pair.x, pair.y, (vid % 2u) == 1u);
  let P = posBuf.data[p_idx].xyz;

  let proj = loadMat(0u);
  let view = loadMat(1u);
  o.pos = proj * view * vec4f(P, 1.0);
  o.col = vec4f(0.3, 0.3, 0.3, 0.5); // Dim gray for pairs
  return o;
}

@fragment
fn fs(inp: VSOut) -> @location(0) vec4f {
  return inp.col;
}
`;

    // Uniforms
    // SimParams is 4 floats (16 bytes): dt, G, eps, num
    const simParams = new Float32Array([dt, G, 1.0, particleCount]); // eps defaults to 1.0
    const simParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSimParams(){ device.queue.writeBuffer(simParamsBuf, 0, simParams.buffer, simParams.byteOffset, simParams.byteLength); }
    writeSimParams();

    // New: repulsion (R) uniform
    const repulseParams = new Float32Array([R, 0,0,0]);
    const repulseBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRepulse(){ repulseParams[0]=R; device.queue.writeBuffer(repulseBuf, 0, repulseParams); }
    writeRepulse();

    // New: radiative damping uniform
    const radParams = new Float32Array([radiativeDamping, 0,0,0]);
    const radBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRad(){ radParams[0]=radiativeDamping; device.queue.writeBuffer(radBuf, 0, radParams); }
    writeRad();

    // Add spin and damping uniforms + writers so UI callbacks have functions to call
    const spinParams = new Float32Array([spin, 0, 0, 0]);
    const spinBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSpin() { spinParams[0] = spin; device.queue.writeBuffer(spinBuf, 0, spinParams); }
    writeSpin();

    const dampParams = new Float32Array([damping, 0, 0, 0]);
    const dampBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeDamp() { dampParams[0] = damping; device.queue.writeBuffer(dampBuf, 0, dampParams); }
    writeDamp();

    // create bind-group placeholders; actual bind-groups use matsBuf which is guaranteed to exist later
    let boxesBG_A;
    let boxesBG_B;

    // Expose pipeline variables in outer scope so frame() can use them
    let renderPipe, renderBG_posA, renderBG_posB;
    let linesPipe, linesBG_posA, linesBG_posB, integratePipe, integrateBG_AtoB, integrateBG_BtoA;

    // Precompute all unique pairs (i<j) once
    const allPairs = new Uint32Array(MAX_PAIRS * 4);
    let pIdx = 0;
    for (let i=0; i<particleCount; i++) {
      for (let j=i+1; j<particleCount; j++) {
        const o = pIdx * 4;
        allPairs[o+0] = i;
        allPairs[o+1] = j;
        allPairs[o+2] = 0;
        allPairs[o+3] = 0;
        pIdx++;
      }
    }
    device.queue.writeBuffer(visPairBuf, 0, allPairs);
    device.queue.writeBuffer(outPairCount, 0, new Uint32Array([pIdx]));

    // Frame loop
    // Track which buffer currently contains the up-to-date particle positions.
    // posIsA === true -> posA holds current positions; false -> posB holds current positions.
    let posIsA = true;
    let lastT = performance.now();

    // Simulation control state
    let paused = false;
    let stepRequested = false;
    const startStopBtn = document.getElementById('startStop');
    const stepBtn = document.getElementById('step');
    startStopBtn.addEventListener('click', () => {
      paused = !paused;
      startStopBtn.textContent = paused ? 'Start' : 'Pause';
    });
    stepBtn.addEventListener('click', () => {
      // Ensure we're paused before stepping; request a single step
      if (!paused) { paused = true; startStopBtn.textContent = 'Start'; }
      stepRequested = true;
    });

    async function frame() {
      const now = performance.now();
      const dtMs = now - lastT; lastT = now;
      writeMats();
      simParams[0] = dt; simParams[1] = G; simParams[2] = simParams[2]; simParams[3] = particleCount; // eps unchanged
      writeSimParams();
      writeRepulse();
      writeRad();

      const enc = device.createCommandEncoder();

      // Integrate (simple O(N^2))
      {
        if (!integratePipe) {
          const integrateModule = device.createShaderModule({ code: integrateWGSL });
          integratePipe = device.createComputePipeline({
            layout: 'auto',
            compute: { module: integrateModule, entryPoint: 'main' }
          });
          integrateBG_AtoB = device.createBindGroup({
            layout: integratePipe.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: posA } }, { binding: 1, resource: { buffer: prevPosA } },
              { binding: 2, resource: { buffer: posB } }, { binding: 3, resource: { buffer: prevPosB } },
              { binding: 4, resource: { buffer: simParamsBuf } }, { binding: 5, resource: { buffer: masses } },
              { binding: 6, resource: { buffer: dampBuf } }, { binding: 7, resource: { buffer: repulseBuf } },
              { binding: 8, resource: { buffer: radBuf } }, { binding: 9, resource: { buffer: spinBuf } },
            ]
          });
          integrateBG_BtoA = device.createBindGroup({
            layout: integratePipe.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: posB } }, { binding: 1, resource: { buffer: prevPosB } },
              { binding: 2, resource: { buffer: posA } }, { binding: 3, resource: { buffer: prevPosA } },
              { binding: 4, resource: { buffer: simParamsBuf } }, { binding: 5, resource: { buffer: masses } },
              { binding: 6, resource: { buffer: dampBuf } }, { binding: 7, resource: { buffer: repulseBuf } },
              { binding: 8, resource: { buffer: radBuf } }, { binding: 9, resource: { buffer: spinBuf } },
            ]
          });
        }

        if ((!paused || stepRequested) && typeof integratePipe !== 'undefined' && typeof integrateBG_AtoB !== 'undefined') {
          const p = enc.beginComputePass();
          p.setPipeline(integratePipe);
          p.setBindGroup(0, posIsA ? integrateBG_AtoB : integrateBG_BtoA);
          p.dispatchWorkgroups(Math.ceil(particleCount / WG_SIZE));
          p.end();
          posIsA = !posIsA;
        }
      }

      // CPU-side position update for overlay (only when paused)
      // This is needed because the GPU state is not read back to the CPU every frame.
      // The overlay needs fresh data to draw correctly.
      if (paused && !stepRequested) {
        // This is a simplified rotation, same as the original cpuAnimate.
        // It ensures the overlay continues to move when the GPU is paused.
        // In a real scenario, you might read back the GPU state instead.
      } else {
        // When running, copy the GPU-computed positions to the CPU array for the overlay.
        enc.copyBufferToBuffer(posIsA ? posA : posB, 0, posReadback, 0, stateBytes);
      }

      // Compute bucket AABBs from the just-written position buffer
      {
        const rp = enc.beginComputePass();
        rp.setPipeline(reducePipe);
        // Use the buffer that currently holds the up-to-date positions (posIsA)
        rp.setBindGroup(0, posIsA ? reduceBG_A : reduceBG_B);
        rp.dispatchWorkgroups(bucketCount);
        rp.end();
      }

      // Render points + lines
      {
        // Ensure boxes bind-groups exist (matsBuf is ready after writeMats())
        if (!boxesBG_A) {
          boxesBG_A = device.createBindGroup({ layout: boxesPipe.getBindGroupLayout(0), entries: [
            { binding: 0, resource: { buffer: nodeBuf } },
            { binding: 1, resource: { buffer: matsBuf } },
          ]});
          boxesBG_B = device.createBindGroup({ layout: boxesPipe.getBindGroupLayout(0), entries: [
            { binding: 0, resource: { buffer: nodeBuf } },
            { binding: 1, resource: { buffer: matsBuf } },
          ]});
        }

        // Ensure lines pipeline and bind-groups exist
        if (!linesPipe) {
          const linesModule = device.createShaderModule({ code: linesWGSL });
          linesPipe = device.createRenderPipeline({
            layout: 'auto',
            vertex: { module: linesModule, entryPoint: 'vs' },
            fragment: { module: linesModule, entryPoint: 'fs', targets: [{ format, blend: {
              color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
              alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
            } }] },
            primitive: { topology: 'line-list' }
          });
          linesBG_posA = device.createBindGroup({
            layout: linesPipe.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: posA } },
              { binding: 1, resource: { buffer: visPairBuf } },
              { binding: 2, resource: { buffer: matsBuf } },
              { binding: 3, resource: { buffer: outPairCount } },
            ]});
          linesBG_posB = device.createBindGroup({
            layout: linesPipe.getBindGroupLayout(0),
            entries: [
              { binding: 0, resource: { buffer: posB } },
              { binding: 1, resource: { buffer: visPairBuf } },
              { binding: 2, resource: { buffer: matsBuf } },
              { binding: 3, resource: { buffer: outPairCount } },
            ]});
        }

        const viewTex = context.getCurrentTexture().createView();
        const rp = enc.beginRenderPass({ colorAttachments: [{ view: viewTex, clearValue: {r:0.0,g:0.0,b:0.0,a:1}, loadOp: 'clear', storeOp: 'store' }] });

        // Optional: draw sprites if render pipeline exists
        if (typeof renderPipe !== 'undefined' && typeof renderBG_posA !== 'undefined') {
          rp.setPipeline(renderPipe);
          rp.setBindGroup(0, posIsA ? renderBG_posA : renderBG_posB);
          rp.draw(4, particleCount);
        }

        // Optional: draw debug pairs if lines pipeline exists
        if (typeof linesPipe !== 'undefined' && typeof linesBG_posA !== 'undefined') {
          rp.setPipeline(linesPipe);
          rp.setBindGroup(0, posIsA ? linesBG_posA : linesBG_posB);
          rp.draw(2, MAX_PAIRS);
        }

        // Draw bucket boxes (12 edges -> 24 vertices per instance) -- boxesPipe is present
        rp.setPipeline(boxesPipe);
        rp.setBindGroup(0, posIsA ? boxesBG_A : boxesBG_B);
        rp.draw(24, bucketCount);

        rp.end();
      }

      device.queue.submit([enc.finish()]);

      // If we performed a single step, clear the request so subsequent frames remain paused
      if (stepRequested) stepRequested = false;

      // Draw CPU-side debug overlay of initial particle positions to confirm projection/camera
      (function drawCpuOverlay(){
        octx.clearRect(0,0,overlay.width,overlay.height);
        octx.fillStyle = 'rgba(255,200,0,0.9)';
        function mulMat4Vec4(m, v){
          return [ m[0]*v[0] + m[4]*v[1] + m[8]*v[2] + m[12]*v[3], m[1]*v[0] + m[5]*v[1] + m[9]*v[2] + m[13]*v[3], m[2]*v[0] + m[6]*v[1] + m[10]*v[2] + m[14]*v[3], m[3]*v[0] + m[7]*v[1] + m[11]*v[2] + m[15]*v[3] ];
        }
        // This readback is slow and just for debugging the overlay.
        posReadback.mapAsync(GPUMapMode.READ).then(() => {
          const data = new Float32Array(posReadback.getMappedRange());
          for (let i=0;i<particleCount;i++){
            const o = i*stride;
            const P = [ data[o], data[o+1], data[o+2], 1.0 ];
            const v1 = mulMat4Vec4(view, P);
            const v2 = mulMat4Vec4(proj, v1);
            if (v2[3] === 0) continue;
            const ndcX = v2[0]/v2[3];
            const ndcY = v2[1]/v2[3];
            const sx = (ndcX * 0.5 + 0.5) * overlay.width;
            const sy = (1.0 - (ndcY * 0.5 + 0.5)) * overlay.height;
            octx.beginPath(); octx.arc(sx, sy, 3, 0, Math.PI*2); octx.fill();
          }
          posReadback.unmap();
        }).catch(e => {
          // This can fail if the page is reloaded; ignore.
        });
      })();

      statsDiv.textContent = `fps: ${(1000/Math.max(1, dtMs)).toFixed(0)}  particles: ${particleCount}  pairs: ${MAX_PAIRS}  buckets: ${bucketCount}  posIsA: ${posIsA}${paused ? '  [PAUSED]' : ''}`;
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
