<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>WebGPU N-Body (merge + split) – nbody5</title>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; overflow: hidden; background: #000; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #ui { position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.6); color: #fff; font-family: system-ui, sans-serif; padding: 10px; font-size: 12px; }
    #ui label { display:block; margin: 6px 0 2px; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="ui">
    <div><b>Controls</b></div>
    <label>G: <span id="gVal">0.30</span></label>
    <input id="g" type="range" min="0.01" max="5.0" step="0.01" value="0.30" />

    <label>dt: <span id="dtVal">0.20</span></label>
    <input id="dt" type="range" min="0.01" max="1.00" step="0.01" value="0.20" />

    <label>Restitution (alpha): <span id="restVal">1.00</span></label>
    <input id="rest" type="range" min="0.0" max="1.0" step="0.01" value="1.00" />

    <!-- New: Radius factor slider -->
    <label>Radius factor: <span id="rfVal">2</span></label>
    <input id="rf" type="range" min="1" max="100" step="1" value="2" />

    <!-- New: Repulsion (R) slider -->
    <label>Repulsion R: <span id="repVal">10</span></label>
    <input id="rep" type="range" min="0" max="100" step="1" value="10" />

    <!-- New: Spin and Damping sliders -->
    <label>Spin: <span id="spinVal">0.00</span></label>
    <input id="spin" type="range" min="-2.0" max="2.0" step="0.01" value="0.00" />

    <label>Damping: <span id="dampVal">1.00</span></label>
    <input id="damp" type="range" min="0.0" max="1.0" step="0.001" value="1.00" />

    <!-- New: Radiative damping -->
    <label>Radiative: <span id="radVal">0.005</span></label>
    <input id="rad" type="range" min="0.0" max="0.1" step="0.001" value="0.005" />

    <div id="stats" style="margin-top:6px; opacity: 0.85;"></div>
  </div>

  <script>
  "use strict";
  (async () => {
    const canvas = document.getElementById('c');
    const statsDiv = document.getElementById('stats');
    if (!('gpu' in navigator)) { alert('WebGPU not supported'); return; }

    const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' }) || await navigator.gpu.requestAdapter();
    if (!adapter) { alert('No GPU adapter'); return; }
    const device = await adapter.requestDevice();
    const context = canvas.getContext('webgpu');
    const format = navigator.gpu.getPreferredCanvasFormat();

    function resize() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(canvas.clientWidth * dpr);
      canvas.height = Math.floor(canvas.clientHeight * dpr);
      context.configure({ device, format, alphaMode: 'opaque' });
    }
    resize();
    addEventListener('resize', resize);

    // Simple parameters/UI
    let G = 0.30;
    let dt = 0.20;
    let restitution = 1.00; // used as alpha in energy restitution
    let radiusFactor = 2.0; // new: scales collision radii
    let R = 10.0;           // new: short-range repulsion strength (like nbody3)
    let spin = 0.00;        // new: tangential velocity injection rate (rad/s)
    let damping = 1.00;     // CHANGED: damping factor (0..1), applied directly to velocity (1.0 = no damping)
    let radiativeDamping = 0.005; // new: radiative damping coefficient

    const gEl = document.getElementById('g');
    const gVal = document.getElementById('gVal');
    gEl.addEventListener('input', () => { G = parseFloat(gEl.value); gVal.textContent = G.toFixed(2); writeSimParams(); });
    const dtEl = document.getElementById('dt');
    const dtVal = document.getElementById('dtVal');
    dtEl.addEventListener('input', () => { dt = parseFloat(dtEl.value); dtVal.textContent = dt.toFixed(2); writeSimParams(); });
    const restEl = document.getElementById('rest');
    const restVal = document.getElementById('restVal');
    restEl.addEventListener('input', () => { restitution = parseFloat(restEl.value); restVal.textContent = restitution.toFixed(2); writeRest(); });

    // New: radius factor UI wiring
    const rfEl = document.getElementById('rf');
    const rfVal = document.getElementById('rfVal');
    rfEl.addEventListener('input', () => { radiusFactor = parseFloat(rfEl.value); rfVal.textContent = String(rfEl.value); writeRadius(); });

    // New: repulsion UI wiring
    const repEl = document.getElementById('rep');
    const repVal = document.getElementById('repVal');
    repEl.addEventListener('input', () => { R = parseFloat(repEl.value); repVal.textContent = String(repEl.value); writeRepulse(); });

    // New: spin + damping UI wiring
    const spinEl = document.getElementById('spin');
    const spinVal = document.getElementById('spinVal');
    spinEl.addEventListener('input', () => { spin = parseFloat(spinEl.value); spinVal.textContent = spin.toFixed(2); writeSpin(); });
    const dampEl = document.getElementById('damp');
    const dampVal = document.getElementById('dampVal');
    dampEl.addEventListener('input', () => { damping = parseFloat(dampEl.value); dampVal.textContent = damping.toFixed(3); writeDamp(); });

    // New: radiative damping UI wiring
    const radEl = document.getElementById('rad');
    const radVal = document.getElementById('radVal');
    radEl.addEventListener('input', () => { radiativeDamping = parseFloat(radEl.value); radVal.textContent = radiativeDamping.toFixed(3); writeRad(); });

    // Basic math helpers (column-major matrices like WebGPU expects)
    function perspective(fovy, aspect, near, far) {
      const f = 1.0 / Math.tan(fovy / 2);
      const nf = 1 / (near - far);
      return new Float32Array([
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * far * near) * nf, 0
      ]);
    }
    function normalize(a) { const l = Math.hypot(a[0],a[1],a[2]) || 1; return [a[0]/l, a[1]/l, a[2]/l]; }
    function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
    function dot(a, b) { return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
    function lookAt(eye, center, up) {
      const f = normalize([center[0]-eye[0], center[1]-eye[1], center[2]-eye[2]]);
      const s = normalize(cross(f, up));
      const u = cross(s, f);
      return new Float32Array([
        s[0], u[0], -f[0], 0,
        s[1], u[1], -f[1], 0,
        s[2], u[2], -f[2], 0,
        - (s[0]*eye[0] + s[1]*eye[1] + s[2]*eye[2]),
        - (u[0]*eye[0] + u[1]*eye[1] + u[2]*eye[2]),
        (f[0]*eye[0] + f[1]*eye[1] + f[2]*eye[2]),
        1
      ]);
    }

    // Orbit camera (simple)
    let az = 0.3, el = 0.6, dist = 2000.0;
    function updateView() {
      const ce = Math.cos(el), se = Math.sin(el), sa = Math.sin(az), ca = Math.cos(az);
      const eye = [ dist * ce * sa, dist * se, dist * ce * ca ];
      view = lookAt(eye, [0,0,0], [0,1,0]);
    }
    (function orbitControls(){
      let drag=false, lx=0, ly=0;
      canvas.addEventListener('mousedown', (e)=>{ if(e.button===0){ drag=true; lx=e.clientX; ly=e.clientY; }});
      addEventListener('mouseup', ()=> drag=false);
      addEventListener('mousemove', (e)=>{
        if(!drag) return; const dx=e.clientX-lx, dy=e.clientY-ly; lx=e.clientX; ly=e.clientY;
        az += dx * 0.005; el += dy * 0.005;
        const minEl = -Math.PI/2 + 0.01;
        const maxEl =  Math.PI/2 - 0.01;
        el = Math.max(minEl, Math.min(maxEl, el));
      });
      canvas.addEventListener('wheel', (e)=>{ e.preventDefault(); dist *= Math.exp(e.deltaY * 0.001); dist = Math.max(10, Math.min(1e6, dist)); }, {passive:false});
    })();

    // Simulation setup (simple random sphere)
    const particleCount = 20000; // keep moderate (O(N^2) pair find)
    const stride = 4; // vec4
    const stateBytes = particleCount * stride * 4;

    function makeBuf(size, usage) { return device.createBuffer({ size, usage }); }
    function bufFrom(arr, usage) {
      const b = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
      new Float32Array(b.getMappedRange()).set(arr);
      b.unmap(); return b;
    }

    const posInit = new Float32Array(particleCount * stride);
    const velInit = new Float32Array(particleCount * stride);
    const massInit = new Float32Array(particleCount);
    const rad = 800.0;
    for (let i=0;i<particleCount;i++){
      let x,y,z; do { x=(Math.random()*2-1)*rad; y=(Math.random()*2-1)*rad; z=(Math.random()*2-1)*rad; } while (x*x+y*y+z*z>rad*rad);
      const o=i*stride; posInit[o]=x; posInit[o+1]=y; posInit[o+2]=z; posInit[o+3]=0;
      velInit[o]=0; velInit[o+1]=0; velInit[o+2]=0; velInit[o+3]=0;
      massInit[i]=1.0; // start uniform
    }
    let posA = bufFrom(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
    let posB = makeBuf(stateBytes, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
    let velA = bufFrom(velInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
    let velB = makeBuf(stateBytes, GPUBufferUsage.STORAGE);
    const masses = bufFrom(massInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);

    // Collision pair buffers (very simple)
    const MAX_PAIRS = Math.min(particleCount * 8, 262144);
    const pairBuf = device.createBuffer({ size: MAX_PAIRS * 16, usage: GPUBufferUsage.STORAGE }); // vec4<u32>
    const pairCount = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const locks = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    const claims = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
    // new: per-pair energy buffer (ΔE at detection time)
    const pairEnergy = device.createBuffer({ size: MAX_PAIRS * 4, usage: GPUBufferUsage.STORAGE });

    // Uniforms
    // SimParams is 4 floats (16 bytes): dt, G, eps, num
    const simParams = new Float32Array([dt, G, 1.0, particleCount]); // eps defaults to 1.0
    const simParamsBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSimParams(){ device.queue.writeBuffer(simParamsBuf, 0, simParams.buffer, simParams.byteOffset, simParams.byteLength); }
    writeSimParams();

    const restParams = new Float32Array([restitution, 0,0,0]);
    const restBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRest(){ restParams[0]=restitution; device.queue.writeBuffer(restBuf, 0, restParams); }
    writeRest();

    // New: collision radius factor uniform
    const radiusParams = new Float32Array([radiusFactor, 0,0,0]);
    const radiusBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRadius(){ radiusParams[0]=radiusFactor; device.queue.writeBuffer(radiusBuf, 0, radiusParams); }
    writeRadius();

    // New: damping uniform
    const dampParams = new Float32Array([damping, 0,0,0]);
    const dampBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeDamp(){ dampParams[0]=damping; device.queue.writeBuffer(dampBuf, 0, dampParams); }
    writeDamp();

    // New: spin uniform
    const spinParams = new Float32Array([spin, 0,0,0]);
    const spinBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeSpin(){ spinParams[0]=spin; device.queue.writeBuffer(spinBuf, 0, spinParams); }
    writeSpin();

    // New: repulsion (R) uniform
    const repulseParams = new Float32Array([R, 0,0,0]);
    const repulseBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRepulse(){ repulseParams[0]=R; device.queue.writeBuffer(repulseBuf, 0, repulseParams); }
    writeRepulse();

    // New: radiative damping uniform
    const radParams = new Float32Array([radiativeDamping, 0,0,0]);
    const radBuf = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeRad(){ radParams[0]=radiativeDamping; device.queue.writeBuffer(radBuf, 0, radParams); }
    writeRad();

    // Matrices + viewport params in a 10-vec4 uniform for alignment
    let proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1e7);
    let view = lookAt([0, 0, dist], [0,0,0], [0,1,0]);
    const mats = new Float32Array(40); // 10 * vec4
    const matsBuf = device.createBuffer({ size: mats.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
    function writeMats() {
      proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 1e7);
      updateView();
      mats.set(proj, 0);
      mats.set(view, 16);
      mats[32] = canvas.width;  // viewport W
      mats[33] = canvas.height; // viewport H
      mats[34] = 18.0;          // sprite sizeScale in pixels (smaller)
      mats[35] = Math.log(1.0 + 8.0); // normalization helper (not used strictly)
      device.queue.writeBuffer(matsBuf, 0, mats);
    }
    writeMats();

    // WGSL Shaders
    const integrateWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Damp { factor: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
struct Repulse { k: f32, _r0: f32, _r1: f32, _r2: f32 }
struct Rad { c: f32, _r0: f32, _r1: f32, _r2: f32 } // new radiative coefficient
@group(0) @binding(0) var<storage, read> posIn: Vec4Buf;
@group(0) @binding(1) var<storage, read> velIn: Vec4Buf;
@group(0) @binding(2) var<storage, read_write> posOut: Vec4Buf;
@group(0) @binding(3) var<storage, read_write> velOut: Vec4Buf;
@group(0) @binding(4) var<uniform> P: SimParams;
@group(0) @binding(5) var<storage, read> M: FloatBuf;
@group(0) @binding(6) var<uniform> D: Damp;
@group(0) @binding(7) var<uniform> Rp: Repulse; // new repulsion coefficient
@group(0) @binding(8) var<uniform> Rd: Rad;     // new radiative damping

const WG: u32 = 256u;
var<workgroup> tPos: array<vec4<f32>, WG>;
var<workgroup> tVel: array<vec4<f32>, WG>;   // new: neighbor velocities
var<workgroup> tMass: array<f32, WG>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = gid.x;
  let n = u32(P.numParticlesF);
  let isActive = i < n;
  let eps2 = P.eps * P.eps;
  var p = vec3<f32>(0.0);
  var v = vec3<f32>(0.0);
  var mi: f32 = 0.0;
  if (isActive) {
    p = posIn.data[i].xyz;
    v = velIn.data[i].xyz;
    mi = M.data[i];
  }
  var a = vec3<f32>(0.0);
  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }
    let j = base + lid.x;
    if (j < n) {
      tPos[lid.x] = posIn.data[j];
      tVel[lid.x] = velIn.data[j]; // load neighbor velocity
      tMass[lid.x] = M.data[j];
    } else {
      tPos[lid.x] = vec4<f32>(0.0);
      tVel[lid.x] = vec4<f32>(0.0);
      tMass[lid.x] = 0.0;
    }
    workgroupBarrier();
    let remain = n - base;
    var count: u32 = WG;
    if (remain < WG) { count = remain; }
    if (isActive && mi > 0.0) {
      var k: u32 = 0u;
      loop {
        if (k >= count) { break; }
        let m = tMass[k];
        if (m > 0.0) {
          let d = tPos[k].xyz - p;
          let r2 = dot(d,d) + eps2;
          let invR = inverseSqrt(r2);
          let invR2 = invR * invR;
          let invR4 = invR2 * invR2;
          let dir = d * invR;
          // gravity (1/r^2) minus short-range repulsion (1/r^4)
          let aG = (P.G * m) * invR2;
          let aR = (Rp.k * m) * invR4;
          var aRad: f32 = 0.0;
          // Apply radiative damping when repulsion ~ attraction (gate: aR >= aG)
          if (aR >= aG) {
            let vj = tVel[k].xyz;
            let closingSpeed = dot(d, v - vj);
            aRad = Rd.c * closingSpeed * invR; // acceleration magnitude along dir
          }
          let aMag = aG - aR - aRad;
          a = a + dir * aMag;
        }
        k = k + 1u;
      }
    }
    workgroupBarrier();
    base = base + WG;
  }
  if (isActive) {
    v = v + a * P.dt;
    // apply multiplicative damping like nbody3 (direct factor 0..1)
    v = v * D.factor;
    p = p + v * P.dt;
    posOut.data[i] = vec4<f32>(p, 0.0);
    velOut.data[i] = vec4<f32>(v, 0.0);
  }
}
`;

    const detectPairsWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct PairCount { value: atomic<u32>, }
struct Pairs { data: array<vec4<u32>>, }
struct FloatBuf1 { data: array<f32>, }
struct Coll { rf: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read> Pvel: Vec4Buf;
@group(0) @binding(2) var<storage, read> M: FloatBuf;
@group(0) @binding(3) var<uniform> S: SimParams;
@group(0) @binding(4) var<storage, read_write> pc: PairCount;
@group(0) @binding(5) var<storage, read_write> pb: Pairs;
@group(0) @binding(6) var<storage, read_write> PE: FloatBuf1; // per-pair ΔE
@group(0) @binding(7) var<uniform> C: Coll;                  // collision radius factor

const WG: u32 = 256u;
var<workgroup> tPos: array<vec4<f32>, WG>;
var<workgroup> tVel: array<vec4<f32>, WG>;
var<workgroup> tMass: array<f32, WG>;

fn encodeNormal(n: vec3<f32>) -> vec2<u32> {
  let nx = clamp(n.x * 32767.0, -32767.0, 32767.0);
  let ny = clamp(n.y * 32767.0, -32767.0, 32767.0);
  let p0 = (u32(i32(nx) & 0xFFFF) | (u32(i32(ny) & 0xFFFF) << 16));
  let p1 = select(0u, 1u, n.z < 0.0);
  return vec2<u32>(p0, p1);
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = gid.x;
  let n = u32(S.numParticlesF);
  let isActive = i < n;
  var mi: f32 = 0.0;
  if (isActive) { mi = M.data[i]; }
  let alive = isActive && (mi > 0.0);
  var pi = vec3<f32>(0.0);
  var vi = vec3<f32>(0.0);
  if (alive) { pi = Ppos.data[i].xyz; vi = Pvel.data[i].xyz; }

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }
    let jg = base + lid.x;
    if (jg < n) {
      tPos[lid.x] = Ppos.data[jg];
      tVel[lid.x] = Pvel.data[jg];
      tMass[lid.x] = M.data[jg];
    } else {
      tPos[lid.x] = vec4<f32>(0.0);
      tVel[lid.x] = vec4<f32>(0.0);
      tMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remain = n - base;
    var count: u32 = WG;
    if (remain < WG) { count = remain; }
    if (alive) {
      var k: u32 = 0u;
      loop {
        if (k >= count) { break; }
        let j = base + k;
        if (j > i) {
          let mj = tMass[k];
          if (mj > 0.0) {
            let dp = tPos[k].xyz - pi;
            let d2 = dot(dp, dp);
            let rf = max(C.rf, 0.0);
            let ri = rf * max(1.0, pow(mi, 0.3333));
            let rj = rf * max(1.0, pow(mj, 0.3333));
            let R = ri + rj;
            if (d2 < R*R) {
              let relv = tVel[k].xyz - vi;
              if (dot(dp, relv) < 0.0) {
                let len2 = max(d2, 1e-12);
                let invL = inverseSqrt(len2);
                let nhat = dp * invL;
                let packed = encodeNormal(nhat);
                let idx = atomicAdd(&pc.value, 1u);
                if (idx < ${MAX_PAIRS}u) {
                  pb.data[idx] = vec4<u32>(i, j, packed.x, packed.y);
                  // store bond energy ΔE from start-of-step velocities
                  let dv = vi - tVel[k].xyz;
                  let m12 = mi + mj;
                  let dE = (mi * mj / (2.0 * m12)) * dot(dv, dv);
                  PE.data[idx] = dE;
                }
              }
            }
          }
        }
        k = k + 1u;
      }
    }

    workgroupBarrier();
    base = base + WG;
  }
}
`;

    const splitWGSL = /* wgsl */`
struct PairCount { value: atomic<u32>, }
struct Pairs { data: array<vec4<u32>>, }
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Rest { e: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
struct Locks { data: array<atomic<u32>>, }
struct Claims { data: array<atomic<u32>>, }

@group(0) @binding(0) var<storage, read_write> V: Vec4Buf; // velocities (post-integration)
@group(0) @binding(1) var<storage, read> M: FloatBuf;      // masses
@group(0) @binding(2) var<storage, read_write> pc: PairCount; // pair count (atomic)
@group(0) @binding(3) var<storage, read> pb: Pairs;        // pairs list
@group(0) @binding(4) var<uniform> R: Rest;               // alpha (energy restitution)
@group(0) @binding(5) var<storage, read_write> L: Locks;  // locks
@group(0) @binding(6) var<storage, read_write> C: Claims; // claims per particle (to avoid multiple splits)

fn decodeNormal(packed: vec2<u32>) -> vec3<f32> {
  let xb = packed.x & 0xFFFFu;
  let yb = (packed.x >> 16u) & 0xFFFFu;
  let xs = select(i32(xb), i32(xb) - 65536, (xb & 0x8000u) != 0u);
  let ys = select(i32(yb), i32(yb) - 65536, (yb & 0x8000u) != 0u);
  let x = f32(xs) / 32767.0;
  let y = f32(ys) / 32767.0;
  var z = sqrt(max(0.0, 1.0 - x*x - y*y));
  if (packed.y != 0u) { z = -z; }
  return normalize(vec3<f32>(x, y, z));
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let k = gid.x;
  let total = atomicLoad(&pc.value);
  if (k >= total) { return; }

  let rec = pb.data[k];
  let i = rec.x; let j = rec.y;
  if (i == j) { return; }

  // Acquire locks in index order to avoid deadlocks
  let a = min(i, j);
  let b = max(i, j);
  let la = atomicCompareExchangeWeak(&L.data[a], 0u, 1u);
  if (!la.exchanged) { return; }
  let lb = atomicCompareExchangeWeak(&L.data[b], 0u, 1u);
  if (!lb.exchanged) { atomicStore(&L.data[a], 0u); return; }

  // Ensure each particle participates in at most one split per frame
  let ca = atomicCompareExchangeWeak(&C.data[i], 0u, 1u);
  if (!ca.exchanged) { atomicStore(&L.data[b], 0u); atomicStore(&L.data[a], 0u); return; }
  let cb = atomicCompareExchangeWeak(&C.data[j], 0u, 1u);
  if (!cb.exchanged) {
    atomicStore(&C.data[i], 0u);
    atomicStore(&L.data[b], 0u);
    atomicStore(&L.data[a], 0u);
    return;
  }

  let mi = M.data[i];
  let mj = M.data[j];
  if (mi <= 0.0 || mj <= 0.0) {
    // release
    atomicStore(&L.data[b], 0u);
    atomicStore(&L.data[a], 0u);
    return;
  }

  var vi = V.data[i].xyz; // post-integration velocities
  var vj = V.data[j].xyz;
  let n = decodeNormal(vec2<u32>(rec.z, rec.w));

  let m12 = mi + mj;
  if (m12 <= 0.0) {
    atomicStore(&L.data[b], 0u);
    atomicStore(&L.data[a], 0u);
    return;
  }
  let v12p = (mi * vi + mj * vj) / m12; // COM velocity after integration

  // Angular-momentum-preserving split: keep tangential component, reverse normal component (with restitution)
  let alpha = clamp(R.e, 0.0, 1.0);           // coefficient of restitution along normal
  let vrel = vj - vi;                         // relative velocity after integration
  let vn_mag = dot(vrel, n);                  // normal component magnitude
  let vn = vn_mag * n;                        // normal component vector
  let vt = vrel - vn;                         // tangential component
  // Only flip normal if approaching (vn_mag < 0). Otherwise keep it (already separating)
  let vn_mag_new = select(vn_mag, -alpha * vn_mag, vn_mag < 0.0);
  let vrel_new = vt + vn_mag_new * n;

  // Reconstruct individual velocities from COM and relative velocity
  vi = v12p - (mj / m12) * vrel_new;
  vj = v12p + (mi / m12) * vrel_new;
  V.data[i] = vec4<f32>(vi, 0.0);
  V.data[j] = vec4<f32>(vj, 0.0);

  // release locks
  atomicStore(&L.data[b], 0u);
  atomicStore(&L.data[a], 0u);
}
`;

    // New: spin injection shader
    const spinWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, eps: f32, numParticlesF: f32 }
struct Vec4Buf { data: array<vec4<f32>>, }
struct Spin { w: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read_write> V: Vec4Buf;
@group(0) @binding(2) var<uniform> P: SimParams;
@group(0) @binding(3) var<uniform> S: Spin;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let i = gid.x;
  let n = u32(P.numParticlesF);
  if (i >= n) { return; }
  let w = S.w;
  if (abs(w) <= 0.0) { return; }
  let p = Ppos.data[i].xyz;
  var v = V.data[i].xyz;
  // Match nbody3: spin around Y axis (tangent in XZ plane), normalized in XZ
  let posXZ = p.xz;
  let len2 = dot(posXZ, posXZ);
  if (len2 > 0.0) {
    let invLen = inverseSqrt(len2);
    let tang2 = vec2<f32>(-posXZ.y, posXZ.x) * invLen;
    let tang = vec3<f32>(tang2.x, 0.0, tang2.y);
    v = v + (w * P.dt) * tang;
  }
  V.data[i] = vec4<f32>(v, 0.0);
}
`;

    const renderWGSL = /* wgsl */`
struct Vec4Buf { data: array<vec4<f32>>, }
struct FloatBuf { data: array<f32>, }
struct Mats { m: array<vec4<f32>, 10>, }
@group(0) @binding(0) var<storage, read> Ppos: Vec4Buf;
@group(0) @binding(1) var<storage, read> M: FloatBuf;
@group(0) @binding(2) var<uniform> U: Mats;

struct VSOut { @builtin(position) pos: vec4<f32>, @location(0) uv: vec2<f32>, @location(1) col: vec3<f32>, };

fn loadMat(idx: u32) -> mat4x4<f32> {
  let b = idx * 4u;
  return mat4x4<f32>(U.m[b+0u], U.m[b+1u], U.m[b+2u], U.m[b+3u]);
}

@vertex
fn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VSOut {
  // Per-instance particle index
  let world = Ppos.data[iid].xyz;
  let mass = M.data[iid];

  // Cull dead particles (mass <= 0)
  if (mass <= 0.0) {
    var out: VSOut;
    out.pos = vec4<f32>(2.0, 2.0, 1.0, 1.0);
    out.uv = vec2<f32>(2.0);
    out.col = vec3<f32>(0.0);
    return out;
  }

  // Corner in NDC pixel space: (-1,-1), (-1,1), (1,-1), (1,1)
  var corner: vec2<f32>;
  switch (vid & 3u) {
    case 0u: { corner = vec2<f32>(-1.0, -1.0); }
    case 1u: { corner = vec2<f32>(-1.0,  1.0); }
    case 2u: { corner = vec2<f32>( 1.0, -1.0); }
    default: { corner = vec2<f32>( 1.0,  1.0); }
  }

  let proj = loadMat(0u);
  let view = loadMat(1u);
  let viewPos = view * vec4<f32>(world, 1.0);
  let clip = proj * viewPos;

  // Viewport and size parameters packed at U.m[8]: (width, height, sizeScale, _)
  let vp = U.m[8u];
  let width = vp.x; let height = vp.y; let sizeScale = vp.z;
  // Depth-scaled size similar to nbody3
  let baseSize = max(1.0, pow(max(mass, 0.0), 0.3333));
  let sizePx = max(2.0, sizeScale * baseSize / max(1.0, -viewPos.z));

  // Convert pixel offset to clip-space offset (pre-divide), account for clip.w
  let offsetClip = vec2<f32>(
    2.0 * corner.x * sizePx / max(1.0, width),
   -2.0 * corner.y * sizePx / max(1.0, height)
  ) * clip.w;

  var out: VSOut;
  out.pos = vec4<f32>(clip.xy + offsetClip, clip.z, clip.w);
  out.uv = corner; // pass to fragment for circular mask
  let t = clamp(mass / 8.0, 0.0, 1.0);
  let c0 = vec3<f32>(0.2,0.6,1.0);
  let c1 = vec3<f32>(1.0,0.8,0.2);
  out.col = c0 * (1.0 - t) + c1 * t;
  return out;
}

@fragment
fn fs(in: VSOut) -> @location(0) vec4<f32> {
  let r = length(in.uv);
  if (r > 1.0) { discard; }
  // Soft edge alpha
  let alpha = clamp((1.0 - r) / 0.3, 0.0, 1.0);
  return vec4<f32>(in.col, alpha);
}
`;

    // Pipelines (compute + render)
    const integrateModule = device.createShaderModule({ code: integrateWGSL });
    const integratePipe = device.createComputePipeline({ layout: 'auto', compute: { module: integrateModule, entryPoint: 'main' } });
    const detectModule = device.createShaderModule({ code: detectPairsWGSL });
    const detectPipe = device.createComputePipeline({ layout: 'auto', compute: { module: detectModule, entryPoint: 'main' } });
    const splitModule = device.createShaderModule({ code: splitWGSL });
    const splitPipe = device.createComputePipeline({ layout: 'auto', compute: { module: splitModule, entryPoint: 'main' } });
    // New: spin pipeline
    const spinModule = device.createShaderModule({ code: spinWGSL });
    const spinPipe = device.createComputePipeline({ layout: 'auto', compute: { module: spinModule, entryPoint: 'main' } });

    const renderModule = device.createShaderModule({ code: renderWGSL });
    const renderPipe = device.createRenderPipeline({
      layout: 'auto',
      vertex: { module: renderModule, entryPoint: 'vs' },
      fragment: { module: renderModule, entryPoint: 'fs', targets: [{ format, blend: { color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' }, alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' } } }] },
      primitive: { topology: 'triangle-strip', cullMode: 'none' }
    });

    // Compute bind groups
    const integrateBG_AtoB = device.createBindGroup({ layout: integratePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: posB } },
      { binding: 3, resource: { buffer: velB } },
      { binding: 4, resource: { buffer: simParamsBuf } },
      { binding: 5, resource: { buffer: masses } },
      { binding: 6, resource: { buffer: dampBuf } },
      { binding: 7, resource: { buffer: repulseBuf } }, // new
      { binding: 8, resource: { buffer: radBuf } },     // new radiative
    ]});
    const integrateBG_BtoA = device.createBindGroup({ layout: integratePipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: posA } },
      { binding: 3, resource: { buffer: velA } },
      { binding: 4, resource: { buffer: simParamsBuf } },
      { binding: 5, resource: { buffer: masses } },
      { binding: 6, resource: { buffer: dampBuf } },
      { binding: 7, resource: { buffer: repulseBuf } }, // new
      { binding: 8, resource: { buffer: radBuf } },     // new radiative
    ]});

    const detectBG_posA = device.createBindGroup({ layout: detectPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: pairEnergy } },
      { binding: 7, resource: { buffer: radiusBuf } },
    ]});
    const detectBG_posB = device.createBindGroup({ layout: detectPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: masses } },
      { binding: 3, resource: { buffer: simParamsBuf } },
      { binding: 4, resource: { buffer: pairCount } },
      { binding: 5, resource: { buffer: pairBuf } },
      { binding: 6, resource: { buffer: pairEnergy } },
      { binding: 7, resource: { buffer: radiusBuf } },
    ]});

    const splitBG_velA = device.createBindGroup({ layout: splitPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: velA } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: pairCount } },
      { binding: 3, resource: { buffer: pairBuf } },
      { binding: 4, resource: { buffer: restBuf } },
      { binding: 5, resource: { buffer: locks } },
      { binding: 6, resource: { buffer: claims } },
    ]});
    const splitBG_velB = device.createBindGroup({ layout: splitPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: velB } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: pairCount } },
      { binding: 3, resource: { buffer: pairBuf } },
      { binding: 4, resource: { buffer: restBuf } },
      { binding: 5, resource: { buffer: locks } },
      { binding: 6, resource: { buffer: claims } },
    ]});

    const renderBG_posA = device.createBindGroup({ layout: renderPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: matsBuf } },
    ]});
    const renderBG_posB = device.createBindGroup({ layout: renderPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: masses } },
      { binding: 2, resource: { buffer: matsBuf } },
    ]});

    // New: spin bind groups
    const spinBG_posA = device.createBindGroup({ layout: spinPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posA } },
      { binding: 1, resource: { buffer: velA } },
      { binding: 2, resource: { buffer: simParamsBuf } },
      { binding: 3, resource: { buffer: spinBuf } },
    ]});
    const spinBG_posB = device.createBindGroup({ layout: spinPipe.getBindGroupLayout(0), entries: [
      { binding: 0, resource: { buffer: posB } },
      { binding: 1, resource: { buffer: velB } },
      { binding: 2, resource: { buffer: simParamsBuf } },
      { binding: 3, resource: { buffer: spinBuf } },
    ]});

    // Frame loop
    let readFromA = true;
    let lastT = performance.now();
    let frameCount = 0;
    function frame() {
      const now = performance.now();
      const dtMs = now - lastT; lastT = now;
      writeMats();
      simParams[0] = dt; simParams[1] = G; simParams[2] = 1.0; simParams[3] = particleCount; // eps = 1.0
      writeSimParams();
      writeRepulse(); // ensure R updates
      writeRad();     // ensure radiative damping updates

      // Force spin = 1.0 for first 10 frames, then use UI-controlled value
      if (frameCount < 10) {
        spinParams[0] = 1.0;
        device.queue.writeBuffer(spinBuf, 0, spinParams);
      } else {
        writeSpin();
      }

      const enc = device.createCommandEncoder();

      // Reset pair data and per-frame locks/claims
      device.queue.writeBuffer(pairCount, 0, new Uint32Array([0]));
      device.queue.writeBuffer(locks, 0, new Uint32Array(particleCount));
      device.queue.writeBuffer(claims, 0, new Uint32Array(particleCount));

      // New: Apply spin injection to current velocity buffer
      {
        const p = enc.beginComputePass();
        p.setPipeline(spinPipe);
        p.setBindGroup(0, readFromA ? spinBG_posA : spinBG_posB);
        p.dispatchWorkgroups(Math.ceil(particleCount / 256));
        p.end();
      }

      // 1) Detect pairs at start-of-step (pre-integration) and store ΔE, normals
      {
        const p = enc.beginComputePass();
        p.setPipeline(detectPipe);
        p.setBindGroup(0, readFromA ? detectBG_posA : detectBG_posB);
        p.dispatchWorkgroups(Math.ceil(particleCount / 256));
        p.end();
      }

      // 2) Integrate all particles
      {
        const p = enc.beginComputePass();
        p.setPipeline(integratePipe);
        p.setBindGroup(0, readFromA ? integrateBG_AtoB : integrateBG_BtoA);
        p.dispatchWorkgroups(Math.ceil(particleCount / 256));
        p.end();
        readFromA = !readFromA;
      }

      // 3) Split: redistribute α·ΔE along bond normals to separate
      {
        const p = enc.beginComputePass();
        p.setPipeline(splitPipe);
        p.setBindGroup(0, readFromA ? splitBG_velA : splitBG_velB);
        // run enough workgroups to cover max pairs capacity, kernel early-outs by actual count
        p.dispatchWorkgroups(Math.ceil(MAX_PAIRS / 256));
        p.end();
      }

      // Render
      {
        const viewTex = context.getCurrentTexture().createView();
        const rp = enc.beginRenderPass({ colorAttachments: [{ view: viewTex, clearValue: {r:0,g:0,b:0,a:1}, loadOp: 'clear', storeOp: 'store' }] });
        // Draw particles as instanced camera-facing quads
        rp.setPipeline(renderPipe);
        rp.setBindGroup(0, readFromA ? renderBG_posA : renderBG_posB);
        rp.draw(4, particleCount);
        rp.end();
      }

      device.queue.submit([enc.finish()]);

      frameCount++;
      statsDiv.textContent = `fps: ${(1000/Math.max(1, dtMs)).toFixed(0)}  particles: ${particleCount}`;
      requestAnimationFrame(frame);
    }
    requestAnimationFrame(frame);
  })();
  </script>
</body>
</html>
