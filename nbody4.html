<!DOCTYPE html>
<!--
  Copyright (c) 2025 Jason Nyberg
  Licensed under the GPL 3.0 License
  See LICENSE for details
-->
<html>

<head>
    <meta charset="UTF-8">
    <title>3D N-Body Simulation – WebGPU</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #debug { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; font-family: monospace; padding: 10px; max-height: 90vh; overflow-y: auto; font-size: 12px; }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div id="debug"></div>
    <div style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="gSlider">G: <span id="gValue">0.2</span></label><br>
        <input type="range" id="gSlider" min="0.01" max="5.0" step="0.01" value="0.3">
    </div>
    <div style="position: fixed; top: 60px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="dampingSlider">Damping: <span id="dampingValue">1.0</span></label><br>
        <input type="range" id="dampingSlider" min="0.0" max="1.0" step="0.01" value="1.0">
    </div>
    <div style="position: fixed; top: 110px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="spinSlider">Spin: <span id="spinValue">0.0</span></label><br>
        <input type="range" id="spinSlider" min="-1.0" max="1.0" step="0.01" value="0.0">
    </div>
    <div style="position: fixed; top: 160px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="radiateSlider">Radiative: <span id="radiateValue">0.005</span></label><br>
        <input type="range" id="radiateSlider" min="0.0" max="0.1" step="0.001" value="0.005">
    </div>
    <div style="position: fixed; top: 210px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="fusionSlider">Fusion: <span id="fusionValue">0.01</span></label><br>
        <input type="range" id="fusionSlider" min="0.01" max="5.00" step="0.01" value="0.01">
    </div>
    <div style="position: fixed; top: 260px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="timestepSlider">Timestep: <span id="timestepValue">0.2</span></label><br>
        <input type="range" id="timestepSlider" min="0.01" max="1.0" step="0.01" value="0.2">
    </div>
    <!-- New: Fusion energy/decay controls -->
    <div style="position: fixed; top: 310px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="boostSlider">Fusion Boost: <span id="boostValue">2.0</span></label><br>
        <input type="range" id="boostSlider" min="1.0" max="5.0" step="0.1" value="2.0">
    </div>
    <div style="position: fixed; top: 360px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="decaySlider">Decay Half-life: <span id="decayValue">1.0</span></label><br>
        <input type="range" id="decaySlider" min="0.05" max="10.0" step="0.05" value="1.0">
    </div>
    <div style="position: fixed; top: 410px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="fuseProbSlider">Fusion Probability: <span id="fuseProbValue">1.00</span></label><br>
        <input type="range" id="fuseProbSlider" min="0.0" max="1.0" step="0.01" value="1.0">
    </div>
    <div style="position: fixed; top: 460px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label><input type="checkbox" id="mergeSplitToggle"> Merge/Split</label><br>
        <label for="restSlider">Restitution: <span id="restValue">0.50</span></label><br>
        <input type="range" id="restSlider" min="0" max="1" step="0.01" value="0.5">
    </div>

    <script type="text/javascript">
    "use strict";

    (async () => {
        const canvas = document.getElementById("glcanvas");
        const debugDiv = document.getElementById('debug');

        if (!('gpu' in navigator)) {
            alert('WebGPU not supported in this browser.');
            return;
        }

        const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' })
            || await navigator.gpu.requestAdapter();
        if (!adapter) { alert('Failed to get GPU adapter'); return; }
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();

        function resizeCanvas() {
            //const dpr = 1; // force DPR=1 for performance; set to window.devicePixelRatio for full res
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = Math.floor(canvas.clientWidth * dpr);
            canvas.height = Math.floor(canvas.clientHeight * dpr);
            context.configure({ device, format, alphaMode: 'opaque' });
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ---- Simulation Parameters ----
        const NUM_PARTICLES = 256*100; // must be multiple of 100 per original
        let G = 0.3;
        const R = 10000.0;
        let spin = 0.03;
        const EPS = 0.001;
        let damping = 0.9;
        const stride = 4; // vec4 per particle
        const radius = 1000.0;
        const cam_dist = 1000.0;
        // Removed SUBSTEPS; single-step per frame
        let radiateCoeff = 0.005; // radiative damping coefficient
        // base timestep per frame
        let baseDt = 0.2;   // timestep per frame; slider controls this directly
        let loopCount = 0;
        const startTime = performance.now();
        let lastFrameMs = 0;
        // Fusion parameters
        const FUSE_RADIUS = 3.0; // distance threshold for fusion (simulation units)
        const FUSE_MIN_REL_SPEED = 0.1; // minimum relative speed to be considered a "smash"
        let fusionFactor = 0.01; // user-controlled fusion ease factor (higher = easier to fuse)
        // New: defaults for fusion energy emission/decay controls
        let fusionBoost = 2.0;     // default boost factor applied on fusion
        let decayHalfLife = 1.0;   // seconds; half-life for repulsion decay
        let fusionProb = 1.0; // probability (0..1) applied to each qualified fusion event

        // Merge/Split Phase1 constants & state (placeholder, particleCount defined later)
        let mergeSplitEnabled = false;
        let restitutionAlpha = 0.5;
        let MAX_PAIRS = 0; // will set after particleCount known

        // Pair / collision buffers
        // Pair struct 32 bytes (a,u32)(b,u32)(nx,ny,nz,pad => 16 bytes) + padding
        const pairStructSize = 32;
        // Pair buffers will be created after particleCount defined
        let pairBuffer; let pairCountBuffer; let lockBuffer;

        // Readback for pairCount (triple-buffer pattern unnecessary; single staging ok)
        let pairCountReadback;

        // UI wiring
        const gSlider = document.getElementById('gSlider');
        const gValueDisplay = document.getElementById('gValue');
        gSlider.addEventListener('input', (e) => { G = parseFloat(e.target.value); gValueDisplay.textContent = G.toFixed(2); writeSimParams(); });
        const dampingSlider = document.getElementById('dampingSlider');
        const dampingValueDisplay = document.getElementById('dampingValue');
        dampingSlider.addEventListener('input', (e) => { damping = parseFloat(e.target.value); dampingValueDisplay.textContent = damping.toFixed(2); writeSimParams(); });
        const spinSlider = document.getElementById('spinSlider');
        const spinValueDisplay = document.getElementById('spinValue');
        spinSlider.addEventListener('input', (e) => { spin = parseFloat(e.target.value); spinValueDisplay.textContent = spin.toFixed(2); writeSimParams(); });
        const radiateSlider = document.getElementById('radiateSlider');
        const radiateValueDisplay = document.getElementById('radiateValue');
        radiateSlider.addEventListener('input', (e) => { radiateCoeff = parseFloat(e.target.value); radiateValueDisplay.textContent = radiateCoeff.toFixed(3); writeSimParams(); });
        const fusionSlider = document.getElementById('fusionSlider');
        const fusionValueDisplay = document.getElementById('fusionValue');
        fusionSlider.addEventListener('input', (e) => { fusionFactor = parseFloat(e.target.value); fusionValueDisplay.textContent = fusionFactor.toFixed(2); writeFusionParams(); });
        const timestepSlider = document.getElementById('timestepSlider');
        const timestepValueDisplay = document.getElementById('timestepValue');
        timestepSlider.addEventListener('input', (e) => {
            baseDt = parseFloat(e.target.value);
            timestepValueDisplay.textContent = baseDt.toFixed(2);
        });
        // New: fusion boost slider
        const boostSlider = document.getElementById('boostSlider');
        const boostValueDisplay = document.getElementById('boostValue');
        boostSlider.addEventListener('input', (e) => {
            fusionBoost = Math.max(1.0, parseFloat(e.target.value));
            boostValueDisplay.textContent = fusionBoost.toFixed(1);
        });
        // New: decay half-life slider
        const decaySlider = document.getElementById('decaySlider');
        const decayValueDisplay = document.getElementById('decayValue');
        decaySlider.addEventListener('input', (e) => {
            decayHalfLife = Math.max(0.001, parseFloat(e.target.value));
            decayValueDisplay.textContent = decayHalfLife.toFixed(2);
        });
        // New: fusion probability slider
        const fuseProbSlider = document.getElementById('fuseProbSlider');
        const fuseProbValue = document.getElementById('fuseProbValue');
        fuseProbSlider.addEventListener('input', (e) => {
            fusionProb = Math.min(1.0, Math.max(0.0, parseFloat(e.target.value)));
            fuseProbValue.textContent = fusionProb.toFixed(2);
            writeFusionParams();
        });
        // Merge/Split UI
        const mergeSplitToggle = document.getElementById('mergeSplitToggle');
        const restSlider = document.getElementById('restSlider');
        const restValue = document.getElementById('restValue');
        mergeSplitToggle.addEventListener('change', ()=> { mergeSplitEnabled = mergeSplitToggle.checked; });
        restSlider.addEventListener('input', (e)=> { restitutionAlpha = parseFloat(e.target.value); restValue.textContent = restitutionAlpha.toFixed(2); writeRestitution(); });

        // Ensure initial values are reflected in UI at startup (uniforms are written later after buffers are created)
        gSlider.value = G.toFixed(2);
        gValueDisplay.textContent = G.toFixed(2);
        fusionSlider.value = fusionFactor.toFixed(2);
        fusionValueDisplay.textContent = fusionFactor.toFixed(2);
        timestepSlider.value = baseDt.toFixed(2);
        timestepValueDisplay.textContent = baseDt.toFixed(2);
        // Initialize remaining sliders to current values
        dampingSlider.value = damping.toFixed(2);
        dampingValueDisplay.textContent = damping.toFixed(2);
        spinSlider.value = spin.toFixed(2);
        spinValueDisplay.textContent = spin.toFixed(2);
        radiateSlider.value = radiateCoeff.toFixed(3);
        radiateValueDisplay.textContent = radiateCoeff.toFixed(3);
        // Removed: substeps UI init
        // New: initialize emission UI
        boostSlider.value = fusionBoost.toFixed(1);
        boostValueDisplay.textContent = fusionBoost.toFixed(1);
        decaySlider.value = decayHalfLife.toFixed(2);
        decayValueDisplay.textContent = decayHalfLife.toFixed(2);
        // New: initialize probability UI
        fuseProbSlider.value = fusionProb.toFixed(2);
        fuseProbValue.textContent = fusionProb.toFixed(2);
        // New: initialize restitution UI
        restSlider.value = restitutionAlpha.toFixed(2);
        restValue.textContent = restitutionAlpha.toFixed(2);

        // ---- Helpers ----
        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, (2 * far * near) * nf, 0
            ]);
        }
        function lookAt(eye, center, up) {
            const f = normalize(subtract(center, eye));
            const s = normalize(cross(f, up));
            const u = cross(s, f);
            return new Float32Array([
                s[0], u[0], -f[0], 0,
                s[1], u[1], -f[1], 0,
                s[2], u[2], -f[2], 0,
                -dot(s, eye), -dot(u, eye), dot(f, eye), 1
            ]);
        }
        function subtract(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function normalize(v) { const l = Math.hypot(v[0], v[1], v[2]); return [v[0]/l, v[1]/l, v[2]/l]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }

        let projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000000);
        // Orbit camera state (around origin)
        let orbitAz = 0.0;          // azimuth angle (radians)
        let orbitEl = 0.6;          // elevation angle (radians)
        let orbitDist = cam_dist;   // distance from origin
        let viewMatrix = lookAt([0, orbitDist * Math.cos(orbitEl), orbitDist], [0,0,0], [0,1,0]);
        function updateViewMatrix() {
            const minEl = -Math.PI/2 + 0.01;
            const maxEl =  Math.PI/2 - 0.01;
            if (orbitEl < minEl) orbitEl = minEl;
            if (orbitEl > maxEl) orbitEl = maxEl;
            const r = Math.max(1.0, orbitDist);
            const ce = Math.cos(orbitEl); const se = Math.sin(orbitEl);
            const sa = Math.sin(orbitAz); const ca = Math.cos(orbitAz);
            const eye = [ r * ce * sa, r * se, r * ce * ca ];
            viewMatrix = lookAt(eye, [0,0,0], [0,1,0]);
        }
        // Mouse orbit controls
        (function initOrbitControls() {
            let dragging = false; let lastX = 0; let lastY = 0;
            canvas.addEventListener('mousedown', (e) => { if (e.button === 0) { dragging = true; lastX = e.clientX; lastY = e.clientY; } });
            window.addEventListener('mouseup', () => { dragging = false; });
            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                const dx = e.clientX - lastX; const dy = e.clientY - lastY;
                lastX = e.clientX; lastY = e.clientY;
                const rotSpeed = 0.005;
                orbitAz += dx * rotSpeed;
                orbitEl += dy * rotSpeed; // inverted Y
            });
            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = Math.exp(e.deltaY * 0.001);
                orbitDist *= zoomFactor;
                orbitDist = Math.min(Math.max(orbitDist, 10.0), 1e7);
            }, { passive: false });
        })();

        // ---- GPU Buffers (positions/velocities ping-pong) ----
        const particleCount = NUM_PARTICLES;
        // Helper buffer creators (reintroduced after refactor)
        function createBufferFromArray(arr, usage) {
            const buffer = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
            new Float32Array(buffer.getMappedRange()).set(arr);
            buffer.unmap();
            return buffer;
        }
        function createEmptyBuffer(size, usage) {
            return device.createBuffer({ size, usage });
        }
        const stateByteSize = particleCount * stride * 4; // 4 bytes per float * vec4 stride
        // Now finalize MAX_PAIRS and allocate buffers
        MAX_PAIRS = Math.min(particleCount * 8, 262144);
        pairBuffer = device.createBuffer({ size: MAX_PAIRS * pairStructSize, usage: GPUBufferUsage.STORAGE });
        pairCountBuffer = device.createBuffer({ size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });
        lockBuffer = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        pairCountReadback = device.createBuffer({ size: 4, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ });

        // Initialize CPU-side state
        const posInit = new Float32Array(particleCount * stride);
        const velInit = new Float32Array(particleCount * stride);
        for (let i = 0; i < particleCount; i++) {
            const ti = i * stride;
            let x, y, z;
            do {
                x = (Math.random() - 0.5) * 2 * radius;
                y = (Math.random() - 0.5) * 2 * radius;
                z = (Math.random() - 0.5) * 2 * radius;
            } while (x*x + y*y + z*z > radius*radius);
            posInit[ti+0] = x; posInit[ti+1] = y; posInit[ti+2] = z; posInit[ti+3] = 0.0; // radiate accumulator
            velInit[ti+0] = 0.0; velInit[ti+1] = 0.0; velInit[ti+2] = 0.0; velInit[ti+3] = 0.0;
        }

        let posA = createBufferFromArray(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        let posB = createEmptyBuffer(stateByteSize, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
        let velA = createBufferFromArray(velInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        let velB = createEmptyBuffer(stateByteSize, GPUBufferUsage.STORAGE);

        // ---- Mass Buffer ----
        // Initialize all particle masses to 1.0 (uniform masses)
        const massesInit = new Float32Array(particleCount);
        massesInit.fill(1.0);
        const maxMass = 1.0;
        const massSum = particleCount * 1.0;
        const avgMass = 1.0;
        const massBuffer = createBufferFromArray(massesInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        // Fusion claims buffer (atomic flags) and params
        const claimsBuffer = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        const zeroClaims = new Uint32Array(particleCount); // reused each frame to clear claims
        // FusionParams: radius, minRelSpeed, fusionFactor, probability
        const fusionParamsData = new Float32Array([FUSE_RADIUS, FUSE_MIN_REL_SPEED, fusionFactor, fusionProb]);
        const fusionParamsBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeFusionParams() {
            fusionParamsData[0] = FUSE_RADIUS;
            fusionParamsData[1] = FUSE_MIN_REL_SPEED;
            fusionParamsData[2] = fusionFactor;
            fusionParamsData[3] = fusionProb;
            device.queue.writeBuffer(fusionParamsBuffer, 0, fusionParamsData.buffer, fusionParamsData.byteOffset, fusionParamsData.byteLength);
        }
        writeFusionParams();
        // New: per-frame fuse flags for flash visualization
        const fuseFlagsBuffer = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        const zeroFuseFlags = new Float32Array(particleCount);
        // New: per-particle extra repulsion factors (>= 1.0); boosted on fusion and decays each physics pass
        const repulseInit = new Float32Array(particleCount); repulseInit.fill(1.0);
        const repulseBuffer = createBufferFromArray(repulseInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        // New: emission params uniform (boost, decayFactor)
        const emissionParamsData = new Float32Array([fusionBoost, 1.0, 0.0, 0.0]);
        const emissionParamsBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        // New: dynamic mass stats (active count and max mass) computed on GPU each frame
        const totalMass = massSum;
        let dynActiveCount = particleCount;
        let dynMaxMass = maxMass;
        const statsBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });
        // Triple-buffer readback to avoid mapped-buffer hazards
        const NUM_READBACK = 3;
        const statsReadBuffers = Array.from({ length: NUM_READBACK }, () =>
            device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST })
        );
        const statsPendingMap = new Array(NUM_READBACK).fill(false);
        let statsWriteIndex = 0;     // next preferred write target
        let lastCopiedIndex = -1;    // index written last frame (to read this frame)
        let copiedThisFrameIndex = -1; // track stats buffer copied this frame
        const zeroStats = new Uint32Array([0,0,0,0]);

        // ---- Uniform Buffers ----
        // Sim params: [dt, G, R, spin, eps, damping, numParticlesF, radiateCoeff]
        const simParamsData = new Float32Array([baseDt, G, R, spin, EPS, damping, particleCount, radiateCoeff]);
        const simParamsBuffer = device.createBuffer({ size: simParamsData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeSimParams() {
            simParamsData[0] = baseDt;     // dt per frame
            simParamsData[1] = G;          // G
            simParamsData[2] = R;          // R
            simParamsData[3] = spin;       // spin per frame (no substep scaling)
            simParamsData[4] = EPS;
            simParamsData[5] = damping;    // damping per frame
            simParamsData[6] = particleCount;
            simParamsData[7] = radiateCoeff;
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData.buffer, simParamsData.byteOffset, simParamsData.byteLength);
        }
        writeSimParams();

        // Matrices uniform: projection(16) + view(16) + params vec4 (viewportW, viewportH, sizeScale, invLogMax)
        // We allocate 10 vec4 (160 bytes = 40 floats) for alignment/padding though only 9 are used (indices 0..8)
        const matricesData = new Float32Array(40); // 10 * vec4
        function writeMatrices() {
            matricesData.set(projMatrix, 0);      // 0..15
            matricesData.set(viewMatrix, 16);     // 16..31
            matricesData[32] = canvas.width;      // param vec4 (index 8 vec4)
            matricesData[33] = canvas.height;
            matricesData[34] = 200.0;            // size scale (reduced from 5000 to make points visible)
            const maxForNorm = Math.min(Math.max(8.0, dynMaxMass), 1e4);
            const invLogMax = 1.0 / Math.log(1.0 + maxForNorm);
            matricesData[35] = invLogMax;         // remaining of param vec4
            // 36..39 remain as padding / unused
            device.queue.writeBuffer(matricesBuffer, 0, matricesData.buffer, matricesData.byteOffset, matricesData.byteLength);
        }
        const matricesBuffer = device.createBuffer({ size: matricesData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        writeMatrices();

        // Restitution uniform (for merge/split impulse resolution) + writer
        const restitutionData = new Float32Array([restitutionAlpha, 0, 0, 0]);
        const restitutionUniform = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeRestitution() {
            restitutionData[0] = restitutionAlpha;
            device.queue.writeBuffer(restitutionUniform, 0, restitutionData.buffer, restitutionData.byteOffset, restitutionData.byteLength);
        }
        writeRestitution();

        // Shared WGSL constants (used in injected WGSL strings below)
        const WG_SIZE = 256; // workgroup size for compute passes
        const TILE_SIZE = WG_SIZE;

        // Center-of-mass buffers and pipelines
        const numComPartials = Math.ceil(particleCount / WG_SIZE);
        const comPartialsBuffer = device.createBuffer({ size: numComPartials * 16, usage: GPUBufferUsage.STORAGE });
        const comBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE });
        const smoothComBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        // Initialize smoothed COM to origin
        device.queue.writeBuffer(smoothComBuffer, 0, new Float32Array([0, 0, 0, 1]));

        const comReduce1WGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
struct Partials { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read_write> partials: Partials;
@group(0) @binding(2) var<uniform> params: SimParams;
@group(0) @binding(3) var<storage, read> masses: FloatBuffer;
@group(0) @binding(4) var<storage, read> anchor: Single; // smoothed COM as anchor for numerical stability
const WG: u32 = ${WG_SIZE}u;
var<workgroup> s: array<vec4<f32>, WG>; // xyz = sum(m*(pos-anchor)), w = sum(m)
@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = wid.x * WG + lid.x;
  let n = u32(params.numParticlesF);
  let a = anchor.data.xyz;
  var accum = vec4<f32>(0.0);
  if (i < n) {
    let p = positions.data[i].xyz - a;
    let m = masses.data[i];
    accum = vec4<f32>(p * m, m);
  }
  s[lid.x] = accum;
  workgroupBarrier();
  var stride: u32 = WG / 2u;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) { s[lid.x] = s[lid.x] + s[lid.x + stride]; }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) { partials.data[wid.x] = s[0u]; }
}
`;
        const comReduce2WGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Partials { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> partials: Partials;
@group(0) @binding(1) var<storage, read_write> comOut: Single;
@group(0) @binding(2) var<uniform> params: SimParams;
@group(0) @binding(3) var<storage, read> anchor: Single; // same anchor as pass 1
const WG: u32 = ${WG_SIZE}u;
var<workgroup> s: array<vec4<f32>, WG>; // xyz = sum(m*(pos-anchor)), w = sum(m)
@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(local_invocation_id) lid: vec3<u32>) {
  let n = u32(params.numParticlesF);
  let numPartials = (n + WG - 1u) / WG;
  var sum = vec4<f32>(0.0);
  var j = lid.x;
  loop {
    if (j >= numPartials) { break; }
    sum = sum + partials.data[j];
    j = j + WG;
  }
  s[lid.x] = sum;
  workgroupBarrier();
  var stride: u32 = WG / 2;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) { s[lid.x] = s[lid.x] + s[lid.x + stride]; }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) {
    let a = anchor.data.xyz;
    let totalM = s[0u].w;
    let invM = select(0.0, 1.0 / totalM, totalM > 0.0);
    let com = a + s[0u].xyz * invM;
    comOut.data = vec4<f32>(com, totalM);
  }
}
`;
        const comReduce1Module = device.createShaderModule({ code: comReduce1WGSL });
        const comReduce1Pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comReduce1Module, entryPoint: 'main' } });
        const comReduce2Module = device.createShaderModule({ code: comReduce2WGSL });
        const comReduce2Pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comReduce2Module, entryPoint: 'main' } });

        // Bind groups for COM reduction (per position buffer)
        const comReduce1BG_A = device.createBindGroup({
            layout: comReduce1Pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: comPartialsBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
                { binding: 3, resource: { buffer: massBuffer } },
                { binding: 4, resource: { buffer: smoothComBuffer } },
            ],
        });
        const comReduce1BG_B = device.createBindGroup({
            layout: comReduce1Pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: comPartialsBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
                { binding: 3, resource: { buffer: massBuffer } },
                { binding: 4, resource: { buffer: smoothComBuffer } },
            ],
        });

        const comReduce2BG = device.createBindGroup({
            layout: comReduce2Pipeline.getBindGroupLayout(0),
            entries:
            [
                { binding: 0, resource: { buffer: comPartialsBuffer } },
                { binding: 1, resource: { buffer: comBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
                { binding: 3, resource: { buffer: smoothComBuffer } },
            ]
        });

        // Smooth COM (exponential smoothing once per frame)
        const comSmoothWGSL = /* wgsl */`
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> comIn: Single;
@group(0) @binding(1) var<storage, read_write> smoothOut: Single;
@compute @workgroup_size(1)
fn main() {
  let c = comIn.data.xyz;
  let s0 = smoothOut.data.xyz;
  let d = length(c - s0);
  // Adaptive smoothing: when far from target, increase alpha toward 1 to quickly catch up;
  // when close, keep alpha ~0.1 to avoid jitter. k controls transition scale.
  let k: f32 = 10000.0;
  let alpha: f32 = clamp(0.10 + 0.90 * (d / (d + k)), 0.10, 1.0);
  let s1 = s0 + (c - s0) * alpha;
  smoothOut.data = vec4<f32>(s1, 1.0);
}
`;
        const comSmoothModule = device.createShaderModule({ code: comSmoothWGSL });
        const comSmoothPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comSmoothModule, entryPoint: 'main' } });
        const comSmoothBG = device.createBindGroup({
            layout: comSmoothPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: comBuffer } },
                { binding: 1, resource: { buffer: smoothComBuffer } },
            ]
        });

        // ---- Shaders (WGSL) ----
        const computeWGSL = /* wgsl */`
struct SimParams {
  dt: f32,
  G: f32,
  R: f32,
  spin: f32,
  eps: f32,
  damping: f32,
  numParticlesF: f32,
  radiateCoeff: f32,
}

struct Vec4Buffer { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
struct FloatBuffer { data: array<f32>, }
struct EmissionParams { boost: f32, decayFactor: f32, _pad0: f32, _pad1: f32 }

@group(0) @binding(0) var<storage, read> posIn: Vec4Buffer;
@group(0) @binding(1) var<storage, read> velIn: Vec4Buffer;
@group(0) @binding(2) var<storage, read_write> posOut: Vec4Buffer;
@group(0) @binding(3) var<storage, read_write> velOut: Vec4Buffer;
@group(0) @binding(4) var<uniform> params: SimParams;
@group(0) @binding(5) var<storage, read> comIn: Single;
@group(0) @binding(6) var<storage, read> masses: FloatBuffer;
@group(0) @binding(7) var<storage, read_write> repulse: FloatBuffer; // extra repulsion factor per particle
@group(0) @binding(8) var<uniform> emission: EmissionParams;

const TILE_SIZE: u32 = ${TILE_SIZE}u;
var<workgroup> tilePos: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileVel: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileMass: array<f32, TILE_SIZE>;

@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id)  lid: vec3<u32>) {
  let i: u32 = gid.x;
  let n: u32 = u32(params.numParticlesF);
  let isActive: bool = i < n;

  // Hoist invariants
  let eps2: f32 = params.eps * params.eps;
  let Gc: f32 = params.G;
  let Rc: f32 = params.R;
  let Rcvt: f32 = params.radiateCoeff;
  let com: vec3<f32> = comIn.data.xyz;

  var pos: vec3<f32> = vec3<f32>(0.0);
  var vel: vec3<f32> = vec3<f32>(0.0);
  var mi: f32 = 1.0;
  var repulse_i: f32 = 1.0;
  if (isActive) {
    pos = posIn.data[i].xyz;
    vel = velIn.data[i].xyz;
    mi = masses.data[i];
    repulse_i = repulse.data[i];
  }
  let hasMass: bool = isActive && (mi > 0.0);

  // Accumulate acceleration directly (avoid multiplying by mi and dividing later)
  var acc: vec3<f32> = vec3<f32>(0.0);
  var radiate_mag: f32 = 0.0;

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }

    // Load a tile of j-particles into shared memory
    let jIndex = base + lid.x;
    if (jIndex < n) {
      tilePos[lid.x] = posIn.data[jIndex];
      tileVel[lid.x] = velIn.data[jIndex];
      tileMass[lid.x] = masses.data[jIndex];
    } else {
      tilePos[lid.x] = vec4<f32>(0.0);
      tileVel[lid.x] = vec4<f32>(0.0);
      tileMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remaining: u32 = n - base;
    var tileCount: u32 = TILE_SIZE;
    if (remaining < TILE_SIZE) { tileCount = remaining; }

    // Only massive particles accumulate forces; zero-mass particles do nothing
    if (hasMass) {
      var k: u32 = 0u;
      loop {
        if (k >= tileCount) { break; }
        let jGlobal = base + k;
        if (jGlobal != i) {
          let mj = tileMass[k];
          if (mj > 0.0) {
            let pj = tilePos[k].xyz;
            let vj = tileVel[k].xyz;
            let diff = pj - pos;

            // Plummer-type softening for both attraction and repulsion
            let dist2 = dot(diff, diff);
            let soft2 = dist2 + eps2;
            let invSoft = inverseSqrt(soft2);
            let dir = diff * invSoft;               // normalized direction
            let invSoft2 = invSoft * invSoft;       // 1/soft^2
            let invSoft4 = invSoft2 * invSoft2; // 1/soft^4 (changed from ^6

            // Acceleration magnitudes (depend only on mj)
            let a_attract = Gc * mj * invSoft2;
            let a_repulse = (Rc * mj * invSoft4) * max(1.0, repulse_i);

            // Radiative damping modeled as acceleration
            var a_radiate: f32 = 0.0;
            if (a_repulse > a_attract) {
              let closingSpeed = dot(diff, vel - vj);
              a_radiate = Rcvt * closingSpeed * invSoft; // acceleration units
            }

            let a_net = a_attract - a_repulse - a_radiate;
            radiate_mag = radiate_mag + abs(a_radiate);
            acc = acc + dir * a_net;
          }
        }
        k = k + 1u;
      }
    }

    workgroupBarrier();
    base = base + TILE_SIZE;
  }

  if (isActive) {
    // Spin acceleration in XZ plane (independent of particle mass)
    var spinAccel: vec3<f32> = vec3<f32>(0.0);
    if (params.spin != 0.0) {
      let rel = pos - com;
      let posXZ = rel.xz;
      let d2 = dot(posXZ, posXZ);
      if (d2 > 0.0) {
        let invd = inverseSqrt(d2);
        let tangent = vec2<f32>(-posXZ.y, posXZ.x);
        spinAccel = vec3<f32>(tangent.x, 0.0, tangent.y) * (params.spin * invd);
        let loA = vec3<f32>(-1000.0);
        let hiA = vec3<f32>( 1000.0);
        spinAccel = clamp(spinAccel, loA, hiA);
      }
    }

    if (hasMass) {
      // Integrate with acceleration directly (no divide by mi)
      var v = (vel + (acc + spinAccel) * params.dt) * params.damping;
      var p = pos + v * params.dt;
      posOut.data[i] = vec4<f32>(p, radiate_mag);
      velOut.data[i] = vec4<f32>(v, 0.0);
    } else {
      // Zero-mass particles: do not integrate, do not act as test particles
      posOut.data[i] = posIn.data[i];
      velOut.data[i] = velIn.data[i];
    }

    // Decay extra repulsion factor toward 1.0 each physics pass using per-substep decayFactor
    let excess = max(0.0, repulse_i - 1.0);
    let decayed = excess * emission.decayFactor;
    repulse.data[i] = 1.0 + decayed;
  }
}
`;

        // Fusion compute (runs after integration) — merges when repulsive force dominates beyond a threshold and particles are approaching; zero-mass excluded
        const fusionWGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct FusionParams { fuseRadius: f32, minRelSpeed: f32, fusionFactor: f32, _pad: f32 }
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
struct Claims { data: array<atomic<u32>>, }
struct EmissionParams { boost: f32, decayFactor: f32, _pad0: f32, _pad1: f32 }

@group(0) @binding(0) var<storage, read_write> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read_write> velocities: Vec4Buffer;
@group(0) @binding(2) var<storage, read_write> masses: FloatBuffer;
@group(0) @binding(3) var<uniform> params: SimParams;
@group(0) @binding(4) var<uniform> fparams: FusionParams;
@group(0) @binding(5) var<storage, read_write> claims: Claims;
@group(0) @binding(6) var<storage, read_write> fuseFlags: FloatBuffer; // new: flash flags
@group(0) @binding(7) var<storage, read_write> repulse: FloatBuffer;   // new: extra repulsion factor
@group(0) @binding(8) var<uniform> emission: EmissionParams;           // boost/decay params

const TILE_SIZE: u32 = ${TILE_SIZE}u;
var<workgroup> tilePos: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileVel: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileMass: array<f32, TILE_SIZE>;

@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id) lid: vec3<u32>) {
  let i: u32 = gid.x;
  let n: u32 = u32(params.numParticlesF);
  let inBounds: bool = i < n;

  var mi0: f32 = 0.0;
  var canFuse: bool = false;
  var p_i: vec3<f32> = vec3<f32>(0.0);
  var v_i: vec3<f32> = vec3<f32>(0.0);
  if (inBounds) {
    mi0 = masses.data[i];
    p_i = positions.data[i].xyz;
    v_i = velocities.data[i].xyz;
    if (mi0 > 0.0 && atomicLoad(&claims.data[i]) == 0u) {
      canFuse = true;
    }
  }

  var bestJ: u32 = i;
  var bestD2: f32 = 1e30;
  var found: bool = false;

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }
    let jIndex = base + lid.x;
    if (jIndex < n) {
      tilePos[lid.x] = positions.data[jIndex];
      tileVel[lid.x] = velocities.data[jIndex];
      tileMass[lid.x] = masses.data[jIndex];
    } else {
      tilePos[lid.x] = vec4<f32>(0.0);
      tileVel[lid.x] = vec4<f32>(0.0);
      tileMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remaining: u32 = n - base;
    var tileCount: u32 = TILE_SIZE;
    if (remaining < TILE_SIZE) { tileCount = remaining; }

    var k: u32 = 0u;
    loop {
      if (k >= tileCount) { break; }
      let j: u32 = base + k;
      if (canFuse && j != i) {
        let mj = tileMass[k];
        if (mj > 0.0) {
          let dp = tilePos[k].xyz - p_i;
          let d2 = dot(dp, dp);

          // Softened distance terms
          let eps2 = params.eps * params.eps;
          let soft2 = d2 + eps2;
          let invSoft = inverseSqrt(soft2);
          let invSoft2 = invSoft * invSoft;
          let invSoft4 = invSoft2 * invSoft2; // 1/soft^4 (changed from ^6
          let Gc = params.G;
          let Rc = params.R;

          // Use mass-independent magnitudes for comparison (mi*mj cancels)
          let attractiveM = Gc * invSoft2;
          let repulsiveM  = Rc * invSoft4;

          // Approaching if distance is shrinking: dp·(v_i - v_j) > 0
          let rel = v_i - tileVel[k].xyz;
          let approaching = dot(dp, rel) > 0.0;

          // Depth threshold (higher fusionFactor => easier to fuse)
          let ratio = repulsiveM / max(attractiveM, 1e-12);
          let req = 1.0 + (1.0 / max(fparams.fusionFactor, 1e-6));

          if (approaching && repulsiveM > attractiveM && ratio >= req) {
            if (!found || d2 < bestD2) {
              bestD2 = d2;
              bestJ = j;
              found = true;
            }
          }
        }
      }
      k = k + 1u;
    }

    workgroupBarrier();
    base = base + TILE_SIZE;
  }

  if (canFuse && found && bestJ != i) {
    // Only lower index survives; avoid mutual merges and races
    if (i < bestJ) {
      // Stochastic gating: skip with probability (1 - fusionProb)
      let prob = fparams._pad; // field reassigned to probability
      if (prob <= 0.0) { return; }
      // Simple hash-based RNG per pair (i,bestJ) to avoid extra buffers
      var h: u32 = (i * 73856093u) ^ (bestJ * 19349663u) ^ u32(params.numParticlesF);
      h ^= h >> 17;
      h *= 0xed5ad4bbu;
      h ^= h >> 11;
      h *= 0xac4c1b51u;
      h ^= h >> 15;
      h *= 0x31848babu;
      h ^= h >> 14;
      let rand01 = f32(h & 0x00FFFFFFu) / f32(0x01000000u);
      if (rand01 > prob) { return; }
      let selfLock = atomicCompareExchangeWeak(&claims.data[i], 0u, 2u);
      if (selfLock.exchanged) {
        let jLock = atomicCompareExchangeWeak(&claims.data[bestJ], 0u, 1u);
        if (jLock.exchanged) {
          // Re-read current values and merge conserving momentum and COM
          let mi = masses.data[i];
          let mj = masses.data[bestJ];
          if (mi > 0.0 && mj > 0.0) {
            let pi = positions.data[i].xyz;
            let pj = positions.data[bestJ].xyz;
            let vi = velocities.data[i].xyz;
            let vj = velocities.data[bestJ].xyz;
            let mNew = mi + mj;
            if (mNew > 0.0) {
              let pNew = (pi * mi + pj * mj) / mNew;
              let vNew = (vi * mi + vj * mj) / mNew;
              positions.data[i] = vec4<f32>(pNew, positions.data[i].w);
              velocities.data[i] = vec4<f32>(vNew, 0.0);
              masses.data[i] = mNew;

              masses.data[bestJ] = 0.0;
              velocities.data[bestJ] = vec4<f32>(0.0);

              // Flag survivor for white flash this frame
              fuseFlags.data[i] = 1.0;

              // Boost extra repulsion on survivor to simulate emitted energy using UI-controlled boost
              let boost = max(1.0, emission.boost);
              let cur = repulse.data[i];
              repulse.data[i] = max(cur, boost);
              // Reset consumed particle
              repulse.data[bestJ] = 1.0;
            }
          }
        }
      }
    }
  }
}
`;

        // WGSL: Pair detection pass (Phase1) — O(N^2) tiled like fusion but no merging
        const detectPairsWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, R: f32, spin: f32, eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32, }
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
struct PairCount { value: atomic<u32>, }
struct Pairs { data: array<vec4<u32>>, } // (a,b, packedNormalLo, packedNormalHi)

@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read> velocities: Vec4Buffer;
@group(0) @binding(2) var<storage, read> masses: FloatBuffer;
@group(0) @binding(3) var<uniform> params: SimParams;
@group(0) @binding(4) var<storage, read_write> pairCount: PairCount;
@group(0) @binding(5) var<storage, read_write> pairBuf: Pairs;

const TILE_SZ: u32 = ${WG_SIZE}u; // workgroup size
var<workgroup> tPos: array<vec4<f32>, TILE_SZ>;
var<workgroup> tVel: array<vec4<f32>, TILE_SZ>;
var<workgroup> tMass: array<f32, TILE_SZ>;

fn encodeNormal(n: vec3<f32>) -> vec2<u32> {
  let s = sign(n.z);
  let nx = clamp(n.x * 32767.0, -32767.0, 32767.0);
  let ny = clamp(n.y * 32767.0, -32767.0, 32767.0);
  let p0 = (u32(i32(nx) & 0xFFFF) | (u32(i32(ny) & 0xFFFF) << 16));
  let p1 = select(0u, 1u, s < 0.0);
  return vec2<u32>(p0, p1);
}

@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i: u32 = gid.x;
  let n: u32 = u32(params.numParticlesF);
  var alive: bool = i < n;
  var mi: f32 = 0.0;
  var pi: vec3<f32> = vec3<f32>(0.0);
  var vi: vec3<f32> = vec3<f32>(0.0);
  if (alive) {
    mi = masses.data[i];
    if (mi <= 0.0) { alive = false; }
    if (alive) {
      pi = positions.data[i].xyz;
      vi = velocities.data[i].xyz;
    }
  }

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }
    let jIdx = base + lid.x;
    if (jIdx < n) {
      tPos[lid.x] = positions.data[jIdx];
      tVel[lid.x] = velocities.data[jIdx];
      tMass[lid.x] = masses.data[jIdx];
    } else {
      tPos[lid.x] = vec4<f32>(0.0);
      tVel[lid.x] = vec4<f32>(0.0);
      tMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remain = n - base;
    var tileCount: u32 = TILE_SZ;
    if (remain < TILE_SZ) { tileCount = remain; }

    if (alive) {
      var k: u32 = 0u;
      loop {
        if (k >= tileCount) { break; }
        let j: u32 = base + k;
        if (j > i) {
          let mj = tMass[k];
            if (mj > 0.0) {
              let pj = tPos[k].xyz;
              let vj = tVel[k].xyz;
              let nvec = pj - pi;
              let d2 = dot(nvec, nvec);
              let ri = max(1.0, pow(mi, 0.3333));
              let rj = max(1.0, pow(mj, 0.3333));
              let R = ri + rj;
              if (d2 < R*R) {
                let relv = vj - vi;
                if (dot(nvec, relv) < 0.0) {
                  let len2 = max(d2, 1e-12);
                  let invLen = inverseSqrt(len2);
                  let nhat = nvec * invLen;
                  let packed = encodeNormal(nhat);
                  let idx = atomicAdd(&pairCount.value, 1u);
                  if (idx < ${MAX_PAIRS}u) {
                    pairBuf.data[idx] = vec4<u32>(i, j, packed.x, packed.y);
                  }
                }
              }
            }
        }
        k = k + 1u;
      }
    }

    workgroupBarrier();
    base = base + TILE_SZ;
  }
}
`;

        // WGSL: Split (impulse resolution) pass
        const splitPairsWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, R: f32, spin: f32, eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32, }
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
struct PairCount { value: atomic<u32>, }
struct Pairs { data: array<vec4<u32>>, }
struct Rest { alpha: f32, _pad0: f32, _pad1: f32, _pad2: f32 }
struct Locks { data: array<atomic<u32>>, }

@group(0) @binding(0) var<storage, read_write> velocities: Vec4Buffer;
@group(0) @binding(1) var<storage, read> masses: FloatBuffer;
@group(0) @binding(2) var<storage, read_write> pairCount: PairCount;
@group(0) @binding(3) var<storage, read> pairBuf: Pairs;
@group(0) @binding(4) var<uniform> rest: Rest;
@group(0) @binding(5) var<storage, read_write> locks: Locks;

fn decodeNormal(p0: u32, p1: u32) -> vec3<f32> {
  let sx = f32(i32(p0 & 0xFFFF));
  let sy = f32(i32((p0 >> 16) & 0xFFFF));
  var nx = sx / 32767.0;
  var ny = sy / 32767.0;
  let signZ = select(1.0, -1.0, (p1 & 1u) == 1u);
  let zz = max(0.0, 1.0 - nx*nx - ny*ny);
  var nz = sqrt(zz) * signZ;
  let norm = max(length(vec3<f32>(nx,ny,nz)), 1e-6);
  return vec3<f32>(nx,ny,nz) / norm;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let k = gid.x;
  let total = atomicLoad(&pairCount.value);
  if (k >= total) { return; }
  let rec = pairBuf.data[k];
  let a = rec.x; let b = rec.y;
  if (a == b) { return; }

  // Simple lock to avoid double-updates; if contention skip pair
  let la = atomicCompareExchangeWeak(&locks.data[a], 0u, 1u);
  if (!la.exchanged) { return; }
  let lb = atomicCompareExchangeWeak(&locks.data[b], 0u, 1u);
  if (!lb.exchanged) { atomicStore(&locks.data[a], 0u); return; }

  let m1 = masses.data[a]; let m2 = masses.data[b];
  if (m1 <= 0.0 || m2 <= 0.0) { return; }
  var v1 = velocities.data[a].xyz;
  var v2 = velocities.data[b].xyz;
  let n = decodeNormal(rec.z, rec.w);
  let rel = v2 - v1;
  let relN = dot(rel, n);
  if (relN >= 0.0) { // already separating
    atomicStore(&locks.data[b], 0u); atomicStore(&locks.data[a], 0u);
    return;
  }
  let e = clamp(rest.alpha, 0.0, 1.0);
  let invMass = (1.0 / max(m1, 1e-6)) + (1.0 / max(m2, 1e-6));
  let J = -(1.0 + e) * relN / invMass;
  v1 = v1 - (J / m1) * n;
  v2 = v2 + (J / m2) * n;
  velocities.data[a] = vec4<f32>(v1, 0.0);
  velocities.data[b] = vec4<f32>(v2, 0.0);
  atomicStore(&locks.data[b], 0u); atomicStore(&locks.data[a], 0u);
}
`;

        // Pipelines for merge/split (phase1)
        const detectPairsModule = device.createShaderModule({ code: detectPairsWGSL });
        const detectPairsPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: detectPairsModule, entryPoint: 'main' } });
        const splitPairsModule = device.createShaderModule({ code: splitPairsWGSL });
        const splitPairsPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: splitPairsModule, entryPoint: 'main' } });

        const detectPairsBG_posA = device.createBindGroup({
            layout: detectPairsPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: velA } },
                { binding: 2, resource: { buffer: massBuffer } },
                { binding: 3, resource: { buffer: simParamsBuffer } },
                { binding: 4, resource: { buffer: pairCountBuffer } },
                { binding: 5, resource: { buffer: pairBuffer } },
            ]
        });
        const detectPairsBG_posB = device.createBindGroup({
            layout: detectPairsPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: velB } },
                { binding: 2, resource: { buffer: massBuffer } },
                { binding: 3, resource: { buffer: simParamsBuffer } },
                { binding: 4, resource: { buffer: pairCountBuffer } },
                { binding: 5, resource: { buffer: pairBuffer } },
            ]
        });
        const splitPairsBG_posA = device.createBindGroup({
            layout: splitPairsPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: velA } },
                { binding: 1, resource: { buffer: massBuffer } },
                { binding: 2, resource: { buffer: pairCountBuffer } },
                { binding: 3, resource: { buffer: pairBuffer } },
                { binding: 4, resource: { buffer: restitutionUniform } },
                { binding: 5, resource: { buffer: lockBuffer } },
            ]
        });
        const splitPairsBG_posB = device.createBindGroup({
            layout: splitPairsPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: velB } },
                { binding: 1, resource: { buffer: massBuffer } },
                { binding: 2, resource: { buffer: pairCountBuffer } },
                { binding: 3, resource: { buffer: pairBuffer } },
                { binding: 4, resource: { buffer: restitutionUniform } },
                { binding: 5, resource: { buffer: lockBuffer } },
            ]
        });

        // After WGSL shader strings (computeWGSL & fusionWGSL) define pipelines/bind groups
        const computeModule = device.createShaderModule({ code: computeWGSL });
        const computePipeline = device.createComputePipeline({ layout: 'auto', compute: { module: computeModule, entryPoint: 'main' } });
        const computeBG_AtoB = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: velA } },
                { binding: 2, resource: { buffer: posB } },
                { binding: 3, resource: { buffer: velB } },
                { binding: 4, resource: { buffer: simParamsBuffer } },
                { binding: 5, resource: { buffer: smoothComBuffer } },
                { binding: 6, resource: { buffer: massBuffer } },
                { binding: 7, resource: { buffer: repulseBuffer } },
                { binding: 8, resource: { buffer: emissionParamsBuffer } },
            ]
        });
        const computeBG_BtoA = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: velB } },
                { binding: 2, resource: { buffer: posA } },
                { binding: 3, resource: { buffer: velA } },
                { binding: 4, resource: { buffer: simParamsBuffer } },
                { binding: 5, resource: { buffer: smoothComBuffer } },
                { binding: 6, resource: { buffer: massBuffer } },
                { binding: 7, resource: { buffer: repulseBuffer } },
                { binding: 8, resource: { buffer: emissionParamsBuffer } },
            ]
        });
        const fusionModule = device.createShaderModule({ code: fusionWGSL });
        const fusionPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: fusionModule, entryPoint: 'main' } });
        const fusionBG_posA = device.createBindGroup({
            layout: fusionPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: velA } },
                { binding: 2, resource: { buffer: massBuffer } },
                { binding: 3, resource: { buffer: simParamsBuffer } },
                { binding: 4, resource: { buffer: fusionParamsBuffer } },
                { binding: 5, resource: { buffer: claimsBuffer } },
                { binding: 6, resource: { buffer: fuseFlagsBuffer } },
                { binding: 7, resource: { buffer: repulseBuffer } },
                { binding: 8, resource: { buffer: emissionParamsBuffer } },
            ]
        });
        const fusionBG_posB = device.createBindGroup({
            layout: fusionPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: velB } },
                { binding: 2, resource: { buffer: massBuffer } },
                { binding: 3, resource: { buffer: simParamsBuffer } },
                { binding: 4, resource: { buffer: fusionParamsBuffer } },
                { binding: 5, resource: { buffer: claimsBuffer } },
                { binding: 6, resource: { buffer: fuseFlagsBuffer } },
                { binding: 7, resource: { buffer: repulseBuffer } },
                { binding: 8, resource: { buffer: emissionParamsBuffer } },
            ]
        });

        // ---------- Rendering Pipeline (instanced billboards) ----------
        const quadVerts = new Float32Array([
            -1, -1,  -1, 1,   1, -1,
            -1,  1,   1, 1,   1, -1,
        ]);
        const quadVertexBuffer = device.createBuffer({ size: quadVerts.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(quadVertexBuffer, 0, quadVerts);

        const renderWGSL = /* wgsl */`
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
// 36 floats -> 9 vec4 (36) + 1 extra vec4 for params (viewportW,H,sizeScale,invLogMax)
struct Mats { m: array<vec4<f32>, 10>, }
@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read> masses: FloatBuffer;
@group(0) @binding(2) var<uniform> mats: Mats;
@group(0) @binding(3) var<storage, read> fuseFlags: FloatBuffer;

struct VSOut { @builtin(position) pos: vec4<f32>, @location(0) color: vec3<f32>, @location(1) alpha: f32, };

fn loadMat(idx: u32) -> mat4x4<f32> {
  // JS uploads matrices in column-major order; mat4x4 ctor takes columns
  let base = idx * 4u;
  return mat4x4<f32>(
    mats.m[base+0u],
    mats.m[base+1u],
    mats.m[base+2u],
    mats.m[base+3u]
  );
}

@vertex
fn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VSOut {
  let proj = loadMat(0u);
  let view = loadMat(1u);
  let world = positions.data[iid];
  let mass = masses.data[iid];
  let fuse = fuseFlags.data[iid];
  let vp = mats.m[8u]; // viewport/scale params
  let viewportW = vp.x;
  let viewportH = vp.y;
  let sizeScale = vp.z;
  let invLogMax = vp.w;
  let center = proj * (view * vec4<f32>(world.xyz, 1.0));
  let qx = select(-1.0, 1.0, (vid == 2u) || (vid == 4u) || (vid == 5u));
  let qy = select(-1.0, 1.0, (vid == 1u) || (vid == 3u) || (vid == 4u));
  let mNorm = log(1.0 + max(0.0, mass)) * invLogMax;
  let pixelSize = sizeScale * (0.3 + mNorm);
  let ndcOffset = vec2<f32>(qx, qy) * pixelSize * 2.0 / vec2<f32>(viewportW, viewportH);
  let w = max(0.1, abs(center.w));
  let offsetClip = vec4<f32>(ndcOffset * w, 0.0, 0.0);
  var out: VSOut;
  out.pos = center + offsetClip;
  var baseCol = vec3<f32>(mNorm, mNorm*0.5, 1.0 - mNorm);
  if (fuse > 0.0) { baseCol = vec3<f32>(1.0); }
  out.color = baseCol;
  out.alpha = select(0.0, 1.0, mass > 0.0);
  return out;
}

@fragment
fn fs(in: VSOut) -> @location(0) vec4<f32> {
  if (in.alpha <= 0.0) { discard; }
  return vec4<f32>(in.color, 1.0);
}
`;
        const renderModule = device.createShaderModule({ code: renderWGSL });
        const renderPipeline = device.createRenderPipeline({
          layout: 'auto',
          vertex: {
            module: renderModule,
            entryPoint: 'vs',
          },
          fragment: {
            module: renderModule,
            entryPoint: 'fs',
            targets: [{ format }]
          },
          primitive: { topology: 'triangle-list', cullMode: 'none' }
        });
        const renderBG_posA = device.createBindGroup({
          layout: renderPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: posA } },
            { binding: 1, resource: { buffer: massBuffer } },
            { binding: 2, resource: { buffer: matricesBuffer } },
            { binding: 3, resource: { buffer: fuseFlagsBuffer } },
          ]
        });
        const renderBG_posB = device.createBindGroup({
          layout: renderPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: posB } },
            { binding: 1, resource: { buffer: massBuffer } },
            { binding: 2, resource: { buffer: matricesBuffer } },
            { binding: 3, resource: { buffer: fuseFlagsBuffer } },
          ]
        });

        // Mass stats compute (active count & max mass)
        const massStatsWGSL = /* wgsl */`
struct SimParams { dt: f32, G: f32, R: f32, spin: f32, eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32 }
struct FloatBuffer { data: array<f32>, }
struct Stats { data: array<atomic<u32>>, }
@group(0) @binding(0) var<storage, read> masses: FloatBuffer;
@group(0) @binding(1) var<storage, read_write> stats: Stats;
@group(0) @binding(2) var<uniform> params: SimParams;
@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
  let i = gid.x;
  let n = u32(params.numParticlesF);
  if (i >= n) { return; }
  let m = masses.data[i];
  if (m > 0.0) {
    atomicAdd(&stats.data[0], 1u);
    let bits = bitcast<u32>(m);
    loop {
      let old = atomicLoad(&stats.data[1]);
      if (bits <= old) { break; }
      let res = atomicCompareExchangeWeak(&stats.data[1], old, bits);
      if (res.exchanged) { break; }
    }
  }
}
`;
        const massStatsModule = device.createShaderModule({ code: massStatsWGSL });
        const massStatsPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: massStatsModule, entryPoint: 'main' } });
        const massStatsBG = device.createBindGroup({
          layout: massStatsPipeline.getBindGroupLayout(0),
          entries: [
            { binding: 0, resource: { buffer: massBuffer } },
            { binding: 1, resource: { buffer: statsBuffer } },
            { binding: 2, resource: { buffer: simParamsBuffer } },
          ]
        });

        // ---- Main Loop ----
        let readFromA = true; // indicates which buffers hold the latest state

        function updateDebug() {
            const currentTime = performance.now();
            const elapsedSeconds = (currentTime - startTime) / 1000;
            const avgActiveMass = totalMass / Math.max(1, dynActiveCount);
            let debugText = '<strong>Simulation Stats:</strong><br>' +
                            `Frame: ${loopCount}<br>` +
                            `Runtime: ${elapsedSeconds.toFixed(1)}s<br>` +
                            `Frame time: ${lastFrameMs.toFixed(2)} ms<br>` +
                            `Avg Mass: ${avgActiveMass.toFixed(1)}  Max Mass: ${dynMaxMass.toFixed(0)}<br>`;
            if (mergeSplitEnabled) {
                debugText += `Pairs: ${lastPairCount} Overflow: ${pairOverflow}<br>`;
            }
            debugDiv.innerHTML = debugText;
        }

        function frame() {
            const frameStart = performance.now();
            // Match nbody2.html timing tweaks (kept as single-shot changes)
            if (loopCount === 10) { damping = 1.0; dampingSlider.value = damping.toFixed(2); dampingValueDisplay.textContent = damping.toFixed(2); writeSimParams(); }
            if (loopCount === 300) { spin = 0.0; spinSlider.value = spin.toFixed(2); spinValueDisplay.textContent = spin.toFixed(2); writeSimParams(); }

            // Update matrices if size changed
            projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000000);
            updateViewMatrix();
            writeMatrices();

            const encoder = device.createCommandEncoder();

            // Compute center of mass for spin center (using current read buffer)
            {
              // Smooth COM before integration so spin uses latest available center
               const ps0 = encoder.beginComputePass();
               ps0.setPipeline(comSmoothPipeline);
               ps0.setBindGroup(0, comSmoothBG);
               ps0.dispatchWorkgroups(1);
               ps0.end();
            }

            // Per-frame params
            const dt = baseDt;
            const dampingFrame = damping;
            const effectiveG = G;
            const effectiveR = R;
            simParamsData[0] = dt;           // dt
            simParamsData[1] = effectiveG;   // G
            simParamsData[2] = effectiveR;   // R
            simParamsData[3] = spin;         // spin per frame
            simParamsData[4] = EPS;          // eps
            simParamsData[5] = dampingFrame; // damping per frame
            simParamsData[6] = particleCount;
            simParamsData[7] = radiateCoeff; // radiative damping
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData.buffer, simParamsData.byteOffset, simParamsData.byteLength);

            // Emission decay factor based on baseDt (no substeps)
            const decayFactor = Math.exp(-Math.LN2 * (dt / Math.max(1e-6, decayHalfLife)));
            emissionParamsData[0] = fusionBoost; // boost
            emissionParamsData[1] = decayFactor; // per-frame decay factor
            device.queue.writeBuffer(emissionParamsBuffer, 0, emissionParamsData.buffer, emissionParamsData.byteOffset, emissionParamsData.byteLength);

            // Single compute pass per frame (no substeps)
            let localReadFromA = readFromA;
            const workgroupSize = WG_SIZE;
            const workgroupCount = Math.ceil(particleCount / workgroupSize);
            {
                const cpass = encoder.beginComputePass();
                cpass.setPipeline(computePipeline);
                cpass.setBindGroup(0, localReadFromA ? computeBG_AtoB : computeBG_BtoA);
                cpass.dispatchWorkgroups(workgroupCount);
                cpass.end();
                localReadFromA = !localReadFromA;
            }

            // Fusion: run after integration on the latest buffers
            device.queue.writeBuffer(claimsBuffer, 0, zeroClaims); // clear claim flags
            device.queue.writeBuffer(fuseFlagsBuffer, 0, zeroFuseFlags); // clear fuse flash flags
            {
              const fpass = encoder.beginComputePass();
              fpass.setPipeline(fusionPipeline);
              fpass.setBindGroup(0, localReadFromA ? fusionBG_posA : fusionBG_posB); // operate on latest write buffers
              fpass.dispatchWorkgroups(workgroupCount);
              fpass.end();
            }
            // Mass stats pass (after fusion so masses are updated)
            device.queue.writeBuffer(statsBuffer, 0, zeroStats);
            {
              const spass = encoder.beginComputePass();
              spass.setPipeline(massStatsPipeline);
              spass.setBindGroup(0, massStatsBG);
              spass.dispatchWorkgroups(workgroupCount);
              spass.end();
              // Find an unmapped / not-pending readback buffer
              let targetIndex = -1;
              for (let t = 0; t < NUM_READBACK; ++t) {
                const cand = (statsWriteIndex + t) % NUM_READBACK;
                if (!statsPendingMap[cand]) { targetIndex = cand; break; }
              }
              if (targetIndex !== -1) {
                encoder.copyBufferToBuffer(statsBuffer, 0, statsReadBuffers[targetIndex], 0, 16);
                copiedThisFrameIndex = targetIndex;
                statsWriteIndex = (targetIndex + 1) % NUM_READBACK;
              } else {
                // All readback buffers busy; skip this frame's stats to avoid hazard
                copiedThisFrameIndex = -1;
              }
            }

            // Merge/Split Phase1 passes
            if (mergeSplitEnabled) {
              // reset counters / locks
              device.queue.writeBuffer(pairCountBuffer, 0, new Uint32Array([0]));
              device.queue.writeBuffer(lockBuffer, 0, new Uint32Array(particleCount));
              const dp = encoder.beginComputePass();
              dp.setPipeline(detectPairsPipeline);
              dp.setBindGroup(0, localReadFromA ? detectPairsBG_posA : detectPairsBG_posB);
              dp.dispatchWorkgroups(workgroupCount);
              dp.end();
              const sp = encoder.beginComputePass();
              sp.setPipeline(splitPairsPipeline);
              sp.setBindGroup(0, localReadFromA ? splitPairsBG_posA : splitPairsBG_posB);
              const pairWG = 256;
              const pairGroups = Math.ceil(MAX_PAIRS / pairWG);
              sp.dispatchWorkgroups(pairGroups);
              sp.end();
            }

            // Render pass
            {
              const viewTex = context.getCurrentTexture().createView();
              const rpass = encoder.beginRenderPass({
                colorAttachments: [{ view: viewTex, clearValue: { r:0, g:0, b:0, a:1 }, loadOp: 'clear', storeOp: 'store' }]
              });
              rpass.setPipeline(renderPipeline);
              rpass.setBindGroup(0, localReadFromA ? renderBG_posA : renderBG_posB);
              rpass.draw(6, particleCount, 0, 0);
              rpass.end();
            }

            device.queue.submit([encoder.finish()]);

            // Drain any mapped buffers still pending to prevent hazard
            for (let i = 0; i < NUM_READBACK; i++) {
              if (statsPendingMap[i]) { /* already handling */ }
            }

            // Read last frame's results (buffer we wrote in the previous frame)
            if (lastCopiedIndex !== -1 && !statsPendingMap[lastCopiedIndex]) {
              const readIdx = lastCopiedIndex;
              statsPendingMap[readIdx] = true;
              statsReadBuffers[readIdx].mapAsync(GPUMapMode.READ).then(() => {
                const u8 = new Uint8Array(statsReadBuffers[readIdx].getMappedRange());
                const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
                const active = dv.getUint32(0, true);
                const maxBits = dv.getUint32(4, true);
                const maxMassF = new Float32Array(new Uint32Array([maxBits]).buffer)[0];
                statsReadBuffers[readIdx].unmap();
                statsPendingMap[readIdx] = false;
                dynActiveCount = Math.max(1, active);
                dynMaxMass = Math.max(1.0, maxMassF);
                // Update matrices for next frame's normalization
                writeMatrices();
              }).catch(() => { statsPendingMap[readIdx] = false; /* ignore on navigation */ });
            }

            // Remember which buffer we wrote this frame so we can read it next frame (if we wrote any)
            if (copiedThisFrameIndex !== -1) { lastCopiedIndex = copiedThisFrameIndex; }

            // Update global readFromA for next frame
            readFromA = localReadFromA;

            loopCount += 1;
            lastFrameMs = performance.now() - frameStart;
            updateDebug();
            requestAnimationFrame(frame);
               }
        frame();
    })();
    </script>
</body>

</html>
