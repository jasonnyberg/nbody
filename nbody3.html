<!DOCTYPE html>
<!--
  Copyright (c) 2025 Jason Nyberg
  Licensed under the GPL 3.0 License
  See LICENSE for details
-->
<html>

<head>
    <meta charset="UTF-8">
    <title>3D N-Body Simulation â€“ WebGPU</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #debug { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; font-family: monospace; padding: 10px; max-height: 90vh; overflow-y: auto; font-size: 12px; }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div id="debug"></div>
    <div style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="gSlider">G: <span id="gValue">0.2</span></label><br>
        <input type="range" id="gSlider" min="0.01" max="5.0" step="0.01" value="0.2">
    </div>
    <div style="position: fixed; top: 60px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="dampingSlider">Damping: <span id="dampingValue">1.0</span></label><br>
        <input type="range" id="dampingSlider" min="0.0" max="1.0" step="0.01" value="1.0">
    </div>
    <div style="position: fixed; top: 110px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="spinSlider">Spin: <span id="spinValue">0.0</span></label><br>
        <input type="range" id="spinSlider" min="-1.0" max="1.0" step="0.01" value="0.0">
    </div>
    <div style="position: fixed; top: 160px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="radiateSlider">Radiative: <span id="radiateValue">0.01</span></label><br>
        <input type="range" id="radiateSlider" min="0.0" max="0.1" step="0.001" value="0.01">
    </div>
    <div style="position: fixed; top: 210px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="fusionSlider">Fusion: <span id="fusionValue">1.00</span></label><br>
        <input type="range" id="fusionSlider" min="0.10" max="5.00" step="0.01" value="1.00">
    </div>

    <script type="text/javascript">
    "use strict";

    (async () => {
        const canvas = document.getElementById("glcanvas");
        const debugDiv = document.getElementById('debug');

        if (!('gpu' in navigator)) {
            alert('WebGPU not supported in this browser.');
            return;
        }

        const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' })
            || await navigator.gpu.requestAdapter();
        if (!adapter) { alert('Failed to get GPU adapter'); return; }
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();

        function resizeCanvas() {
            //const dpr = 1; // force DPR=1 for performance; set to window.devicePixelRatio for full res
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = Math.floor(canvas.clientWidth * dpr);
            canvas.height = Math.floor(canvas.clientHeight * dpr);
            context.configure({ device, format, alphaMode: 'premultiplied' });
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ---- Simulation Parameters ----
        const NUM_PARTICLES = 256*100; // must be multiple of 100 per original
        const DT = 0.2;
        let G = 0.2;
        const R = 10000.0;
        let spin = 0.03;
        const EPS = 0.001;
        let damping = 0.9;
        const stride = 4; // vec4 per particle
        const radius = 1000.0;
        const cam_dist = 1000.0;
        const SUBSTEPS = 4; // physics substeps per rendered frame
        let radiateCoeff = 0.01; // radiative damping coefficient
        let loopCount = 0;
        const startTime = performance.now();
        // Fusion parameters
        const FUSE_RADIUS = 3.0; // distance threshold for fusion (simulation units)
        const FUSE_MIN_REL_SPEED = 0.5; // minimum relative speed to be considered a "smash"
        let fusionFactor = 1.0; // user-controlled fusion ease factor (higher = easier to fuse)

        // UI wiring
        const gSlider = document.getElementById('gSlider');
        const gValueDisplay = document.getElementById('gValue');
        gSlider.addEventListener('input', (e) => { G = parseFloat(e.target.value); gValueDisplay.textContent = G.toFixed(2); writeSimParams(); });
        const dampingSlider = document.getElementById('dampingSlider');
        const dampingValueDisplay = document.getElementById('dampingValue');
        dampingSlider.addEventListener('input', (e) => { damping = parseFloat(e.target.value); dampingValueDisplay.textContent = damping.toFixed(2); writeSimParams(); });
        const spinSlider = document.getElementById('spinSlider');
        const spinValueDisplay = document.getElementById('spinValue');
        spinSlider.addEventListener('input', (e) => { spin = parseFloat(e.target.value); spinValueDisplay.textContent = spin.toFixed(2); writeSimParams(); });
        const radiateSlider = document.getElementById('radiateSlider');
        const radiateValueDisplay = document.getElementById('radiateValue');
        radiateSlider.addEventListener('input', (e) => { radiateCoeff = parseFloat(e.target.value); radiateValueDisplay.textContent = radiateCoeff.toFixed(3); writeSimParams(); });
        const fusionSlider = document.getElementById('fusionSlider');
        const fusionValueDisplay = document.getElementById('fusionValue');
        fusionSlider.addEventListener('input', (e) => { fusionFactor = parseFloat(e.target.value); fusionValueDisplay.textContent = fusionFactor.toFixed(2); writeFusionParams(); });

        // ---- Helpers ----
        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, (2 * far * near) * nf, 0
            ]);
        }
        function lookAt(eye, center, up) {
            const f = normalize(subtract(center, eye));
            const s = normalize(cross(f, up));
            const u = cross(s, f);
            return new Float32Array([
                s[0], u[0], -f[0], 0,
                s[1], u[1], -f[1], 0,
                s[2], u[2], -f[2], 0,
                -dot(s, eye), -dot(u, eye), dot(f, eye), 1
            ]);
        }
        function subtract(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function normalize(v) { const l = Math.hypot(v[0], v[1], v[2]); return [v[0]/l, v[1]/l, v[2]/l]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }

        let projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000000);
        let viewMatrix = lookAt([0, cam_dist/3, cam_dist], [0, 0, 0], [0, 1, 0]);

        // ---- GPU Buffers (positions/velocities ping-pong) ----
        const particleCount = NUM_PARTICLES;
        const stateByteSize = particleCount * stride * 4; // 4 bytes per float
        function createBufferFromArray(arr, usage) {
            const buffer = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
            new Float32Array(buffer.getMappedRange()).set(arr);
            buffer.unmap();
            return buffer;
        }
        function createEmptyBuffer(size, usage) {
            return device.createBuffer({ size, usage });
        }

        // Initialize CPU-side state
        const posInit = new Float32Array(particleCount * stride);
        const velInit = new Float32Array(particleCount * stride);
        for (let i = 0; i < particleCount; i++) {
            const ti = i * stride;
            let x, y, z;
            do {
                x = (Math.random() - 0.5) * 2 * radius;
                y = (Math.random() - 0.5) * 2 * radius;
                z = (Math.random() - 0.5) * 2 * radius;
            } while (x*x + y*y + z*z > radius*radius);
            posInit[ti+0] = x; posInit[ti+1] = y; posInit[ti+2] = z; posInit[ti+3] = 0.0; // radiate accumulator
            velInit[ti+0] = 0.0; velInit[ti+1] = 0.0; velInit[ti+2] = 0.0; velInit[ti+3] = 0.0;
        }

        let posA = createBufferFromArray(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        let posB = createEmptyBuffer(stateByteSize, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
        let velA = createBufferFromArray(velInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        let velB = createEmptyBuffer(stateByteSize, GPUBufferUsage.STORAGE);

        // ---- Mass Buffer ----
        // Use simple atomic mass numbers (mass number A) to represent per-particle mass.
        // Bias the distribution toward light elements (H/He), with a long, sparse tail to heavy elements up to Iron.
        const MAX_ATOMIC_MASS = 56; // Iron-56 upper bound for initial masses
        function randomAtomicMass() {
            const u = Math.random();
            if (u < 0.74) return 1;      // ~Hydrogen-1 dominant
            if (u < 0.97) return 4;      // ~Helium-4 abundant
            // Heavier nuclei: skew strongly toward lighter heavy elements
            const v = Math.random();
            // Power-law bias: v^4 concentrates near 0, few near 1 -> few very heavy nuclei (<= Fe)
            const a = 3 + Math.floor(Math.pow(v, 4.0) * (MAX_ATOMIC_MASS - 3 + 1));
            return Math.min(MAX_ATOMIC_MASS, Math.max(3, a));
        }
        const massesInit = new Float32Array(particleCount);
        let maxMass = 0;
        let massSum = 0;
        for (let i = 0; i < particleCount; i++) {
            const m = randomAtomicMass();
            massesInit[i] = m;
            massSum += m;
            if (m > maxMass) maxMass = m;
        }
        const avgMass = massSum / particleCount;
        // Physics mass scale keeps forces in a reasonable range when mass range is large
        const massScale = Math.max(1, avgMass);
        const massBuffer = createBufferFromArray(massesInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        // Fusion claims buffer (atomic flags) and params
        const claimsBuffer = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        const zeroClaims = new Uint32Array(particleCount); // reused each frame to clear claims
        const fusionParamsData = new Float32Array([FUSE_RADIUS, FUSE_MIN_REL_SPEED, fusionFactor, 0]);
        const fusionParamsBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeFusionParams() {
            fusionParamsData[0] = FUSE_RADIUS;
            fusionParamsData[1] = FUSE_MIN_REL_SPEED;
            fusionParamsData[2] = fusionFactor;
            fusionParamsData[3] = 0.0;
            device.queue.writeBuffer(fusionParamsBuffer, 0, fusionParamsData.buffer, fusionParamsData.byteOffset, fusionParamsData.byteLength);
        }
        writeFusionParams();
        // New: per-frame fuse flags for flash visualization
        const fuseFlagsBuffer = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        const zeroFuseFlags = new Float32Array(particleCount);

        // ---- Uniform Buffers ----
        // Sim params: [dt, G, R, spin, eps, damping, numParticlesF, radiateCoeff]
        const simParamsData = new Float32Array([DT, G, R, spin, EPS, damping, particleCount, radiateCoeff]);
        const simParamsBuffer = device.createBuffer({ size: simParamsData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeSimParams() {
            // Do not scale G by massScale; keep R scaled to balance repulsion if desired
            simParamsData[0] = DT;
            simParamsData[1] = G;           // G unscaled
            simParamsData[2] = R / massScale; // R scaled (unchanged)
            simParamsData[3] = spin;
            simParamsData[4] = EPS;
            simParamsData[5] = damping;
            simParamsData[6] = particleCount;
            simParamsData[7] = radiateCoeff;
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData.buffer, simParamsData.byteOffset, simParamsData.byteLength);
        }
        writeSimParams();

        // Matrices + viewport: projection(16) + view(16) + viewportSize(2) + sizeScale + pad = 36 floats
        const matricesData = new Float32Array(36);
        function writeMatrices() {
            matricesData.set(projMatrix, 0);
            matricesData.set(viewMatrix, 16);
            matricesData[32] = canvas.width;
            matricesData[33] = canvas.height;
            matricesData[34] = 5000.0; // size scale (matches WebGL version)
            // Use log mapping for mass normalization to improve dynamic range in color/size
            const invLogMax = maxMass > 0 ? (1.0 / Math.log(1.0 + maxMass)) : 1.0;
            matricesData[35] = invLogMax; // packed parameter for render normalization
            device.queue.writeBuffer(matricesBuffer, 0, matricesData.buffer, matricesData.byteOffset, matricesData.byteLength);
        }
        const matricesBuffer = device.createBuffer({ size: matricesData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        writeMatrices();

        // Center-of-mass buffers and pipelines
        const COM_WG = 256;
        const numComPartials = Math.ceil(particleCount / COM_WG);
        const comPartialsBuffer = device.createBuffer({ size: numComPartials * 16, usage: GPUBufferUsage.STORAGE });
        const comBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE });
        const smoothComBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        // Initialize smoothed COM to origin
        device.queue.writeBuffer(smoothComBuffer, 0, new Float32Array([0, 0, 0, 1]));

        const comReduce1WGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
struct Partials { data: array<vec4<f32>>, }
@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read_write> partials: Partials;
@group(0) @binding(2) var<uniform> params: SimParams;
@group(0) @binding(3) var<storage, read> masses: FloatBuffer;
const WG: u32 = 256u;
var<workgroup> s: array<vec4<f32>, WG>; // xyz = sum(m*pos), w = sum(m)
@compute @workgroup_size(256)
fn main(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = wid.x * WG + lid.x;
  let n = u32(params.numParticlesF);
  var accum = vec4<f32>(0.0);
  if (i < n) {
    let p = positions.data[i].xyz;
    let m = masses.data[i];
    accum = vec4<f32>(p * m, m);
  }
  s[lid.x] = accum;
  workgroupBarrier();
  var stride: u32 = WG / 2u;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) { s[lid.x] = s[lid.x] + s[lid.x + stride]; }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) { partials.data[wid.x] = s[0u]; }
}
`;
        const comReduce2WGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Partials { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> partials: Partials;
@group(0) @binding(1) var<storage, read_write> comOut: Single;
@group(0) @binding(2) var<uniform> params: SimParams;
const WG: u32 = 256u;
var<workgroup> s: array<vec4<f32>, WG>; // xyz = sum(m*pos), w = sum(m)
@compute @workgroup_size(256)
fn main(@builtin(local_invocation_id) lid: vec3<u32>) {
  let n = u32(params.numParticlesF);
  let numPartials = (n + WG - 1u) / WG;
  var sum = vec4<f32>(0.0);
  var j = lid.x;
  loop {
    if (j >= numPartials) { break; }
    sum = sum + partials.data[j];
    j = j + WG;
  }
  s[lid.x] = sum;
  workgroupBarrier();
  var stride: u32 = WG / 2u;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) { s[lid.x] = s[lid.x] + s[lid.x + stride]; }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) {
    let invM = select(0.0, 1.0 / s[0u].w, s[0u].w > 0.0);
    let com = s[0u].xyz * invM;
    // Store total mass in w for downstream camera tracker
    comOut.data = vec4<f32>(com, s[0u].w);
  }
}
`;
        const comReduce1Module = device.createShaderModule({ code: comReduce1WGSL });
        const comReduce1Pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comReduce1Module, entryPoint: 'main' } });
        const comReduce2Module = device.createShaderModule({ code: comReduce2WGSL });
        const comReduce2Pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comReduce2Module, entryPoint: 'main' } });

        // Bind groups for COM reduction (per position buffer)
        const comReduce1BG_A = device.createBindGroup({
            layout: comReduce1Pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: comPartialsBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
                { binding: 3, resource: { buffer: massBuffer } },
            ],
        });
        const comReduce1BG_B = device.createBindGroup({
            layout: comReduce1Pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: comPartialsBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
                { binding: 3, resource: { buffer: massBuffer } },
            ],
        });

        const comReduce2BG = device.createBindGroup({
            layout: comReduce2Pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: comPartialsBuffer } },
                { binding: 1, resource: { buffer: comBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
            ]
        });

        // Smooth COM (exponential smoothing once per frame)
        const comSmoothWGSL = /* wgsl */`
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> comIn: Single;
@group(0) @binding(1) var<storage, read_write> smoothOut: Single;
@compute @workgroup_size(1)
fn main() {
  let c = comIn.data.xyz;
  let s0 = smoothOut.data.xyz;
  let alpha: f32 = 0.10; // smoothing factor per rendered frame
  let s1 = s0 + (c - s0) * alpha; // linear interpolation
  smoothOut.data = vec4<f32>(s1, 1.0);
}
`;
        const comSmoothModule = device.createShaderModule({ code: comSmoothWGSL });
        const comSmoothPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comSmoothModule, entryPoint: 'main' } });
        const comSmoothBG = device.createBindGroup({
            layout: comSmoothPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: comBuffer } },
                { binding: 1, resource: { buffer: smoothComBuffer } },
            ]
        });

        // ---- Camera tracker (massless, gravitates toward COM) ----
        // Buffers to hold tracker position (xyz, w=1) and velocity (xyz)
        const camTrackPosBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        const camTrackVelBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(camTrackPosBuffer, 0, new Float32Array([0, 0, 0, 1]));
        device.queue.writeBuffer(camTrackVelBuffer, 0, new Float32Array([0, 0, 0, 0]));

        const camTrackWGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> comIn: Single;          // xyz = COM, w = total mass
@group(0) @binding(1) var<storage, read_write> camPos: Single;   // xyz = tracker position
@group(0) @binding(2) var<storage, read_write> camVel: Single;   // xyz = tracker velocity
@group(0) @binding(3) var<uniform> params: SimParams;

@compute @workgroup_size(1)
fn main() {
  let c = comIn.data.xyz;
  let M = comIn.data.w;
  var p = camPos.data.xyz;
  var v = camVel.data.xyz;
  let diff = c - p;
  let soft2 = dot(diff, diff) + params.eps * params.eps;
  let invSoft = inverseSqrt(soft2);
  let invSoft3 = invSoft * invSoft * invSoft; // 1/(r^3) with softening
  let acc = params.G * M * diff * invSoft3;   // gravitational accel toward COM
  let loA = vec3<f32>(-1000.0);
  let hiA = vec3<f32>( 1000.0);
  let a = clamp(acc, loA, hiA);
  v = (v + a * params.dt) * params.damping;
  p = p + v * params.dt;
  camPos.data = vec4<f32>(p, 1.0);
  camVel.data = vec4<f32>(v, 0.0);
}
`;
        const camTrackModule = device.createShaderModule({ code: camTrackWGSL });
        const camTrackPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: camTrackModule, entryPoint: 'main' } });
        const camTrackBG = device.createBindGroup({
            layout: camTrackPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: comBuffer } },
                { binding: 1, resource: { buffer: camTrackPosBuffer } },
                { binding: 2, resource: { buffer: camTrackVelBuffer } },
                { binding: 3, resource: { buffer: simParamsBuffer } },
            ]
        });

        // ---- Shaders (WGSL) ----
        const computeWGSL = /* wgsl */`
struct SimParams {
  dt: f32,
  G: f32,
  R: f32,
  spin: f32,
  eps: f32,
  damping: f32,
  numParticlesF: f32,
  radiateCoeff: f32,
}

struct Vec4Buffer { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
struct FloatBuffer { data: array<f32>, }

@group(0) @binding(0) var<storage, read> posIn: Vec4Buffer;
@group(0) @binding(1) var<storage, read> velIn: Vec4Buffer;
@group(0) @binding(2) var<storage, read_write> posOut: Vec4Buffer;
@group(0) @binding(3) var<storage, read_write> velOut: Vec4Buffer;
@group(0) @binding(4) var<uniform> params: SimParams;
@group(0) @binding(5) var<storage, read> comIn: Single;
@group(0) @binding(6) var<storage, read> masses: FloatBuffer;

const TILE_SIZE: u32 = 256u;
var<workgroup> tilePos: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileVel: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileMass: array<f32, TILE_SIZE>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id)  lid: vec3<u32>) {
  let i: u32 = gid.x;
  let n: u32 = u32(params.numParticlesF);
  let isActive: bool = i < n;

  // Hoist invariants
  let eps2: f32 = params.eps * params.eps;
  let Gc: f32 = params.G;
  let Rc: f32 = params.R;
  let Rcvt: f32 = params.radiateCoeff;
  let com: vec3<f32> = comIn.data.xyz;

  var pos: vec3<f32> = vec3<f32>(0.0);
  var vel: vec3<f32> = vec3<f32>(0.0);
  var mi: f32 = 1.0;
  if (isActive) {
    pos = posIn.data[i].xyz;
    vel = velIn.data[i].xyz;
    mi = masses.data[i];
  }
  let activeParticle: bool = isActive && (mi > 0.0);

  var force: vec3<f32> = vec3<f32>(0.0);
  var radiate_mag: f32 = 0.0;

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }

    // Load a tile of j-particles into shared memory
    let jIndex = base + lid.x;
    if (jIndex < n) {
      tilePos[lid.x] = posIn.data[jIndex];
      tileVel[lid.x] = velIn.data[jIndex];
      tileMass[lid.x] = masses.data[jIndex];
    } else {
      tilePos[lid.x] = vec4<f32>(0.0);
      tileVel[lid.x] = vec4<f32>(0.0);
      tileMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remaining: u32 = n - base;
    var tileCount: u32 = TILE_SIZE;
    if (remaining < TILE_SIZE) { tileCount = remaining; }

    if (activeParticle) {
      var k: u32 = 0u;
      loop {
        if (k >= tileCount) { break; }
        let jGlobal = base + k;
        if (jGlobal != i) {
          let mj = tileMass[k];
          if (mj > 0.0) {
            let pj = tilePos[k].xyz;
            let vj = tileVel[k].xyz;
            let diff = pj - pos;

            // Plummer-type softening for both attraction and repulsion
            let dist2 = dot(diff, diff);
            let soft2 = dist2 + eps2;
            let invSoft = inverseSqrt(soft2);
            let dir = diff * invSoft;               // normalized direction
            let invSoft2 = invSoft * invSoft;       // 1/soft^2
            let invSoft6 = invSoft2 * invSoft2 * invSoft2; // 1/soft^6

            // True force magnitudes: F = G * mi * mj / soft^2, similar scaling for repulsion
            let attractiveF = Gc * mi * mj * invSoft2;
            let repulsiveF  = Rc * mi * mj * invSoft6;

            // Radiative damping modeled as acceleration; convert to force by multiplying with mi
            var radiateAccel: f32 = 0.0;
            if (repulsiveF > attractiveF) {
              let closingSpeed = dot(diff, vel - vj);
              radiateAccel = Rcvt * closingSpeed * invSoft; // acceleration units
            }

            let fmagF = attractiveF - repulsiveF - (radiateAccel * mi);
            radiate_mag = radiate_mag + abs(radiateAccel); // store accel magnitude for visualization
            force = force + dir * fmagF;
          }
        }
        k = k + 1u;
      }
    }

    workgroupBarrier();
    base = base + TILE_SIZE;
  }

  if (activeParticle) {
    // Spin force in XZ plane (skip completely if spin is zero)
    if (params.spin != 0.0) {
      let rel = pos - com;
      let posXZ = rel.xz;
      let d2 = dot(posXZ, posXZ);
      if (d2 > 0.0) {
        let invd = inverseSqrt(d2);
        let tangent = vec2<f32>(-posXZ.y, posXZ.x);
        // Treat spin as an acceleration, independent of particle mass
        let spinAccel = vec3<f32>(tangent.x, 0.0, tangent.y) * (params.spin * invd);
        let loA = vec3<f32>(-1000.0);
        let hiA = vec3<f32>( 1000.0);
        // Convert to force contribution by multiplying with mi so that after division by mi it yields mass-independent acceleration
        force = force + clamp(spinAccel, loA, hiA) * mi;
      }
    }

    // Convert accumulated mass-weighted force to acceleration by dividing with mi
    var v = (vel + (force / max(mi, 1e-6)) * params.dt) * params.damping;
    var p = pos + v * params.dt;

    posOut.data[i] = vec4<f32>(p, radiate_mag);
    velOut.data[i] = vec4<f32>(v, 0.0);
  } else if (isActive) {
    // Zero-mass particle: copy through to preserve radiate accumulator
    posOut.data[i] = posIn.data[i];
    velOut.data[i] = velIn.data[i];
  }
}
`;

        // Fusion compute (runs after integration) â€” merges close, high-speed pairs; zero-mass excluded
        const fusionWGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct FusionParams { fuseRadius: f32, minRelSpeed: f32, fusionFactor: f32, _pad: f32 }
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
struct Claims { data: array<atomic<u32>>, }

@group(0) @binding(0) var<storage, read_write> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read_write> velocities: Vec4Buffer;
@group(0) @binding(2) var<storage, read_write> masses: FloatBuffer;
@group(0) @binding(3) var<uniform> params: SimParams;
@group(0) @binding(4) var<uniform> fparams: FusionParams;
@group(0) @binding(5) var<storage, read_write> claims: Claims;
@group(0) @binding(6) var<storage, read_write> fuseFlags: FloatBuffer; // new: flash flags

const TILE_SIZE: u32 = 256u;
var<workgroup> tilePos: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileVel: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileMass: array<f32, TILE_SIZE>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id) lid: vec3<u32>) {
  let i: u32 = gid.x;
  let n: u32 = u32(params.numParticlesF);
  let inBounds: bool = i < n;

  var mi0: f32 = 0.0;
  var canFuse: bool = false;
  var p_i: vec3<f32> = vec3<f32>(0.0);
  var v_i: vec3<f32> = vec3<f32>(0.0);
  if (inBounds) {
    mi0 = masses.data[i];
    p_i = positions.data[i].xyz;
    v_i = velocities.data[i].xyz;
    if (mi0 > 0.0 && atomicLoad(&claims.data[i]) == 0u) {
      canFuse = true;
    }
  }

  var bestJ: u32 = i;
  var bestD2: f32 = 1e30;
  var found: bool = false;

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }
    let jIndex = base + lid.x;
    if (jIndex < n) {
      tilePos[lid.x] = positions.data[jIndex];
      tileVel[lid.x] = velocities.data[jIndex];
      tileMass[lid.x] = masses.data[jIndex];
    } else {
      tilePos[lid.x] = vec4<f32>(0.0);
      tileVel[lid.x] = vec4<f32>(0.0);
      tileMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remaining: u32 = n - base;
    var tileCount: u32 = TILE_SIZE;
    if (remaining < TILE_SIZE) { tileCount = remaining; }

    var k: u32 = 0u;
    loop {
      if (k >= tileCount) { break; }
      let j: u32 = base + k;
      if (canFuse && j != i) {
        let mj = tileMass[k];
        if (mj > 0.0) {
          let dp = tilePos[k].xyz - p_i;
          let d2 = dot(dp, dp);

          // Pair-dependent fusion thresholds with user-controlled factor:
          // - Effective radius shrinks with total mass (heavier pairs harder to fuse), scaled up by fusionFactor
          // - Required relative speed grows with total mass, scaled down by fusionFactor
          let msum = mi0 + mj;
          let rEff = (fparams.fuseRadius * fparams.fusionFactor) / sqrt(1.0 + 0.05 * msum);
          let r2Eff = rEff * rEff;
          if (d2 <= r2Eff) {
            let rel = v_i - tileVel[k].xyz;
            let relSpeed = length(rel);
            let vMinEff = (fparams.minRelSpeed * (1.0 + 0.02 * msum)) / max(fparams.fusionFactor, 1e-6);
            if (relSpeed >= vMinEff) {
              if (!found || d2 < bestD2) {
                bestD2 = d2;
                bestJ = j;
                found = true;
              }
            }
          }
        }
      }
      k = k + 1u;
    }

    workgroupBarrier();
    base = base + TILE_SIZE;
  }

  if (canFuse && found && bestJ != i) {
    // Only lower index survives; avoid mutual merges and races
    if (i < bestJ) {
      let selfLock = atomicCompareExchangeWeak(&claims.data[i], 0u, 2u);
      if (selfLock.exchanged) {
        let jLock = atomicCompareExchangeWeak(&claims.data[bestJ], 0u, 1u);
        if (jLock.exchanged) {
          // Re-read current values and merge conserving momentum and COM
          let mi = masses.data[i];
          let mj = masses.data[bestJ];
          if (mi > 0.0 && mj > 0.0) {
            let pi = positions.data[i].xyz;
            let pj = positions.data[bestJ].xyz;
            let vi = velocities.data[i].xyz;
            let vj = velocities.data[bestJ].xyz;
            let mNew = mi + mj;
            if (mNew > 0.0) {
              let pNew = (pi * mi + pj * mj) / mNew;
              let vNew = (vi * mi + vj * mj) / mNew;
              positions.data[i] = vec4<f32>(pNew, positions.data[i].w);
              velocities.data[i] = vec4<f32>(vNew, 0.0);
              masses.data[i] = mNew;

              masses.data[bestJ] = 0.0;
              velocities.data[bestJ] = vec4<f32>(0.0);

              // Flag survivor for white flash this frame
              fuseFlags.data[i] = 1.0;
            }
          }
        }
      }
    }
  }
}
`;

        // Add render shader definition before pipelines
        const renderWGSL = /* wgsl */`
struct Matrices {
  projection: mat4x4<f32>,
  view: mat4x4<f32>,
  viewportSize: vec2<f32>,
  sizeScale: f32,
  _pad: f32,
}

struct Vec4Buffer { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
struct FloatBuffer { data: array<f32>, }

@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<uniform> mats: Matrices;
@group(0) @binding(2) var<storage, read> comIn: Single;
@group(0) @binding(3) var<storage, read> masses: FloatBuffer;
@group(0) @binding(4) var<storage, read> fuseFlags: FloatBuffer; // new: flash flags

struct VSOut {
  @builtin(position) position: vec4<f32>,
  @location(0) radiate: f32,
  @location(1) corner: vec2<f32>,
  @location(2) massNorm: f32,
  @location(3) fused: f32,
}

@vertex
fn vs_main(@location(0) corner: vec2<f32>, @builtin(instance_index) instance: u32) -> VSOut {
  let pos4 = positions.data[instance];
  let c = comIn.data.xyz;
  let m = masses.data[instance];
  // Logarithmic normalization for better spread across mass range
  let invLogMax = mats._pad; // stores 1 / log(1 + maxMass)
  let mNorm = clamp(log(1.0 + m) * invLogMax, 0.0, 1.0);
  let world = vec4<f32>(pos4.xyz - c, 1.0);
  let viewPos = mats.view * world;
  let clipCenter = mats.projection * viewPos;

  // size scaled by log-normalized mass
  let sizePx = max(2.0, (mNorm + 0.2) * mats.sizeScale / max(1.0, -viewPos.z));
  let offsetNDC = (corner * sizePx) * vec2<f32>(2.0 / mats.viewportSize.x, 2.0 / mats.viewportSize.y);
  let offset = offsetNDC * clipCenter.w;

  var out: VSOut;
  out.position = vec4<f32>(clipCenter.xy + offset, clipCenter.zw);
  out.radiate = pos4.w;
  out.corner = corner;
  out.massNorm = mNorm;
  out.fused = fuseFlags.data[instance];
  return out;
}

@fragment
fn fs_main(@location(0) radiate: f32, @location(1) corner: vec2<f32>, @location(2) massNorm: f32, @location(3) fused: f32) -> @location(0) vec4<f32> {
  let r = length(corner);
  if (r > 1.0) { discard; }
  let alpha = smoothstep(0.7, 0.0, r);

  // Flash newly fused survivors as bright white this frame
  if (fused > 0.0) {
    return vec4<f32>(1.0, 1.0, 1.0, alpha);
  }

  // Do not render zero-mass particles
  if (massNorm == 0.0) { discard; }

  // green channel encodes mass, blue from (1 - mass), red from radiative magnitude
  let g = massNorm;
  let b = 1.0 - massNorm;
  let rad = clamp(5.0 * radiate, 0.0, 1.0);
  return vec4<f32>(rad, g, b, alpha);
}
`;

        // ---- Pipelines ----
        const computeModule = device.createShaderModule({ code: computeWGSL });
        const computePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: { module: computeModule, entryPoint: 'main' }
        });

        // Fusion pipeline
        const fusionModule = device.createShaderModule({ code: fusionWGSL });
        const fusionPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: fusionModule, entryPoint: 'main' } });

        const renderModule = device.createShaderModule({ code: renderWGSL });
        // Quad geometry for billboard (two triangles)
        const quadVerts = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1,
        ]);
        const quadIdx = new Uint16Array([0,1,2, 2,1,3]);
        const quadVB = device.createBuffer({ size: quadVerts.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(quadVB, 0, quadVerts.buffer, quadVerts.byteOffset, quadVerts.byteLength);
        const quadIB = device.createBuffer({ size: quadIdx.byteLength, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(quadIB, 0, quadIdx.buffer, quadIdx.byteOffset, quadIdx.byteLength);

        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: renderModule,
                entryPoint: 'vs_main',
                buffers: [{ arrayStride: 2 * 4, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] }]
            },
            fragment: {
                module: renderModule,
                entryPoint: 'fs_main',
                targets: [{
                    format,
                    blend: {
                        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                    }
                }]
            },
            primitive: { topology: 'triangle-list', cullMode: 'none' }
        });

        // ---- Bind Groups ----
        function createComputeBindGroup(posInBuf, velInBuf, posOutBuf, velOutBuf) {
            return device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: posInBuf } },
                    { binding: 1, resource: { buffer: velInBuf } },
                    { binding: 2, resource: { buffer: posOutBuf } },
                    { binding: 3, resource: { buffer: velOutBuf } },
                    { binding: 4, resource: { buffer: simParamsBuffer } },
                    { binding: 5, resource: { buffer: comBuffer } },
                    { binding: 6, resource: { buffer: massBuffer } },
                ]
            });
        }
        let computeBG_AtoB = createComputeBindGroup(posA, velA, posB, velB);
        let computeBG_BtoA = createComputeBindGroup(posB, velB, posA, velA);

        function createRenderBindGroup(posBuf) {
            return device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: posBuf } },
                    { binding: 1, resource: { buffer: matricesBuffer } },
                    // Center rendering on smoothed COM to avoid drift
                    { binding: 2, resource: { buffer: smoothComBuffer } },
                    { binding: 3, resource: { buffer: massBuffer } },
                    { binding: 4, resource: { buffer: fuseFlagsBuffer } },
                ]
            });
        }
        let renderBG_posA = createRenderBindGroup(posA);
        let renderBG_posB = createRenderBindGroup(posB);

        function createFusionBindGroup(posBuf, velBuf) {
            return device.createBindGroup({
                layout: fusionPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: posBuf } },
                    { binding: 1, resource: { buffer: velBuf } },
                    { binding: 2, resource: { buffer: massBuffer } },
                    { binding: 3, resource: { buffer: simParamsBuffer } },
                    { binding: 4, resource: { buffer: fusionParamsBuffer } },
                    { binding: 5, resource: { buffer: claimsBuffer } },
                    { binding: 6, resource: { buffer: fuseFlagsBuffer } },
                ]
            });
        }
        let fusionBG_posA = createFusionBindGroup(posA, velA);
        let fusionBG_posB = createFusionBindGroup(posB, velB);

        // ---- Main Loop ----
        let readFromA = true; // indicates which buffers hold the latest state

        function updateDebug() {
            const currentTime = performance.now();
            const elapsedSeconds = (currentTime - startTime) / 1000;
            const fps = loopCount / elapsedSeconds;
            let debugText = '<strong>Simulation Stats:</strong><br>' +
                            `Frame: ${loopCount}<br>` +
                            `Runtime: ${elapsedSeconds.toFixed(1)}s<br>` +
                            `FPS: ${fps.toFixed(1)}<br>` +
                            `Avg Mass: ${avgMass.toFixed(1)}  Max Mass: ${maxMass.toFixed(0)}<br>`;
            debugDiv.innerHTML = debugText;
        }

        function frame() {
            // Match nbody2.html timing tweaks
            if (loopCount === 10) { damping = 1.0; dampingSlider.value = damping.toFixed(2); dampingValueDisplay.textContent = damping.toFixed(2); writeSimParams(); }
            if (loopCount === 150) { spin = 0.0; spinSlider.value = spin.toFixed(2); spinValueDisplay.textContent = spin.toFixed(2); writeSimParams(); }

            // Update matrices if size changed
            projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000000);
            writeMatrices();

            const encoder = device.createCommandEncoder();

            // Compute center of mass for spin center (using current read buffer)
            {
              const bg1 = readFromA ? comReduce1BG_A : comReduce1BG_B;
              const p1 = encoder.beginComputePass();
              p1.setPipeline(comReduce1Pipeline);
              p1.setBindGroup(0, bg1);
              p1.dispatchWorkgroups(numComPartials);
              p1.end();

              const p2 = encoder.beginComputePass();
              p2.setPipeline(comReduce2Pipeline);
              p2.setBindGroup(0, comReduce2BG);
              p2.dispatchWorkgroups(1);
              p2.end();
            }

            // Per-substep params: dt and damping scaled
            const dtSub = DT / SUBSTEPS;
            const dampingSub = Math.pow(damping, 1.0 / SUBSTEPS);
            const effectiveG = G;           // G unscaled per request
            const effectiveR = R / massScale;
            simParamsData[0] = dtSub;      // dt
            simParamsData[1] = effectiveG; // G
            simParamsData[2] = effectiveR; // R scaled to match
            simParamsData[3] = spin;       // spin (unchanged)
            simParamsData[4] = EPS;        // eps (unchanged)
            simParamsData[5] = dampingSub; // per-substep damping
            simParamsData[6] = particleCount;
            simParamsData[7] = radiateCoeff; // radiative damping
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData.buffer, simParamsData.byteOffset, simParamsData.byteLength);

            // Compute passes: SUBSTEPS sub-iterations, ping-ponging A/B
            let localReadFromA = readFromA;
            const workgroupSize = 256;
            const workgroupCount = Math.ceil(particleCount / workgroupSize);
            for (let s = 0; s < SUBSTEPS; s++) {
                const cpass = encoder.beginComputePass();
                cpass.setPipeline(computePipeline);
                cpass.setBindGroup(0, localReadFromA ? computeBG_AtoB : computeBG_BtoA);
                cpass.dispatchWorkgroups(workgroupCount);
                cpass.end();
                localReadFromA = !localReadFromA;
            }

            // Fusion: run after integration on the latest buffers
            device.queue.writeBuffer(claimsBuffer, 0, zeroClaims); // clear claim flags
            device.queue.writeBuffer(fuseFlagsBuffer, 0, zeroFuseFlags); // clear fuse flash flags
            {
              const fpass = encoder.beginComputePass();
              fpass.setPipeline(fusionPipeline);
              fpass.setBindGroup(0, localReadFromA ? fusionBG_posB : fusionBG_posA); // operate on latest write buffers
              fpass.dispatchWorkgroups(workgroupCount);
              fpass.end();
            }

            // Recompute center of mass for rendering (using latest state)
            {
              const bg1 = localReadFromA ? comReduce1BG_B : comReduce1BG_A; // latest written buffer
              const p1 = encoder.beginComputePass();
              p1.setPipeline(comReduce1Pipeline);
              p1.setBindGroup(0, bg1);
              p1.dispatchWorkgroups(numComPartials);
              p1.end();

              const p2 = encoder.beginComputePass();
              p2.setPipeline(comReduce2Pipeline);
              p2.setBindGroup(0, comReduce2BG);
              p2.dispatchWorkgroups(1);
              p2.end();

              // Smooth the COM once per frame for stable camera tracking
              const ps = encoder.beginComputePass();
              ps.setPipeline(comSmoothPipeline);
              ps.setBindGroup(0, comSmoothBG);
              ps.dispatchWorkgroups(1);
              ps.end();
            }

            // Render pass after last substep
            const colorView = context.getCurrentTexture().createView();
            const rpass = encoder.beginRenderPass({
                colorAttachments: [{ view: colorView, clearValue: { r:0, g:0, b:0, a:1 }, loadOp: 'clear', storeOp: 'store' }]
            });
            rpass.setPipeline(renderPipeline);
            rpass.setVertexBuffer(0, quadVB);
            rpass.setIndexBuffer(quadIB, 'uint16');
            rpass.setBindGroup(0, localReadFromA ? renderBG_posB : renderBG_posA); // latest is the write buffer from final substep
            rpass.drawIndexed(6, particleCount, 0, 0, 0);
            rpass.end();

            device.queue.submit([encoder.finish()]);

            // Update global readFromA for next frame
            readFromA = localReadFromA;

            loopCount++;
            updateDebug();
            requestAnimationFrame(frame);
        }
        frame();
    })();
    </script>
</body>

</html>
