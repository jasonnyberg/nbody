<!DOCTYPE html>
<!--
  Copyright (c) 2025 Jason Nyberg
  Licensed under the GPL 3.0 License
  See LICENSE for details
-->
<html>

<head>
    <meta charset="UTF-8">
    <title>3D N-Body Simulation â€“ WebGPU</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #debug { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; font-family: monospace; padding: 10px; max-height: 90vh; overflow-y: auto; font-size: 12px; }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div id="debug"></div>
    <div style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="gSlider">G: <span id="gValue">0.2</span></label><br>
        <input type="range" id="gSlider" min="0.01" max="5.0" step="0.01" value="0.2">
    </div>
    <div style="position: fixed; top: 60px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="dampingSlider">Damping: <span id="dampingValue">1.0</span></label><br>
        <input type="range" id="dampingSlider" min="0.0" max="1.0" step="0.01" value="1.0">
    </div>
    <div style="position: fixed; top: 110px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="spinSlider">Spin: <span id="spinValue">0.0</span></label><br>
        <input type="range" id="spinSlider" min="-1.0" max="1.0" step="0.01" value="0.0">
    </div>
    <div style="position: fixed; top: 160px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="radiateSlider">Radiative: <span id="radiateValue">0.01</span></label><br>
        <input type="range" id="radiateSlider" min="0.0" max="0.1" step="0.001" value="0.01">
    </div>

    <script type="text/javascript">
    "use strict";

    (async () => {
        const canvas = document.getElementById("glcanvas");
        const debugDiv = document.getElementById('debug');

        if (!('gpu' in navigator)) {
            alert('WebGPU not supported in this browser.');
            return;
        }

        const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' })
            || await navigator.gpu.requestAdapter();
        if (!adapter) { alert('Failed to get GPU adapter'); return; }
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();

        function resizeCanvas() {
            //const dpr = 1; // force DPR=1 for performance; set to window.devicePixelRatio for full res
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = Math.floor(canvas.clientWidth * dpr);
            canvas.height = Math.floor(canvas.clientHeight * dpr);
            context.configure({ device, format, alphaMode: 'premultiplied' });
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ---- Simulation Parameters ----
        const NUM_PARTICLES = 256*100; // must be multiple of 100 per original
        const DT = 0.2;
        let G = 0.2;
        const R = 10000.0;
        let spin = 0.03;
        const EPS = 0.001;
        let damping = 0.9;
        const stride = 4; // vec4 per particle
        const radius = 1000.0;
        const cam_dist = 1000.0;
        const SUBSTEPS = 4; // physics substeps per rendered frame
        let radiateCoeff = 0.01; // radiative damping coefficient
        let loopCount = 0;
        const startTime = performance.now();

        // UI wiring
        const gSlider = document.getElementById('gSlider');
        const gValueDisplay = document.getElementById('gValue');
        gSlider.addEventListener('input', (e) => { G = parseFloat(e.target.value); gValueDisplay.textContent = G.toFixed(2); writeSimParams(); });
        const dampingSlider = document.getElementById('dampingSlider');
        const dampingValueDisplay = document.getElementById('dampingValue');
        dampingSlider.addEventListener('input', (e) => { damping = parseFloat(e.target.value); dampingValueDisplay.textContent = damping.toFixed(2); writeSimParams(); });
        const spinSlider = document.getElementById('spinSlider');
        const spinValueDisplay = document.getElementById('spinValue');
        spinSlider.addEventListener('input', (e) => { spin = parseFloat(e.target.value); spinValueDisplay.textContent = spin.toFixed(2); writeSimParams(); });
        const radiateSlider = document.getElementById('radiateSlider');
        const radiateValueDisplay = document.getElementById('radiateValue');
        radiateSlider.addEventListener('input', (e) => { radiateCoeff = parseFloat(e.target.value); radiateValueDisplay.textContent = radiateCoeff.toFixed(3); writeSimParams(); });

        // ---- Helpers ----
        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, (2 * far * near) * nf, 0
            ]);
        }
        function lookAt(eye, center, up) {
            const f = normalize(subtract(center, eye));
            const s = normalize(cross(f, up));
            const u = cross(s, f);
            return new Float32Array([
                s[0], u[0], -f[0], 0,
                s[1], u[1], -f[1], 0,
                s[2], u[2], -f[2], 0,
                -dot(s, eye), -dot(u, eye), dot(f, eye), 1
            ]);
        }
        function subtract(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function normalize(v) { const l = Math.hypot(v[0], v[1], v[2]); return [v[0]/l, v[1]/l, v[2]/l]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }

        let projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000000);
        let viewMatrix = lookAt([0, cam_dist/3, cam_dist], [0, 0, 0], [0, 1, 0]);

        // ---- GPU Buffers (positions/velocities ping-pong) ----
        const particleCount = NUM_PARTICLES;
        const stateByteSize = particleCount * stride * 4; // 4 bytes per float
        function createBufferFromArray(arr, usage) {
            const buffer = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
            new Float32Array(buffer.getMappedRange()).set(arr);
            buffer.unmap();
            return buffer;
        }
        function createEmptyBuffer(size, usage) {
            return device.createBuffer({ size, usage });
        }

        // Initialize CPU-side state
        const posInit = new Float32Array(particleCount * stride);
        const velInit = new Float32Array(particleCount * stride);
        for (let i = 0; i < particleCount; i++) {
            const ti = i * stride;
            let x, y, z;
            do {
                x = (Math.random() - 0.5) * 2 * radius;
                y = (Math.random() - 0.5) * 2 * radius;
                z = (Math.random() - 0.5) * 2 * radius;
            } while (x*x + y*y + z*z > radius*radius);
            posInit[ti+0] = x; posInit[ti+1] = y; posInit[ti+2] = z; posInit[ti+3] = 0.0; // radiate accumulator
            velInit[ti+0] = 0.0; velInit[ti+1] = 0.0; velInit[ti+2] = 0.0; velInit[ti+3] = 0.0;
        }

        let posA = createBufferFromArray(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        let posB = createEmptyBuffer(stateByteSize, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
        let velA = createBufferFromArray(velInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        let velB = createEmptyBuffer(stateByteSize, GPUBufferUsage.STORAGE);

        // ---- Uniform Buffers ----
        // Sim params: [dt, G, R, spin, eps, damping, numParticlesF, radiateCoeff]
        const simParamsData = new Float32Array([DT, G, R, spin, EPS, damping, particleCount, radiateCoeff]);
        const simParamsBuffer = device.createBuffer({ size: simParamsData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeSimParams() {
            simParamsData[0] = DT;
            simParamsData[1] = G;
            simParamsData[2] = R;
            simParamsData[3] = spin;
            simParamsData[4] = EPS;
            simParamsData[5] = damping;
            simParamsData[6] = particleCount;
            simParamsData[7] = radiateCoeff;
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData.buffer, simParamsData.byteOffset, simParamsData.byteLength);
        }
        writeSimParams();

        // Matrices + viewport: projection(16) + view(16) + viewportSize(2) + sizeScale + pad = 36 floats
        const matricesData = new Float32Array(36);
        function writeMatrices() {
            matricesData.set(projMatrix, 0);
            matricesData.set(viewMatrix, 16);
            matricesData[32] = canvas.width;
            matricesData[33] = canvas.height;
            matricesData[34] = 5000.0; // size scale (matches WebGL version)
            matricesData[35] = 0.0;     // pad
            device.queue.writeBuffer(matricesBuffer, 0, matricesData.buffer, matricesData.byteOffset, matricesData.byteLength);
        }
        const matricesBuffer = device.createBuffer({ size: matricesData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        writeMatrices();

        // Center-of-mass buffers and pipelines
        const COM_WG = 256;
        const numComPartials = Math.ceil(particleCount / COM_WG);
        const comPartialsBuffer = device.createBuffer({ size: numComPartials * 16, usage: GPUBufferUsage.STORAGE });
        const comBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE });

        const comReduce1WGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Vec4Buffer { data: array<vec4<f32>>, }
struct Partials { data: array<vec4<f32>>, }
@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read_write> partials: Partials;
@group(0) @binding(2) var<uniform> params: SimParams;
const WG: u32 = 256u;
var<workgroup> s: array<vec3<f32>, WG>;
@compute @workgroup_size(256)
fn main(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = wid.x * WG + lid.x;
  var v = vec3<f32>(0.0);
  let n = u32(params.numParticlesF);
  if (i < n) { v = positions.data[i].xyz; }
  s[lid.x] = v;
  workgroupBarrier();
  var stride: u32 = WG / 2u;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) { s[lid.x] = s[lid.x] + s[lid.x + stride]; }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) { partials.data[wid.x] = vec4<f32>(s[0u], 0.0); }
}
`;
        const comReduce2WGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Partials { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> partials: Partials;
@group(0) @binding(1) var<storage, read_write> comOut: Single;
@group(0) @binding(2) var<uniform> params: SimParams;
const WG: u32 = 256u;
var<workgroup> s: array<vec3<f32>, WG>;
@compute @workgroup_size(256)
fn main(@builtin(local_invocation_id) lid: vec3<u32>) {
  let n = u32(params.numParticlesF);
  let numPartials = (n + WG - 1u) / WG;
  var sum = vec3<f32>(0.0);
  var j = lid.x;
  loop {
    if (j >= numPartials) { break; }
    sum = sum + partials.data[j].xyz;
    j = j + WG;
  }
  s[lid.x] = sum;
  workgroupBarrier();
  var stride: u32 = WG / 2u;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) { s[lid.x] = s[lid.x] + s[lid.x + stride]; }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) {
    let invN = 1.0 / f32(n);
    comOut.data = vec4<f32>(s[0u] * invN, 1.0);
  }
}
`;
        const comReduce1Module = device.createShaderModule({ code: comReduce1WGSL });
        const comReduce1Pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comReduce1Module, entryPoint: 'main' } });
        const comReduce2Module = device.createShaderModule({ code: comReduce2WGSL });
        const comReduce2Pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comReduce2Module, entryPoint: 'main' } });

        function createComReduce1BindGroup(posBuf) {
            return device.createBindGroup({
                layout: comReduce1Pipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: posBuf } },
                    { binding: 1, resource: { buffer: comPartialsBuffer } },
                    { binding: 2, resource: { buffer: simParamsBuffer } },
                ]
            });
        }
        const comReduce1BG_A = createComReduce1BindGroup(posA);
        const comReduce1BG_B = createComReduce1BindGroup(posB);
        const comReduce2BG = device.createBindGroup({
            layout: comReduce2Pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: comPartialsBuffer } },
                { binding: 1, resource: { buffer: comBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
            ]
        });

        // ---- Shaders (WGSL) ----
        const computeWGSL = /* wgsl */`
struct SimParams {
  dt: f32,
  G: f32,
  R: f32,
  spin: f32,
  eps: f32,
  damping: f32,
  numParticlesF: f32,
  radiateCoeff: f32,
}

struct Vec4Buffer { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }

@group(0) @binding(0) var<storage, read> posIn: Vec4Buffer;
@group(0) @binding(1) var<storage, read> velIn: Vec4Buffer;
@group(0) @binding(2) var<storage, read_write> posOut: Vec4Buffer;
@group(0) @binding(3) var<storage, read_write> velOut: Vec4Buffer;
@group(0) @binding(4) var<uniform> params: SimParams;
@group(0) @binding(5) var<storage, read> comIn: Single;

const TILE_SIZE: u32 = 256u;
var<workgroup> tilePos: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileVel: array<vec4<f32>, TILE_SIZE>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id)  lid: vec3<u32>) {
  let i: u32 = gid.x;
  let n: u32 = u32(params.numParticlesF);
  let isActive: bool = i < n;

  // Hoist invariants
  let eps2: f32 = params.eps * params.eps;
  let Gc: f32 = params.G;
  let Rc: f32 = params.R;
  let Rcvt: f32 = params.radiateCoeff;
  let com: vec3<f32> = comIn.data.xyz;

  var pos: vec3<f32> = vec3<f32>(0.0);
  var vel: vec3<f32> = vec3<f32>(0.0);
  if (isActive) {
    pos = posIn.data[i].xyz;
    vel = velIn.data[i].xyz;
  }

  var force: vec3<f32> = vec3<f32>(0.0);
  var radiate_mag: f32 = 0.0;

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }

    // Load a tile of j-particles into shared memory
    let jIndex = base + lid.x;
    if (jIndex < n) {
      tilePos[lid.x] = posIn.data[jIndex];
      tileVel[lid.x] = velIn.data[jIndex];
    } else {
      tilePos[lid.x] = vec4<f32>(0.0);
      tileVel[lid.x] = vec4<f32>(0.0);
    }
    workgroupBarrier();

    let remaining: u32 = n - base;
    var tileCount: u32 = TILE_SIZE;
    if (remaining < TILE_SIZE) { tileCount = remaining; }

    if (isActive) {
      var k: u32 = 0u;
      loop {
        if (k >= tileCount) { break; }
        let jGlobal = base + k;
        if (jGlobal != i) {
          let pj = tilePos[k].xyz;
          let vj = tileVel[k].xyz;
          let diff = pj - pos;

          // Plummer-type softening for both attraction and repulsion
          let dist2 = dot(diff, diff);
          let soft2 = dist2 + eps2;
          let invSoft = inverseSqrt(soft2);
          let dir = diff * invSoft;               // normalized direction
          let invSoft2 = invSoft * invSoft;       // 1/soft^2
          let invSoft6 = invSoft2 * invSoft2 * invSoft2; // 1/soft^6

          let attractive = Gc * invSoft2;
          let repulsive  = Rc * invSoft6;

          var radiate: f32 = 0.0;
          if (repulsive > attractive) {
            let closingSpeed = dot(diff, vel - vj);
            radiate = Rcvt * closingSpeed * invSoft; // scaled by 1/soft
          }

          let fmag = attractive - repulsive - radiate;
          radiate_mag = radiate_mag + abs(radiate);
          force = force + dir * fmag;
        }
        k = k + 1u;
      }
    }

    workgroupBarrier();
    base = base + TILE_SIZE;
  }

  if (isActive) {
    // Spin force in XZ plane (skip completely if spin is zero)
    if (params.spin != 0.0) {
      let rel = pos - com;
      let posXZ = rel.xz;
      let d2 = dot(posXZ, posXZ);
      if (d2 > 0.0) {
        let invd = inverseSqrt(d2);
        let tangent = vec2<f32>(-posXZ.y, posXZ.x);
        let spinForce = vec3<f32>(tangent.x, 0.0, tangent.y) * (params.spin * invd);
        let lo = vec3<f32>(-1000.0);
        let hi = vec3<f32>( 1000.0);
        force = force + clamp(spinForce, lo, hi);
      }
    }

    var v = (vel + force * params.dt) * params.damping;
    var p = pos + v * params.dt;

    posOut.data[i] = vec4<f32>(p, radiate_mag);
    velOut.data[i] = vec4<f32>(v, 0.0);
  }
}
`;

        const renderWGSL = /* wgsl */`
struct Matrices {
  projection: mat4x4<f32>,
  view: mat4x4<f32>,
  viewportSize: vec2<f32>,
  sizeScale: f32,
  _pad: f32,
}

struct Vec4Buffer { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }

@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<uniform> mats: Matrices;
@group(0) @binding(2) var<storage, read> comIn: Single;

struct VSOut {
  @builtin(position) position: vec4<f32>,
  @location(0) radiate: f32,
  @location(1) corner: vec2<f32>,
}

@vertex
fn vs_main(@location(0) corner: vec2<f32>, @builtin(instance_index) instance: u32) -> VSOut {
  let pos4 = positions.data[instance];
  let c = comIn.data.xyz;
  let world = vec4<f32>(pos4.xyz - c, 1.0);
  let viewPos = mats.view * world;
  let clipCenter = mats.projection * viewPos;

  // screen-space billboard using NDC offset scaled by clip.w
  let sizePx = max(2.0, mats.sizeScale / max(1.0, -viewPos.z));
  let offsetNDC = (corner * sizePx) * vec2<f32>(2.0 / mats.viewportSize.x, 2.0 / mats.viewportSize.y);
  let offset = offsetNDC * clipCenter.w;

  var out: VSOut;
  out.position = vec4<f32>(clipCenter.xy + offset, clipCenter.zw);
  out.radiate = pos4.w;
  out.corner = corner;
  return out;
}

@fragment
fn fs_main(@location(0) radiate: f32, @location(1) corner: vec2<f32>) -> @location(0) vec4<f32> {
  let rad = clamp(5.0 * radiate, 0.0, 1.0);
  let r = length(corner);
  if (r > 1.0) { discard; }
  let alpha = smoothstep(0.7, 0.0, r);
  return vec4<f32>(rad, 0.5, 1.0 - rad, alpha);
}
`;

        // ---- Pipelines ----
        const computeModule = device.createShaderModule({ code: computeWGSL });
        const computePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: { module: computeModule, entryPoint: 'main' }
        });

        const renderModule = device.createShaderModule({ code: renderWGSL });
        // Quad geometry for billboard (two triangles)
        const quadVerts = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1,
        ]);
        const quadIdx = new Uint16Array([0,1,2, 2,1,3]);
        const quadVB = device.createBuffer({ size: quadVerts.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(quadVB, 0, quadVerts.buffer, quadVerts.byteOffset, quadVerts.byteLength);
        const quadIB = device.createBuffer({ size: quadIdx.byteLength, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(quadIB, 0, quadIdx.buffer, quadIdx.byteOffset, quadIdx.byteLength);

        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: renderModule,
                entryPoint: 'vs_main',
                buffers: [{ arrayStride: 2 * 4, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] }]
            },
            fragment: {
                module: renderModule,
                entryPoint: 'fs_main',
                targets: [{
                    format,
                    blend: {
                        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                    }
                }]
            },
            primitive: { topology: 'triangle-list', cullMode: 'none' }
        });

        // ---- Bind Groups ----
        function createComputeBindGroup(posInBuf, velInBuf, posOutBuf, velOutBuf) {
            return device.createBindGroup({
                layout: computePipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: posInBuf } },
                    { binding: 1, resource: { buffer: velInBuf } },
                    { binding: 2, resource: { buffer: posOutBuf } },
                    { binding: 3, resource: { buffer: velOutBuf } },
                    { binding: 4, resource: { buffer: simParamsBuffer } },
                    { binding: 5, resource: { buffer: comBuffer } },
                ]
            });
        }
        let computeBG_AtoB = createComputeBindGroup(posA, velA, posB, velB);
        let computeBG_BtoA = createComputeBindGroup(posB, velB, posA, velA);

        function createRenderBindGroup(posBuf) {
            return device.createBindGroup({
                layout: renderPipeline.getBindGroupLayout(0),
                entries: [
                    { binding: 0, resource: { buffer: posBuf } },
                    { binding: 1, resource: { buffer: matricesBuffer } },
                    { binding: 2, resource: { buffer: comBuffer } },
                ]
            });
        }
        let renderBG_posA = createRenderBindGroup(posA);
        let renderBG_posB = createRenderBindGroup(posB);

        // ---- Main Loop ----
        let readFromA = true; // indicates which buffers hold the latest state

        function updateDebug() {
            const currentTime = performance.now();
            const elapsedSeconds = (currentTime - startTime) / 1000;
            const fps = loopCount / elapsedSeconds;
            let debugText = '<strong>Simulation Stats:</strong><br>' +
                            `Frame: ${loopCount}<br>` +
                            `Runtime: ${elapsedSeconds.toFixed(1)}s<br>` +
                            `FPS: ${fps.toFixed(1)}<br>`;
            debugDiv.innerHTML = debugText;
        }

        function frame() {
            // Match nbody2.html timing tweaks
            if (loopCount === 10) { damping = 1.0; dampingSlider.value = damping.toFixed(2); dampingValueDisplay.textContent = damping.toFixed(2); writeSimParams(); }
            if (loopCount === 150) { spin = 0.0; spinSlider.value = spin.toFixed(2); spinValueDisplay.textContent = spin.toFixed(2); writeSimParams(); }

            // Update matrices if size changed
            projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000000);
            writeMatrices();

            const encoder = device.createCommandEncoder();

            // Compute center of mass for spin center (using current read buffer)
            {
              const bg1 = readFromA ? comReduce1BG_A : comReduce1BG_B;
              const p1 = encoder.beginComputePass();
              p1.setPipeline(comReduce1Pipeline);
              p1.setBindGroup(0, bg1);
              p1.dispatchWorkgroups(numComPartials);
              p1.end();

              const p2 = encoder.beginComputePass();
              p2.setPipeline(comReduce2Pipeline);
              p2.setBindGroup(0, comReduce2BG);
              p2.dispatchWorkgroups(1);
              p2.end();
            }

            // Per-substep params: dt and damping scaled
            const dtSub = DT / SUBSTEPS;
            const dampingSub = Math.pow(damping, 1.0 / SUBSTEPS);
            simParamsData[0] = dtSub;      // dt
            simParamsData[1] = G;          // G (unchanged)
            simParamsData[2] = R;          // R (unchanged)
            simParamsData[3] = spin;       // spin (unchanged)
            simParamsData[4] = EPS;        // eps (unchanged)
            simParamsData[5] = dampingSub; // per-substep damping
            simParamsData[6] = particleCount;
            simParamsData[7] = radiateCoeff; // radiative damping
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData.buffer, simParamsData.byteOffset, simParamsData.byteLength);

            // Compute passes: SUBSTEPS sub-iterations, ping-ponging A/B
            let localReadFromA = readFromA;
            const workgroupSize = 256;
            const workgroupCount = Math.ceil(particleCount / workgroupSize);
            for (let s = 0; s < SUBSTEPS; s++) {
                const cpass = encoder.beginComputePass();
                cpass.setPipeline(computePipeline);
                cpass.setBindGroup(0, localReadFromA ? computeBG_AtoB : computeBG_BtoA);
                cpass.dispatchWorkgroups(workgroupCount);
                cpass.end();
                localReadFromA = !localReadFromA;
            }

            // Recompute center of mass for rendering (using latest state)
            {
              const bg1 = localReadFromA ? comReduce1BG_B : comReduce1BG_A; // latest written buffer
              const p1 = encoder.beginComputePass();
              p1.setPipeline(comReduce1Pipeline);
              p1.setBindGroup(0, bg1);
              p1.dispatchWorkgroups(numComPartials);
              p1.end();

              const p2 = encoder.beginComputePass();
              p2.setPipeline(comReduce2Pipeline);
              p2.setBindGroup(0, comReduce2BG);
              p2.dispatchWorkgroups(1);
              p2.end();
            }

            // Render pass after last substep
            const colorView = context.getCurrentTexture().createView();
            const rpass = encoder.beginRenderPass({
                colorAttachments: [{ view: colorView, clearValue: { r:0, g:0, b:0, a:1 }, loadOp: 'clear', storeOp: 'store' }]
            });
            rpass.setPipeline(renderPipeline);
            rpass.setVertexBuffer(0, quadVB);
            rpass.setIndexBuffer(quadIB, 'uint16');
            rpass.setBindGroup(0, localReadFromA ? renderBG_posB : renderBG_posA); // latest is the write buffer from final substep
            rpass.drawIndexed(6, particleCount, 0, 0, 0);
            rpass.end();

            device.queue.submit([encoder.finish()]);

            // Update global readFromA for next frame
            readFromA = localReadFromA;

            loopCount++;
            updateDebug();
            requestAnimationFrame(frame);
        }
        frame();
    })();
    </script>
</body>

</html>
