<!DOCTYPE html>
<!--
  Copyright (c) 2025 Jason Nyberg
  Licensed under the GPL 3.0 License
  See LICENSE for details
-->
<html>

<head>
    <meta charset="UTF-8">
    <title>3D N-Body Simulation – WebGPU</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { width: 100vw; height: 100vh; display: block; }
        #debug { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.7); color: white; font-family: monospace; padding: 10px; max-height: 90vh; overflow-y: auto; font-size: 12px; }
    </style>
</head>

<body>
    <canvas id="glcanvas"></canvas>
    <div id="debug"></div>
    <div style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="gSlider">G: <span id="gValue">0.2</span></label><br>
        <input type="range" id="gSlider" min="0.01" max="5.0" step="0.01" value="0.3">
    </div>
    <div style="position: fixed; top: 60px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="dampingSlider">Damping: <span id="dampingValue">1.0</span></label><br>
        <input type="range" id="dampingSlider" min="0.0" max="1.0" step="0.01" value="1.0">
    </div>
    <div style="position: fixed; top: 110px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="spinSlider">Spin: <span id="spinValue">0.0</span></label><br>
        <input type="range" id="spinSlider" min="-1.0" max="1.0" step="0.01" value="0.0">
    </div>
    <div style="position: fixed; top: 160px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="radiateSlider">Radiative: <span id="radiateValue">0.005</span></label><br>
        <input type="range" id="radiateSlider" min="0.0" max="0.1" step="0.001" value="0.005">
    </div>
    <div style="position: fixed; top: 210px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="fusionSlider">Fusion: <span id="fusionValue">0.01</span></label><br>
        <input type="range" id="fusionSlider" min="0.01" max="5.00" step="0.01" value="0.01">
    </div>
    <div style="position: fixed; top: 260px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="timestepSlider">Timestep: <span id="timestepValue">0.2</span></label><br>
        <input type="range" id="timestepSlider" min="0.01" max="1.0" step="0.01" value="0.2">
    </div>
    <!-- New: Substeps slider -->
    <div style="position: fixed; top: 310px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="substepsSlider">Substeps: <span id="substepsValue">4</span></label><br>
        <input type="range" id="substepsSlider" min="1" max="16" step="1" value="4">
    </div>
    <!-- New: Fusion energy/decay controls -->
    <div style="position: fixed; top: 360px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="boostSlider">Fusion Boost: <span id="boostValue">2.0</span></label><br>
        <input type="range" id="boostSlider" min="1.0" max="5.0" step="0.1" value="2.0">
    </div>
    <div style="position: fixed; top: 410px; right: 10px; background: rgba(0,0,0,0.7); padding: 10px; color: white;">
        <label for="decaySlider">Decay Half-life: <span id="decayValue">1.0</span></label><br>
        <input type="range" id="decaySlider" min="0.05" max="10.0" step="0.05" value="1.0">
    </div>

    <script type="text/javascript">
    "use strict";

    (async () => {
        const canvas = document.getElementById("glcanvas");
        const debugDiv = document.getElementById('debug');

        if (!('gpu' in navigator)) {
            alert('WebGPU not supported in this browser.');
            return;
        }

        const adapter = await navigator.gpu.requestAdapter({ powerPreference: 'high-performance' })
            || await navigator.gpu.requestAdapter();
        if (!adapter) { alert('Failed to get GPU adapter'); return; }
        const device = await adapter.requestDevice();
        const context = canvas.getContext('webgpu');
        const format = navigator.gpu.getPreferredCanvasFormat();

        function resizeCanvas() {
            //const dpr = 1; // force DPR=1 for performance; set to window.devicePixelRatio for full res
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = Math.floor(canvas.clientWidth * dpr);
            canvas.height = Math.floor(canvas.clientHeight * dpr);
            context.configure({ device, format, alphaMode: 'premultiplied' });
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // ---- Simulation Parameters ----
        const NUM_PARTICLES = 128*100; // must be multiple of 100 per original
        let G = 0.3;
        const R = 10000.0;
        let spin = 0.3;
        const EPS = 0.001;
        let damping = 0.9;
        const stride = 4; // vec4 per particle
        const radius = 1000.0;
        const cam_dist = 1000.0;
        // Changed: SUBSTEPS is now runtime-adjustable via UI
        let SUBSTEPS = 4; // physics substeps per rendered frame
        let radiateCoeff = 0.005; // radiative damping coefficient
        // Replaced DT + dtMultiplier with a configurable base timestep
        let baseDt = 0.2;   // timestep per frame before substepping; slider controls this directly
        let loopCount = 0;
        const startTime = performance.now();
        let lastFrameMs = 0;
        // Fusion parameters
        const FUSE_RADIUS = 3.0; // distance threshold for fusion (simulation units)
        const FUSE_MIN_REL_SPEED = 0.1; // minimum relative speed to be considered a "smash"
        let fusionFactor = 0.01; // user-controlled fusion ease factor (higher = easier to fuse)
        // New: defaults for fusion energy emission/decay controls
        let fusionBoost = 2.0;     // default boost factor applied on fusion
        let decayHalfLife = 1.0;   // seconds; half-life for repulsion decay

        // UI wiring
        const gSlider = document.getElementById('gSlider');
        const gValueDisplay = document.getElementById('gValue');
        gSlider.addEventListener('input', (e) => { G = parseFloat(e.target.value); gValueDisplay.textContent = G.toFixed(2); writeSimParams(); });
        const dampingSlider = document.getElementById('dampingSlider');
        const dampingValueDisplay = document.getElementById('dampingValue');
        dampingSlider.addEventListener('input', (e) => { damping = parseFloat(e.target.value); dampingValueDisplay.textContent = damping.toFixed(2); writeSimParams(); });
        const spinSlider = document.getElementById('spinSlider');
        const spinValueDisplay = document.getElementById('spinValue');
        spinSlider.addEventListener('input', (e) => { spin = parseFloat(e.target.value); spinValueDisplay.textContent = spin.toFixed(2); writeSimParams(); });
        const radiateSlider = document.getElementById('radiateSlider');
        const radiateValueDisplay = document.getElementById('radiateValue');
        radiateSlider.addEventListener('input', (e) => { radiateCoeff = parseFloat(e.target.value); radiateValueDisplay.textContent = radiateCoeff.toFixed(3); writeSimParams(); });
        const fusionSlider = document.getElementById('fusionSlider');
        const fusionValueDisplay = document.getElementById('fusionValue');
        fusionSlider.addEventListener('input', (e) => { fusionFactor = parseFloat(e.target.value); fusionValueDisplay.textContent = fusionFactor.toFixed(2); writeFusionParams(); });
        const timestepSlider = document.getElementById('timestepSlider');
        const timestepValueDisplay = document.getElementById('timestepValue');
        timestepSlider.addEventListener('input', (e) => {
            baseDt = parseFloat(e.target.value);
            timestepValueDisplay.textContent = baseDt.toFixed(2);
        });
        // New: substeps slider
        const substepsSlider = document.getElementById('substepsSlider');
        const substepsValueDisplay = document.getElementById('substepsValue');
        substepsSlider.addEventListener('input', (e) => {
            SUBSTEPS = parseInt(e.target.value, 10);
            substepsValueDisplay.textContent = SUBSTEPS.toString();
            writeSimParams();
        });
        // New: fusion boost slider
        const boostSlider = document.getElementById('boostSlider');
        const boostValueDisplay = document.getElementById('boostValue');
        boostSlider.addEventListener('input', (e) => {
            fusionBoost = Math.max(1.0, parseFloat(e.target.value));
            boostValueDisplay.textContent = fusionBoost.toFixed(1);
        });
        // New: decay half-life slider
        const decaySlider = document.getElementById('decaySlider');
        const decayValueDisplay = document.getElementById('decayValue');
        decaySlider.addEventListener('input', (e) => {
            decayHalfLife = Math.max(0.001, parseFloat(e.target.value));
            decayValueDisplay.textContent = decayHalfLife.toFixed(2);
        });

        // Ensure initial values are reflected in UI at startup (uniforms are written later after buffers are created)
        gSlider.value = G.toFixed(2);
        gValueDisplay.textContent = G.toFixed(2);
        fusionSlider.value = fusionFactor.toFixed(2);
        fusionValueDisplay.textContent = fusionFactor.toFixed(2);
        timestepSlider.value = baseDt.toFixed(2);
        timestepValueDisplay.textContent = baseDt.toFixed(2);
        // Initialize remaining sliders to current values
        dampingSlider.value = damping.toFixed(2);
        dampingValueDisplay.textContent = damping.toFixed(2);
        spinSlider.value = spin.toFixed(2);
        spinValueDisplay.textContent = spin.toFixed(2);
        radiateSlider.value = radiateCoeff.toFixed(3);
        radiateValueDisplay.textContent = radiateCoeff.toFixed(3);
        // New: initialize substeps UI
        substepsSlider.value = SUBSTEPS.toString();
        substepsValueDisplay.textContent = SUBSTEPS.toString();
        // New: initialize emission UI
        boostSlider.value = fusionBoost.toFixed(1);
        boostValueDisplay.textContent = fusionBoost.toFixed(1);
        decaySlider.value = decayHalfLife.toFixed(2);
        decayValueDisplay.textContent = decayHalfLife.toFixed(2);

        // ---- Helpers ----
        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) * nf, -1,
                0, 0, (2 * far * near) * nf, 0
            ]);
        }
        function lookAt(eye, center, up) {
            const f = normalize(subtract(center, eye));
            const s = normalize(cross(f, up));
            const u = cross(s, f);
            return new Float32Array([
                s[0], u[0], -f[0], 0,
                s[1], u[1], -f[1], 0,
                s[2], u[2], -f[2], 0,
                -dot(s, eye), -dot(u, eye), dot(f, eye), 1
            ]);
        }
        function subtract(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
        function normalize(v) { const l = Math.hypot(v[0], v[1], v[2]); return [v[0]/l, v[1]/l, v[2]/l]; }
        function cross(a, b) { return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]]; }
        function dot(a, b) { return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]; }

        let projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000000);
        let viewMatrix = lookAt([0, cam_dist/3, cam_dist], [0, 0, 0], [0, 1, 0]);

        // ---- GPU Buffers (positions/velocities ping-pong) ----
        const particleCount = NUM_PARTICLES;
        const stateByteSize = particleCount * stride * 4; // 4 bytes per float
        function createBufferFromArray(arr, usage) {
            const buffer = device.createBuffer({ size: arr.byteLength, usage, mappedAtCreation: true });
            new Float32Array(buffer.getMappedRange()).set(arr);
            buffer.unmap();
            return buffer;
        }
        function createEmptyBuffer(size, usage) {
            return device.createBuffer({ size, usage });
        }

        // Initialize CPU-side state
        const posInit = new Float32Array(particleCount * stride);
        const velInit = new Float32Array(particleCount * stride);
        for (let i = 0; i < particleCount; i++) {
            const ti = i * stride;
            let x, y, z;
            do {
                x = (Math.random() - 0.5) * 2 * radius;
                y = (Math.random() - 0.5) * 2 * radius;
                z = (Math.random() - 0.5) * 2 * radius;
            } while (x*x + y*y + z*z > radius*radius);
            posInit[ti+0] = x; posInit[ti+1] = y; posInit[ti+2] = z; posInit[ti+3] = 0.0; // radiate accumulator
            velInit[ti+0] = 0.0; velInit[ti+1] = 0.0; velInit[ti+2] = 0.0; velInit[ti+3] = 0.0;
        }

        let posA = createBufferFromArray(posInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        let posB = createEmptyBuffer(stateByteSize, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
        let velA = createBufferFromArray(velInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        let velB = createEmptyBuffer(stateByteSize, GPUBufferUsage.STORAGE);

        // ---- Mass Buffer ----
        // Initialize all particle masses to 1.0 (uniform masses)
        const massesInit = new Float32Array(particleCount);
        massesInit.fill(1.0);
        const maxMass = 1.0;
        const massSum = particleCount * 1.0;
        const avgMass = 1.0;
        // Physics mass scale with uniform masses is 1
        const massScale = 1.0;
        const massBuffer = createBufferFromArray(massesInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        // Fusion claims buffer (atomic flags) and params
        const claimsBuffer = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        const zeroClaims = new Uint32Array(particleCount); // reused each frame to clear claims
        const fusionParamsData = new Float32Array([FUSE_RADIUS, FUSE_MIN_REL_SPEED, fusionFactor, 0]);
        const fusionParamsBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeFusionParams() {
            fusionParamsData[0] = FUSE_RADIUS;
            fusionParamsData[1] = FUSE_MIN_REL_SPEED;
            fusionParamsData[2] = fusionFactor;
            fusionParamsData[3] = 0.0;
            device.queue.writeBuffer(fusionParamsBuffer, 0, fusionParamsData.buffer, fusionParamsData.byteOffset, fusionParamsData.byteLength);
        }
        writeFusionParams();
        // New: per-frame fuse flags for flash visualization
        const fuseFlagsBuffer = device.createBuffer({ size: particleCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        const zeroFuseFlags = new Float32Array(particleCount);
        // New: per-particle extra repulsion factors (>= 1.0); boosted on fusion and decays each physics pass
        const repulseInit = new Float32Array(particleCount); repulseInit.fill(1.0);
        const repulseBuffer = createBufferFromArray(repulseInit, GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
        // New: emission params uniform (boost, decayFactor)
        const emissionParamsData = new Float32Array([fusionBoost, 1.0, 0.0, 0.0]);
        const emissionParamsBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeEmissionParams() {
            emissionParamsData[0] = fusionBoost;
            emissionParamsData[1] = decayHalfLife;
            device.queue.writeBuffer(emissionParamsBuffer, 0, emissionParamsData.buffer, emissionParamsData.byteOffset, emissionParamsData.byteLength);
        }
        writeEmissionParams();
        // New: dynamic mass stats (active count and max mass) computed on GPU each frame
        const totalMass = massSum;
        let dynActiveCount = particleCount;
        let dynMaxMass = maxMass;
        const statsBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });
        // Triple-buffer readback to avoid mapped-buffer hazards
        const NUM_READBACK = 3;
        const statsReadBuffers = Array.from({ length: NUM_READBACK }, () =>
            device.createBuffer({ size: 16, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST })
        );
        const statsPendingMap = new Array(NUM_READBACK).fill(false);
        let statsWriteIndex = 0;     // next preferred write target
        let lastCopiedIndex = -1;    // index written last frame (to read this frame)

        // ---- Uniform Buffers ----
        // Sim params: [dt, G, R, spin, eps, damping, numParticlesF, radiateCoeff]
        const simParamsData = new Float32Array([baseDt, G, R, spin, EPS, damping, particleCount, radiateCoeff]);
        const simParamsBuffer = device.createBuffer({ size: simParamsData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        function writeSimParams() {
            // Do not scale G by massScale; keep R scaled to balance repulsion if desired
            simParamsData[0] = baseDt;
            simParamsData[1] = G;           // G unscaled
            simParamsData[2] = R / massScale; // R scaled (unchanged)
            simParamsData[3] = spin / SUBSTEPS; // spin scaled by inverse of SUBSTEPS
            simParamsData[4] = EPS;
            simParamsData[5] = damping;
            simParamsData[6] = particleCount;
            simParamsData[7] = radiateCoeff;
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData.buffer, simParamsData.byteOffset, simParamsData.byteLength);
        }
        writeSimParams();

        // Matrices + viewport: projection(16) + view(16) + viewportSize(2) + sizeScale + pad = 36 floats
        const matricesData = new Float32Array(36);
        function writeMatrices() {
            matricesData.set(projMatrix, 0);
            matricesData.set(viewMatrix, 16);
            matricesData[32] = canvas.width;
            matricesData[33] = canvas.height;
            matricesData[34] = 5000.0; // size scale (matches WebGL version)
            // Use log mapping for mass normalization to improve dynamic range in color/size
            const maxForNorm = Math.max(8.0, dynMaxMass); // assume max mass is at least 8
            const invLogMax = 1.0 / Math.log(1.0 + maxForNorm);
            matricesData[35] = invLogMax; // packed parameter for render normalization
            device.queue.writeBuffer(matricesBuffer, 0, matricesData.buffer, matricesData.byteOffset, matricesData.byteLength);
        }
        const matricesBuffer = device.createBuffer({ size: matricesData.byteLength, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        writeMatrices();

        // Center-of-mass buffers and pipelines
        const COM_WG = 256;
        const numComPartials = Math.ceil(particleCount / COM_WG);
        const comPartialsBuffer = device.createBuffer({ size: numComPartials * 16, usage: GPUBufferUsage.STORAGE });
        const comBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE });
        const smoothComBuffer = device.createBuffer({ size: 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        // Initialize smoothed COM to origin
        device.queue.writeBuffer(smoothComBuffer, 0, new Float32Array([0, 0, 0, 1]));

        const comReduce1WGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
struct Partials { data: array<vec4<f32>>, }
@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read_write> partials: Partials;
@group(0) @binding(2) var<uniform> params: SimParams;
@group(0) @binding(3) var<storage, read> masses: FloatBuffer;
const WG: u32 = 256u;
var<workgroup> s: array<vec4<f32>, WG>; // xyz = sum(m*pos), w = sum(m)
@compute @workgroup_size(256)
fn main(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = wid.x * WG + lid.x;
  let n = u32(params.numParticlesF);
  var accum = vec4<f32>(0.0);
  if (i < n) {
    let p = positions.data[i].xyz;
    let m = masses.data[i];
    accum = vec4<f32>(p * m, m);
  }
  s[lid.x] = accum;
  workgroupBarrier();
  var stride: u32 = WG / 2u;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) { s[lid.x] = s[lid.x] + s[lid.x + stride]; }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) { partials.data[wid.x] = s[0u]; }
}
`;
        const comReduce2WGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct Partials { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> partials: Partials;
@group(0) @binding(1) var<storage, read_write> comOut: Single;
@group(0) @binding(2) var<uniform> params: SimParams;
const WG: u32 = 256u;
var<workgroup> s: array<vec4<f32>, WG>; // xyz = sum(m*pos), w = sum(m)
@compute @workgroup_size(256)
fn main(@builtin(local_invocation_id) lid: vec3<u32>) {
  let n = u32(params.numParticlesF);
  let numPartials = (n + WG - 1u) / WG;
  var sum = vec4<f32>(0.0);
  var j = lid.x;
  loop {
    if (j >= numPartials) { break; }
    sum = sum + partials.data[j];
    j = j + WG;
  }
  s[lid.x] = sum;
  workgroupBarrier();
  var stride: u32 = WG / 2;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) { s[lid.x] = s[lid.x] + s[lid.x + stride]; }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) {
    let invM = select(0.0, 1.0 / s[0u].w, s[0u].w > 0.0);
    let com = s[0u].xyz * invM;
    // Store total mass in w for downstream camera tracker
    comOut.data = vec4<f32>(com, s[0u].w);
  }
}
`;
        const comReduce1Module = device.createShaderModule({ code: comReduce1WGSL });
        const comReduce1Pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comReduce1Module, entryPoint: 'main' } });
        const comReduce2Module = device.createShaderModule({ code: comReduce2WGSL });
        const comReduce2Pipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comReduce2Module, entryPoint: 'main' } });

        // Bind groups for COM reduction (per position buffer)
        const comReduce1BG_A = device.createBindGroup({
            layout: comReduce1Pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: comPartialsBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
                { binding: 3, resource: { buffer: massBuffer } },
            ],
        });
        const comReduce1BG_B = device.createBindGroup({
            layout: comReduce1Pipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: comPartialsBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
                { binding: 3, resource: { buffer: massBuffer } },
            ],
        });

        const comReduce2BG = device.createBindGroup({
            layout: comReduce2Pipeline.getBindGroupLayout(0),
            entries:
            [
                { binding: 0, resource: { buffer: comPartialsBuffer } },
                { binding: 1, resource: { buffer: comBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
            ]
        });

        // Smooth COM (exponential smoothing once per frame)
        const comSmoothWGSL = /* wgsl */`
struct Single { data: vec4<f32>, }
@group(0) @binding(0) var<storage, read> comIn: Single;
@group(0) @binding(1) var<storage, read_write> smoothOut: Single;
@compute @workgroup_size(1)
fn main() {
  let c = comIn.data.xyz;
  let s0 = smoothOut.data.xyz;
  let alpha: f32 = 0.10; // smoothing factor per rendered frame
  let s1 = s0 + (c - s0) * alpha; // linear interpolation
  smoothOut.data = vec4<f32>(s1, 1.0);
}
`;
        const comSmoothModule = device.createShaderModule({ code: comSmoothWGSL });
        const comSmoothPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: comSmoothModule, entryPoint: 'main' } });
        const comSmoothBG = device.createBindGroup({
            layout: comSmoothPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: comBuffer } },
                { binding: 1, resource: { buffer: smoothComBuffer } },
            ]
        });

        // ---- Shaders (WGSL) ----
        const computeWGSL = /* wgsl */`
struct SimParams {
  dt: f32,
  G: f32,
  R: f32,
  spin: f32,
  eps: f32,
  damping: f32,
  numParticlesF: f32,
  radiateCoeff: f32,
}

struct Vec4Buffer { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
struct FloatBuffer { data: array<f32>, }
struct EmissionParams { boost: f32, decayFactor: f32, _pad0: f32, _pad1: f32 }

@group(0) @binding(0) var<storage, read> posIn: Vec4Buffer;
@group(0) @binding(1) var<storage, read> velIn: Vec4Buffer;
@group(0) @binding(2) var<storage, read_write> posOut: Vec4Buffer;
@group(0) @binding(3) var<storage, read_write> velOut: Vec4Buffer;
@group(0) @binding(4) var<uniform> params: SimParams;
@group(0) @binding(5) var<storage, read> comIn: Single;
@group(0) @binding(6) var<storage, read> masses: FloatBuffer;
@group(0) @binding(7) var<storage, read_write> repulse: FloatBuffer; // extra repulsion factor per particle
@group(0) @binding(8) var<uniform> emission: EmissionParams;

const TILE_SIZE: u32 = 256u;
var<workgroup> tilePos: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileVel: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileMass: array<f32, TILE_SIZE>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id)  lid: vec3<u32>) {
  let i: u32 = gid.x;
  let n: u32 = u32(params.numParticlesF);
  let isActive: bool = i < n;

  // Hoist invariants
  let eps2: f32 = params.eps * params.eps;
  let Gc: f32 = params.G;
  let Rc: f32 = params.R;
  let Rcvt: f32 = params.radiateCoeff;
  let com: vec3<f32> = comIn.data.xyz;

  var pos: vec3<f32> = vec3<f32>(0.0);
  var vel: vec3<f32> = vec3<f32>(0.0);
  var mi: f32 = 1.0;
  var repulse_i: f32 = 1.0;
  if (isActive) {
    pos = posIn.data[i].xyz;
    vel = velIn.data[i].xyz;
    mi = masses.data[i];
    repulse_i = repulse.data[i];
  }
  let hasMass: bool = isActive && (mi > 0.0);

  // Accumulate acceleration directly (avoid multiplying by mi and dividing later)
  var acc: vec3<f32> = vec3<f32>(0.0);
  var radiate_mag: f32 = 0.0;

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }

    // Load a tile of j-particles into shared memory
    let jIndex = base + lid.x;
    if (jIndex < n) {
      tilePos[lid.x] = posIn.data[jIndex];
      tileVel[lid.x] = velIn.data[jIndex];
      tileMass[lid.x] = masses.data[jIndex];
    } else {
      tilePos[lid.x] = vec4<f32>(0.0);
      tileVel[lid.x] = vec4<f32>(0.0);
      tileMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remaining: u32 = n - base;
    var tileCount: u32 = TILE_SIZE;
    if (remaining < TILE_SIZE) { tileCount = remaining; }

    // Only massive particles accumulate forces; zero-mass particles do nothing
    if (hasMass) {
      var k: u32 = 0u;
      loop {
        if (k >= tileCount) { break; }
        let jGlobal = base + k;
        if (jGlobal != i) {
          let mj = tileMass[k];
          if (mj > 0.0) {
            let pj = tilePos[k].xyz;
            let vj = tileVel[k].xyz;
            let diff = pj - pos;

            // Plummer-type softening for both attraction and repulsion
            let dist2 = dot(diff, diff);
            let soft2 = dist2 + eps2;
            let invSoft = inverseSqrt(soft2);
            let dir = diff * invSoft;               // normalized direction
            let invSoft2 = invSoft * invSoft;       // 1/soft^2
            let invSoft6 = invSoft2 * invSoft2 * invSoft2; // 1/soft^6

            // Acceleration magnitudes (depend only on mj)
            let a_attract = Gc * mj * invSoft2;
            let a_repulse = (Rc * mj * invSoft6) * max(1.0, repulse_i);

            // Radiative damping modeled as acceleration
            var a_radiate: f32 = 0.0;
            if (a_repulse > a_attract) {
              let closingSpeed = dot(diff, vel - vj);
              a_radiate = Rcvt * closingSpeed * invSoft; // acceleration units
            }

            let a_net = a_attract - a_repulse - a_radiate;
            radiate_mag = radiate_mag + abs(a_radiate);
            acc = acc + dir * a_net;
          }
        }
        k = k + 1u;
      }
    }

    workgroupBarrier();
    base = base + TILE_SIZE;
  }

  if (isActive) {
    // Spin acceleration in XZ plane (independent of particle mass)
    var spinAccel: vec3<f32> = vec3<f32>(0.0);
    if (params.spin != 0.0) {
      let rel = pos - com;
      let posXZ = rel.xz;
      let d2 = dot(posXZ, posXZ);
      if (d2 > 0.0) {
        let invd = inverseSqrt(d2);
        let tangent = vec2<f32>(-posXZ.y, posXZ.x);
        spinAccel = vec3<f32>(tangent.x, 0.0, tangent.y) * (params.spin * invd);
        let loA = vec3<f32>(-1000.0);
        let hiA = vec3<f32>( 1000.0);
        spinAccel = clamp(spinAccel, loA, hiA);
      }
    }

    if (hasMass) {
      // Integrate with acceleration directly (no divide by mi)
      var v = (vel + (acc + spinAccel) * params.dt) * params.damping;
      var p = pos + v * params.dt;
      posOut.data[i] = vec4<f32>(p, radiate_mag);
      velOut.data[i] = vec4<f32>(v, 0.0);
    } else {
      // Zero-mass particles: do not integrate, do not act as test particles
      posOut.data[i] = posIn.data[i];
      velOut.data[i] = velIn.data[i];
    }

    // Decay extra repulsion factor toward 1.0 each physics pass using per-substep decayFactor
    let excess = max(0.0, repulse_i - 1.0);
    let decayed = excess * emission.decayFactor;
    repulse.data[i] = 1.0 + decayed;
  }
}
`;

        // Fusion compute (runs after integration) — merges when repulsive force dominates beyond a threshold and particles are approaching; zero-mass excluded
        const fusionWGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct FusionParams { fuseRadius: f32, minRelSpeed: f32, fusionFactor: f32, _pad: f32 }
struct Vec4Buffer { data: array<vec4<f32>>, }
struct FloatBuffer { data: array<f32>, }
struct Claims { data: array<atomic<u32>>, }
struct EmissionParams { boost: f32, decayFactor: f32, _pad0: f32, _pad1: f32 }

@group(0) @binding(0) var<storage, read_write> positions: Vec4Buffer;
@group(0) @binding(1) var<storage, read_write> velocities: Vec4Buffer;
@group(0) @binding(2) var<storage, read_write> masses: FloatBuffer;
@group(0) @binding(3) var<uniform> params: SimParams;
@group(0) @binding(4) var<uniform> fparams: FusionParams;
@group(0) @binding(5) var<storage, read_write> claims: Claims;
@group(0) @binding(6) var<storage, read_write> fuseFlags: FloatBuffer; // new: flash flags
@group(0) @binding(7) var<storage, read_write> repulse: FloatBuffer;   // new: extra repulsion factor
@group(0) @binding(8) var<uniform> emission: EmissionParams;           // boost/decay params

const TILE_SIZE: u32 = 256u;
var<workgroup> tilePos: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileVel: array<vec4<f32>, TILE_SIZE>;
var<workgroup> tileMass: array<f32, TILE_SIZE>;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) gid: vec3<u32>,
        @builtin(local_invocation_id) lid: vec3<u32>) {
  let i: u32 = gid.x;
  let n: u32 = u32(params.numParticlesF);
  let inBounds: bool = i < n;

  var mi0: f32 = 0.0;
  var canFuse: bool = false;
  var p_i: vec3<f32> = vec3<f32>(0.0);
  var v_i: vec3<f32> = vec3<f32>(0.0);
  if (inBounds) {
    mi0 = masses.data[i];
    p_i = positions.data[i].xyz;
    v_i = velocities.data[i].xyz;
    if (mi0 > 0.0 && atomicLoad(&claims.data[i]) == 0u) {
      canFuse = true;
    }
  }

  var bestJ: u32 = i;
  var bestD2: f32 = 1e30;
  var found: bool = false;

  var base: u32 = 0u;
  loop {
    if (base >= n) { break; }
    let jIndex = base + lid.x;
    if (jIndex < n) {
      tilePos[lid.x] = positions.data[jIndex];
      tileVel[lid.x] = velocities.data[jIndex];
      tileMass[lid.x] = masses.data[jIndex];
    } else {
      tilePos[lid.x] = vec4<f32>(0.0);
      tileVel[lid.x] = vec4<f32>(0.0);
      tileMass[lid.x] = 0.0;
    }
    workgroupBarrier();

    let remaining: u32 = n - base;
    var tileCount: u32 = TILE_SIZE;
    if (remaining < TILE_SIZE) { tileCount = remaining; }

    var k: u32 = 0u;
    loop {
      if (k >= tileCount) { break; }
      let j: u32 = base + k;
      if (canFuse && j != i) {
        let mj = tileMass[k];
        if (mj > 0.0) {
          let dp = tilePos[k].xyz - p_i;
          let d2 = dot(dp, dp);

          // Softened distance terms
          let eps2 = params.eps * params.eps;
          let soft2 = d2 + eps2;
          let invSoft = inverseSqrt(soft2);
          let invSoft2 = invSoft * invSoft;
          let invSoft6 = invSoft2 * invSoft2 * invSoft2;
          let Gc = params.G;
          let Rc = params.R;

          // Use mass-independent magnitudes for comparison (mi*mj cancels)
          let attractiveM = Gc * invSoft2;
          let repulsiveM  = Rc * invSoft6;

          // Approaching if distance is shrinking: dp·(v_i - v_j) > 0
          let rel = v_i - tileVel[k].xyz;
          let approaching = dot(dp, rel) > 0.0;

          // Depth threshold (higher fusionFactor => easier to fuse)
          let ratio = repulsiveM / max(attractiveM, 1e-12);
          let req = 1.0 + (1.0 / max(fparams.fusionFactor, 1e-6));

          if (approaching && repulsiveM > attractiveM && ratio >= req) {
            if (!found || d2 < bestD2) {
              bestD2 = d2;
              bestJ = j;
              found = true;
            }
          }
        }
      }
      k = k + 1u;
    }

    workgroupBarrier();
    base = base + TILE_SIZE;
  }

  if (canFuse && found && bestJ != i) {
    // Only lower index survives; avoid mutual merges and races
    if (i < bestJ) {
      let selfLock = atomicCompareExchangeWeak(&claims.data[i], 0u, 2u);
      if (selfLock.exchanged) {
        let jLock = atomicCompareExchangeWeak(&claims.data[bestJ], 0u, 1u);
        if (jLock.exchanged) {
          // Re-read current values and merge conserving momentum and COM
          let mi = masses.data[i];
          let mj = masses.data[bestJ];
          if (mi > 0.0 && mj > 0.0) {
            let pi = positions.data[i].xyz;
            let pj = positions.data[bestJ].xyz;
            let vi = velocities.data[i].xyz;
            let vj = velocities.data[bestJ].xyz;
            let mNew = mi + mj;
            if (mNew > 0.0) {
              let pNew = (pi * mi + pj * mj) / mNew;
              let vNew = (vi * mi + vj * mj) / mNew;
              positions.data[i] = vec4<f32>(pNew, positions.data[i].w);
              velocities.data[i] = vec4<f32>(vNew, 0.0);
              masses.data[i] = mNew;

              masses.data[bestJ] = 0.0;
              velocities.data[bestJ] = vec4<f32>(0.0);

              // Flag survivor for white flash this frame
              fuseFlags.data[i] = 1.0;

              // Boost extra repulsion on survivor to simulate emitted energy using UI-controlled boost
              let boost = max(1.0, emission.boost);
              let cur = repulse.data[i];
              repulse.data[i] = max(cur, boost);
              // Reset consumed particle
              repulse.data[bestJ] = 1.0;
            }
          }
        }
      }
    }
  }
}
`;

        // Add render shader definition before pipelines
        const renderWGSL = /* wgsl */`
struct Matrices {
  projection: mat4x4<f32>,
  view: mat4x4<f32>,
  viewportSize: vec2<f32>,
  sizeScale: f32,
  _pad: f32,
}

struct Vec4Buffer { data: array<vec4<f32>>, }
struct Single { data: vec4<f32>, }
struct FloatBuffer { data: array<f32>, }

@group(0) @binding(0) var<storage, read> positions: Vec4Buffer;
@group(0) @binding(1) var<uniform> mats: Matrices;
@group(0) @binding(2) var<storage, read> comIn: Single;
@group(0) @binding(3) var<storage, read> masses: FloatBuffer;
@group(0) @binding(4) var<storage, read> fuseFlags: FloatBuffer;

struct VSOut {
  @builtin(position) position: vec4<f32>,
  @location(0) radiate: f32,
  @location(1) corner: vec2<f32>,
  @location(2) massNorm: f32,
  @location(3) fused: f32,
}

@vertex
fn vs_main(@location(0) corner: vec2<f32>, @builtin(instance_index) instance: u32) -> VSOut {
  let pos4 = positions.data[instance];
  let m = masses.data[instance];
  if (m <= 0.0) { // Cull in vertex stage to avoid fragment work
    // Place off-screen with zero alpha; fragment will discard by radius anyway
    var o: VSOut;
    o.position = vec4<f32>(-2.0, -2.0, 0.0, 1.0);
    o.radiate = 0.0; o.corner = corner; o.massNorm = 0.0; o.fused = 0.0;
    return o;
  }
  let c = comIn.data.xyz;
  let invLogMax = mats._pad;
  let mNorm = clamp(log(1.0 + m) * invLogMax, 0.0, 1.0);
  let world = vec4<f32>(pos4.xyz - c, 1.0);
  let viewPos = mats.view * world;
  let clipCenter = mats.projection * viewPos;
  let sizePx = max(2.0, (mNorm + 0.2) * mats.sizeScale / max(1.0, -viewPos.z));
  let offsetNDC = (corner * sizePx) * vec2<f32>(2.0 / mats.viewportSize.x, 2.0 / mats.viewportSize.y);
  let offset = offsetNDC * clipCenter.w;
  var out: VSOut;
  out.position = vec4<f32>(clipCenter.xy + offset, clipCenter.zw);
  out.radiate = pos4.w; out.corner = corner; out.massNorm = mNorm; out.fused = fuseFlags.data[instance];
  return out;
}

@fragment
fn fs_main(@location(0) radiate: f32, @location(1) corner: vec2<f32>, @location(2) massNorm: f32, @location(3) fused: f32) -> @location(0) vec4<f32> {
  let r = length(corner); if (r > 1.0) { discard; }
  let alpha = smoothstep(0.7, 0.0, r);
  if (massNorm == 0.0) { discard; } // zero-mass culled
  if (fused > 0.0) { return vec4<f32>(1.0, 1.0, 1.0, alpha); }
  let g = massNorm; let b = 1.0 - massNorm; let rad = clamp(5.0 * radiate, 0.0, 1.0);
  return vec4<f32>(rad, g, b, alpha);
}
`;

        // ---- Pipelines ----
        const computeModule = device.createShaderModule({ code: computeWGSL });
        const computePipeline = device.createComputePipeline({
            layout: 'auto',
            compute: { module: computeModule, entryPoint: 'main' }
        });

        // Fusion pipeline
        const fusionModule = device.createShaderModule({ code: fusionWGSL });
        const fusionPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: fusionModule, entryPoint: 'main' } });

        const renderModule = device.createShaderModule({ code: renderWGSL });
        // Quad geometry for billboard (two triangles)
        const quadVerts = new Float32Array([
            -1, -1,
             1, -1,
            -1,  1,
             1,  1,
        ]);
        const quadIdx = new Uint16Array([0,1,2, 2,1,3]);
        const quadVB = device.createBuffer({ size: quadVerts.byteLength, usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(quadVB, 0, quadVerts.buffer, quadVerts.byteOffset, quadVerts.byteLength);
        const quadIB = device.createBuffer({ size: quadIdx.byteLength, usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST });
        device.queue.writeBuffer(quadIB, 0, quadIdx.buffer, quadIdx.byteOffset, quadIdx.byteLength);

        const renderPipeline = device.createRenderPipeline({
            layout: 'auto',
            vertex: {
                module: renderModule,
                entryPoint: 'vs_main',
                buffers: [{ arrayStride: 2 * 4, attributes: [{ shaderLocation: 0, offset: 0, format: 'float32x2' }] }]
            },
            fragment: {
                module: renderModule,
                entryPoint: 'fs_main',
                targets: [{
                    format,
                    blend: {
                        color: { srcFactor: 'src-alpha', dstFactor: 'one-minus-src-alpha', operation: 'add' },
                        alpha: { srcFactor: 'one', dstFactor: 'one-minus-src-alpha', operation: 'add' }
                    }
                }]
            },
            primitive: { topology: 'triangle-list', cullMode: 'none' }
        });

        // New: Mass stats reduction (active count and max mass)
        const massStatsWGSL = /* wgsl */`
struct SimParams {
  dt: f32, G: f32, R: f32, spin: f32,
  eps: f32, damping: f32, numParticlesF: f32, radiateCoeff: f32,
}
struct FloatBuffer { data: array<f32>, }
struct Stats { activeCount: atomic<u32>, maxMassBits: atomic<u32>, pad0: u32, pad1: u32 }
@group(0) @binding(0) var<storage, read> masses: FloatBuffer;
@group(0) @binding(1) var<storage, read_write> stats: Stats;
@group(0) @binding(2) var<uniform> params: SimParams;
const WG: u32 = 256u;
var<workgroup> sCount: array<u32, WG>;
var<workgroup> sMax: array<f32, WG>;
@compute @workgroup_size(256)
fn main(@builtin(workgroup_id) wid: vec3<u32>, @builtin(local_invocation_id) lid: vec3<u32>) {
  let i = wid.x * WG + lid.x;
  let n = u32(params.numParticlesF);
  var c: u32 = 0u;
  var m: f32 = 0.0;
  if (i < n) {
    let mi = masses.data[i];
    if (mi > 0.0) { c = 1u; m = mi; }
  }
  sCount[lid.x] = c;
  sMax[lid.x] = m;
  workgroupBarrier();
  var stride: u32 = WG / 2u;
  loop {
    if (stride == 0u) { break; }
    if (lid.x < stride) {
      sCount[lid.x] = sCount[lid.x] + sCount[lid.x + stride];
      sMax[lid.x] = max(sMax[lid.x], sMax[lid.x + stride]);
    }
    workgroupBarrier();
    stride = stride / 2u;
  }
  if (lid.x == 0u) {
    atomicAdd(&stats.activeCount, sCount[0u]);
    let bits = bitcast<u32>(sMax[0u]);
    atomicMax(&stats.maxMassBits, bits);
  }
}
`;
        const massStatsModule = device.createShaderModule({ code: massStatsWGSL });
        const massStatsPipeline = device.createComputePipeline({ layout: 'auto', compute: { module: massStatsModule, entryPoint: 'main' } });
        const massStatsBG = device.createBindGroup({
            layout: massStatsPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: massBuffer } },
                { binding: 1, resource: { buffer: statsBuffer } },
                { binding: 2, resource: { buffer: simParamsBuffer } },
            ]
        });

        // Compute bind groups (ping-pong)
        const computeBG_AtoB = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: velA } },
                { binding: 2, resource: { buffer: posB } },
                { binding: 3, resource: { buffer: velB } },
                { binding: 4, resource: { buffer: simParamsBuffer } },
                { binding: 5, resource: { buffer: comBuffer } },
                { binding: 6, resource: { buffer: massBuffer } },
                { binding: 7, resource: { buffer: repulseBuffer } },
                { binding: 8, resource: { buffer: emissionParamsBuffer } },
            ]
        });
        const computeBG_BtoA = device.createBindGroup({
            layout: computePipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: velB } },
                { binding: 2, resource: { buffer: posA } },
                { binding: 3, resource: { buffer: velA } },
                { binding: 4, resource: { buffer: simParamsBuffer } },
                { binding: 5, resource: { buffer: comBuffer } },
                { binding: 6, resource: { buffer: massBuffer } },
                { binding: 7, resource: { buffer: repulseBuffer } },
                { binding: 8, resource: { buffer: emissionParamsBuffer } },
            ]
        });

        // Fusion bind groups (operate on latest state buffers)
        const fusionBG_posA = device.createBindGroup({
            layout: fusionPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: velA } },
                { binding: 2, resource: { buffer: massBuffer } },
                { binding: 3, resource: { buffer: simParamsBuffer } },
                { binding: 4, resource: { buffer: fusionParamsBuffer } },
                { binding: 5, resource: { buffer: claimsBuffer } },
                { binding: 6, resource: { buffer: fuseFlagsBuffer } },
                { binding: 7, resource: { buffer: repulseBuffer } },
                { binding: 8, resource: { buffer: emissionParamsBuffer } },
            ]
        });
        const fusionBG_posB = device.createBindGroup({
            layout: fusionPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: velB } },
                { binding: 2, resource: { buffer: massBuffer } },
                { binding: 3, resource: { buffer: simParamsBuffer } },
                { binding: 4, resource: { buffer: fusionParamsBuffer } },
                { binding: 5, resource: { buffer: claimsBuffer } },
                { binding: 6, resource: { buffer: fuseFlagsBuffer } },
                { binding: 7, resource: { buffer: repulseBuffer } },
                { binding: 8, resource: { buffer: emissionParamsBuffer } },
            ]
        });

        // Render bind groups
        const renderBG_posA = device.createBindGroup({
            layout: renderPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posA } },
                { binding: 1, resource: { buffer: matricesBuffer } },
                { binding: 2, resource: { buffer: smoothComBuffer } },
                { binding: 3, resource: { buffer: massBuffer } },
                { binding: 4, resource: { buffer: fuseFlagsBuffer } },
            ]
        });
        const renderBG_posB = device.createBindGroup({
            layout: renderPipeline.getBindGroupLayout(0),
            entries: [
                { binding: 0, resource: { buffer: posB } },
                { binding: 1, resource: { buffer: matricesBuffer } },
                { binding: 2, resource: { buffer: smoothComBuffer } },
                { binding: 3, resource: { buffer: massBuffer } },
                { binding: 4, resource: { buffer: fuseFlagsBuffer } },
            ]
        });

        // ---- Main Loop ----
        let readFromA = true; // indicates which buffers hold the latest state

        function updateDebug() {
            const currentTime = performance.now();
            const elapsedSeconds = (currentTime - startTime) / 1000;
            const avgActiveMass = totalMass / Math.max(1, dynActiveCount);
            let debugText = '<strong>Simulation Stats:</strong><br>' +
                            `Frame: ${loopCount}<br>` +
                            `Runtime: ${elapsedSeconds.toFixed(1)}s<br>` +
                            `Frame time: ${lastFrameMs.toFixed(2)} ms<br>` +
                            `Avg Mass: ${avgActiveMass.toFixed(1)}  Max Mass: ${dynMaxMass.toFixed(0)}<br>`;
            debugDiv.innerHTML = debugText;
        }

        function frame() {
            const frameStart = performance.now();
            // Match nbody2.html timing tweaks
            if (loopCount === 10) { damping = 1.0; dampingSlider.value = damping.toFixed(2); dampingValueDisplay.textContent = damping.toFixed(2); writeSimParams(); }
            if (loopCount === 256) { spin = 0.0; spinSlider.value = spin.toFixed(2); spinValueDisplay.textContent = spin.toFixed(2); writeSimParams(); }

            // Update matrices if size changed
            projMatrix = perspectiveMatrix(Math.PI / 4, canvas.width / canvas.height, 0.1, 1000000);
            writeMatrices();

            const encoder = device.createCommandEncoder();

            // Compute center of mass for spin center (using current read buffer)
            {
              const bg1 = readFromA ? comReduce1BG_A : comReduce1BG_B;
              const p1 = encoder.beginComputePass();
              p1.setPipeline(comReduce1Pipeline);
              p1.setBindGroup(0, bg1);
              p1.dispatchWorkgroups(numComPartials);
              p1.end();

              const p2 = encoder.beginComputePass();
              p2.setPipeline(comReduce2Pipeline);
              p2.setBindGroup(0, comReduce2BG);
              p2.dispatchWorkgroups(1);
              p2.end();
            }

            // Per-substep params: dt and damping scaled
            const dtSub = baseDt / SUBSTEPS;
            const dampingSub = Math.pow(damping, 1.0 * dtSub);
            const effectiveG = G;           // G unscaled per request
            const effectiveR = R / massScale;
            simParamsData[0] = dtSub;      // dt
            simParamsData[1] = effectiveG; // G
            simParamsData[2] = effectiveR; // R scaled to match
            simParamsData[3] = spin * dtSub; // spin scaled by dtSub
            simParamsData[4] = EPS;        // eps (unchanged)
            simParamsData[5] = dampingSub; // per-substep damping
            simParamsData[6] = particleCount;
            simParamsData[7] = radiateCoeff; // radiative damping
            device.queue.writeBuffer(simParamsBuffer, 0, simParamsData.buffer, simParamsData.byteOffset, simParamsData.byteLength);

            // New: compute per-substep decay factor based on half-life and dtSub, and write emission params
            const decayFactor = Math.exp(-Math.LN2 * (dtSub / Math.max(1e-6, decayHalfLife)));
            emissionParamsData[0] = fusionBoost; // boost
            emissionParamsData[1] = decayFactor; // per-substep decay factor
            device.queue.writeBuffer(emissionParamsBuffer, 0, emissionParamsData.buffer, emissionParamsData.byteOffset, emissionParamsData.byteLength);

            // Compute passes: SUBSTEPS sub-iterations, ping-ponging A/B
            let localReadFromA = readFromA;
            const workgroupSize = 256;
            const workgroupCount = Math.ceil(particleCount / workgroupSize);
            for (let s = 0; s < SUBSTEPS; s++) {
                const cpass = encoder.beginComputePass();
                cpass.setPipeline(computePipeline);
                cpass.setBindGroup(0, localReadFromA ? computeBG_AtoB : computeBG_BtoA);
                cpass.dispatchWorkgroups(workgroupCount);
                cpass.end();
                localReadFromA = !localReadFromA;
            }

            // Fusion: run after integration on the latest buffers
            device.queue.writeBuffer(claimsBuffer, 0, zeroClaims); // clear claim flags
            device.queue.writeBuffer(fuseFlagsBuffer, 0, zeroFuseFlags); // clear fuse flash flags
            {
              const fpass = encoder.beginComputePass();
              fpass.setPipeline(fusionPipeline);
              fpass.setBindGroup(0, localReadFromA ? fusionBG_posA : fusionBG_posB); // operate on latest write buffers
              fpass.dispatchWorkgroups(workgroupCount);
              fpass.end();
            }

            // Mass stats pass (after fusion) + copy to CPU readback
            device.queue.writeBuffer(statsBuffer, 0, new Uint32Array(4)); // reset counters
            let copiedThisFrameIndex = -1;
            {
              const spass = encoder.beginComputePass();
              spass.setPipeline(massStatsPipeline);
              spass.setBindGroup(0, massStatsBG);
              spass.dispatchWorkgroups(workgroupCount);
              spass.end();
              // Choose a non-mapped buffer to write this frame; if none, skip copy
              let writeIdx = -1;
              for (let t = 0; t < NUM_READBACK; t++) {
                const idx = (statsWriteIndex + t) % NUM_READBACK;
                if (!statsPendingMap[idx]) { writeIdx = idx; break; }
              }
              if (writeIdx !== -1) {
                encoder.copyBufferToBuffer(statsBuffer, 0, statsReadBuffers[writeIdx], 0, 16);
                copiedThisFrameIndex = writeIdx;
                statsWriteIndex = (writeIdx + 1) % NUM_READBACK;
              }
            }

            // Recompute center of mass for rendering (using latest state)
            {
              const bg1 = localReadFromA ? comReduce1BG_A : comReduce1BG_B; // latest written buffer
              const p1 = encoder.beginComputePass();
              p1.setPipeline(comReduce1Pipeline);
              p1.setBindGroup(0, bg1);
              p1.dispatchWorkgroups(numComPartials);
              p1.end();

              const p2 = encoder.beginComputePass();
              p2.setPipeline(comReduce2Pipeline);
              p2.setBindGroup(0, comReduce2BG);
              p2.dispatchWorkgroups(1);
              p2.end();

              // Smooth the COM once per frame for stable camera tracking
              const ps = encoder.beginComputePass();
              ps.setPipeline(comSmoothPipeline);
              ps.setBindGroup(0, comSmoothBG);
              ps.dispatchWorkgroups(1);
              ps.end();
            }

            // Render pass after last substep
            const colorView = context.getCurrentTexture().createView();
            const rpass = encoder.beginRenderPass({
                colorAttachments: [{ view: colorView, clearValue: { r:0, g:0, b:0, a:1 }, loadOp: 'clear', storeOp: 'store' }]
            });
            rpass.setPipeline(renderPipeline);
            rpass.setVertexBuffer(0, quadVB);
            rpass.setIndexBuffer(quadIB, 'uint16');
            rpass.setBindGroup(0, localReadFromA ? renderBG_posA : renderBG_posB); // latest is the write buffer from final substep
            rpass.drawIndexed(6, particleCount, 0, 0, 0);
            rpass.end();

            device.queue.submit([encoder.finish()]);

            // Read last frame's results (buffer we wrote in the previous frame)
            if (lastCopiedIndex !== -1 && !statsPendingMap[lastCopiedIndex]) {
              const readIdx = lastCopiedIndex;
              statsPendingMap[readIdx] = true;
              statsReadBuffers[readIdx].mapAsync(GPUMapMode.READ).then(() => {
                const u8 = new Uint8Array(statsReadBuffers[readIdx].getMappedRange());
                const dv = new DataView(u8.buffer, u8.byteOffset, u8.byteLength);
                const active = dv.getUint32(0, true);
                const maxBits = dv.getUint32(4, true);
                const maxMassF = new Float32Array(new Uint32Array([maxBits]).buffer)[0];
                statsReadBuffers[readIdx].unmap();
                statsPendingMap[readIdx] = false;
                dynActiveCount = Math.max(1, active);
                dynMaxMass = Math.max(1.0, maxMassF);
                // Update matrices for next frame's normalization
                writeMatrices();
              }).catch(() => { statsPendingMap[readIdx] = false; /* ignore on navigation */ });
            }

            // Remember which buffer we wrote this frame so we can read it next frame (if we wrote any)
            if (copiedThisFrameIndex !== -1) { lastCopiedIndex = copiedThisFrameIndex; }

            // Update global readFromA for next frame
            readFromA = localReadFromA;

            loopCount+=1;
            lastFrameMs = performance.now() - frameStart;
            updateDebug();
            requestAnimationFrame(frame);
        }
        frame();
    })();
    </script>
</body>

</html>
